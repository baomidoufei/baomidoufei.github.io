

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="彭">
  <meta name="keywords" content="">
  
    <meta name="description" content="事务事务四大特性 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。  上述就是事务">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL">
<meta property="og:url" content="http://example.com/2023/04/13/MySQL/index.html">
<meta property="og:site_name" content="PJF">
<meta property="og:description" content="事务事务四大特性 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。  上述就是事务">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/mysql_pic/37.png">
<meta property="og:image" content="http://example.com/mysql_pic/38.png">
<meta property="og:image" content="http://example.com/mysql_pic/39.png">
<meta property="og:image" content="http://example.com/mysql_pic/40.png">
<meta property="og:image" content="http://example.com/mysql_pic/1.png">
<meta property="og:image" content="http://example.com/mysql_pic/2.png">
<meta property="og:image" content="http://example.com/mysql_pic/3.png">
<meta property="og:image" content="http://example.com/mysql_pic/4.png">
<meta property="og:image" content="http://example.com/mysql_pic/85.png">
<meta property="og:image" content="http://example.com/mysql_pic/86.png">
<meta property="og:image" content="http://example.com/mysql_pic/87.png">
<meta property="og:image" content="http://example.com/mysql_pic/88.png">
<meta property="og:image" content="http://example.com/mysql_pic/89.png">
<meta property="og:image" content="http://example.com/mysql_pic/90.png">
<meta property="og:image" content="http://example.com/mysql_pic/91.png">
<meta property="og:image" content="http://example.com/mysql_pic/92.png">
<meta property="og:image" content="http://example.com/mysql_pic/93.png">
<meta property="og:image" content="http://example.com/mysql_pic/94.png">
<meta property="og:image" content="http://example.com/mysql_pic/95.png">
<meta property="og:image" content="http://example.com/mysql_pic/96.png">
<meta property="og:image" content="http://example.com/mysql_pic/61.png">
<meta property="og:image" content="http://example.com/mysql_pic/62.png">
<meta property="og:image" content="http://example.com/mysql_pic/63.png">
<meta property="og:image" content="http://example.com/mysql_pic/64.png">
<meta property="og:image" content="http://example.com/mysql_pic/65.png">
<meta property="og:image" content="http://example.com/mysql_pic/66.png">
<meta property="og:image" content="http://example.com/mysql_pic/67.png">
<meta property="og:image" content="http://example.com/mysql_pic/68.png">
<meta property="og:image" content="http://example.com/mysql_pic/69.png">
<meta property="og:image" content="http://example.com/mysql_pic/70.png">
<meta property="og:image" content="http://example.com/mysql_pic/71.png">
<meta property="og:image" content="http://example.com/mysql_pic/72.png">
<meta property="og:image" content="http://example.com/mysql_pic/73.png">
<meta property="og:image" content="http://example.com/mysql_pic/74.png">
<meta property="og:image" content="http://example.com/mysql_pic/75.png">
<meta property="og:image" content="http://example.com/mysql_pic/76.png">
<meta property="og:image" content="http://example.com/mysql_pic/77.png">
<meta property="og:image" content="http://example.com/mysql_pic/77.png">
<meta property="og:image" content="http://example.com/mysql_pic/78.png">
<meta property="og:image" content="http://example.com/mysql_pic/79.png">
<meta property="og:image" content="http://example.com/mysql_pic/80.png">
<meta property="og:image" content="http://example.com/mysql_pic/81.png">
<meta property="og:image" content="http://example.com/mysql_pic/82.png">
<meta property="og:image" content="http://example.com/mysql_pic/83.png">
<meta property="og:image" content="http://example.com/mysql_pic/84.png">
<meta property="og:image" content="http://example.com/mysql_pic/17.png">
<meta property="og:image" content="http://example.com/mysql_pic/18.png">
<meta property="og:image" content="http://example.com/mysql_pic/19.png">
<meta property="og:image" content="http://example.com/mysql_pic/20.png">
<meta property="og:image" content="http://example.com/mysql_pic/21.png">
<meta property="og:image" content="http://example.com/mysql_pic/22.png">
<meta property="og:image" content="http://example.com/mysql_pic/23.png">
<meta property="og:image" content="http://example.com/mysql_pic/24.png">
<meta property="og:image" content="http://example.com/mysql_pic/25.png">
<meta property="og:image" content="http://example.com/mysql_pic/26.png">
<meta property="og:image" content="http://example.com/mysql_pic/27.png">
<meta property="og:image" content="http://example.com/mysql_pic/28.png">
<meta property="og:image" content="http://example.com/mysql_pic/29.png">
<meta property="og:image" content="http://example.com/mysql_pic/30.png">
<meta property="og:image" content="http://example.com/mysql_pic/31.png">
<meta property="og:image" content="http://example.com/mysql_pic/32.png">
<meta property="og:image" content="http://example.com/mysql_pic/33.png">
<meta property="og:image" content="http://example.com/mysql_pic/34.png">
<meta property="og:image" content="http://example.com/mysql_pic/35.png">
<meta property="og:image" content="http://example.com/mysql_pic/36.png">
<meta property="og:image" content="http://example.com/mysql_pic/5.png">
<meta property="og:image" content="http://example.com/mysql_pic/6.png">
<meta property="og:image" content="http://example.com/mysql_pic/7.png">
<meta property="og:image" content="http://example.com/mysql_pic/9.png">
<meta property="og:image" content="http://example.com/mysql_pic/10.png">
<meta property="og:image" content="http://example.com/mysql_pic/8.png">
<meta property="og:image" content="http://example.com/mysql_pic/11.png">
<meta property="og:image" content="http://example.com/mysql_pic/12.png">
<meta property="og:image" content="http://example.com/mysql_pic/13.png">
<meta property="og:image" content="http://example.com/mysql_pic/14.png">
<meta property="og:image" content="http://example.com/mysql_pic/15.png">
<meta property="og:image" content="http://example.com/mysql_pic/16.png">
<meta property="og:image" content="http://example.com/mysql_pic/41.png">
<meta property="og:image" content="http://example.com/mysql_pic/42.png">
<meta property="og:image" content="http://example.com/mysql_pic/43.png">
<meta property="og:image" content="http://example.com/mysql_pic/44.png">
<meta property="og:image" content="http://example.com/mysql_pic/45.png">
<meta property="og:image" content="http://example.com/mysql_pic/46.png">
<meta property="og:image" content="http://example.com/mysql_pic/47.png">
<meta property="og:image" content="http://example.com/mysql_pic/48.png">
<meta property="og:image" content="http://example.com/mysql_pic/49.png">
<meta property="og:image" content="http://example.com/mysql_pic/50.png">
<meta property="og:image" content="http://example.com/mysql_pic/51.png">
<meta property="og:image" content="http://example.com/mysql_pic/45.png">
<meta property="og:image" content="http://example.com/mysql_pic/52.png">
<meta property="og:image" content="http://example.com/mysql_pic/53.png">
<meta property="og:image" content="http://example.com/mysql_pic/54.png">
<meta property="og:image" content="http://example.com/mysql_pic/55.png">
<meta property="og:image" content="http://example.com/mysql_pic/56.png">
<meta property="og:image" content="http://example.com/mysql_pic/57.png">
<meta property="og:image" content="http://example.com/mysql_pic/58.png">
<meta property="og:image" content="http://example.com/mysql_pic/59.png">
<meta property="og:image" content="http://example.com/mysql_pic/60.png">
<meta property="article:published_time" content="2023-04-13T02:56:39.937Z">
<meta property="article:modified_time" content="2023-05-29T15:20:07.631Z">
<meta property="article:author" content="彭">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/mysql_pic/37.png">
  
  
  
  <title>MySQL - PJF</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>PJF</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="MySQL"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-13 10:56" pubdate>
          April 13, 2023 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          24k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          201 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">MySQL</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h3><ul>
<li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li>
<li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li>
<li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。</li>
<li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
<p>上述就是事务的四大特性，简称ACID。</p>
<h3 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h3><ul>
<li>赃读：一个事务读到另外一个事务还没有提交的数据。</li>
</ul>
<p><img src="/../mysql_pic/37.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</li>
</ul>
<p><img src="/../mysql_pic/38.png" srcset="/img/loading.gif" lazyload></p>
<p>事务A两次读取同一条记录，但是读取到的数据却是不一样的.</p>
<ul>
<li>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 “幻影”</li>
</ul>
<p><img src="/../mysql_pic/39.png" srcset="/img/loading.gif" lazyload></p>
<p>为什么会出现幻读？因为已经解决了上面的不可重复度，所以两次查询的结果是一样的，误以为没有数据，其实事务B已经插入了。</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：</p>
<p><img src="/../mysql_pic/40.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>查看事务隔离级别</li>
</ul>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">SELECT</span> @<span class="hljs-symbol">@TRANSACTION_ISOLATION</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>设置事务隔离级别</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SET</span> [ <span class="hljs-keyword">SESSION</span> | <span class="hljs-keyword">GLOBAL</span> ] <span class="hljs-keyword">TRANSACTION</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> &#123; <span class="hljs-keyword">READ</span> <span class="hljs-keyword">UNCOMMITTED</span> |<br><span class="hljs-keyword">READ</span> <span class="hljs-keyword">COMMITTED</span> | <span class="hljs-keyword">REPEATABLE</span> <span class="hljs-keyword">READ</span> | <span class="hljs-keyword">SERIALIZABLE</span> &#125;<br></code></pre></td></tr></table></figure>

<p>事务隔离级别越高，数据越安全，但是性能越低</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是帮助MySQL高效获取数据的数据结构(有序)。</p>
<p><img src="/../mysql_pic/1.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p><strong>聚簇索引（Clustered Index）即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引</strong></p>
<p>聚簇索引（Clustered Index）一般指的是主键索引（如果存在主键索引的话），聚簇索引也被称之为聚集索引。</p>
<p>聚簇索引在 InnoDB 中是使用 B+ 树实现的，比如我们创建一张 student 表，它的构建 SQL 如下：</p>
<p><img src="/../mysql_pic/2.png" srcset="/img/loading.gif" lazyload></p>
<p>以上 student 表中有一个聚簇索引（也就是主键索引）id，和一个非聚簇索引 class_id。</p>
<p>聚簇索引 id 对应的 B+ 树如下图所示：</p>
<p><img src="/../mysql_pic/3.png" srcset="/img/loading.gif" lazyload></p>
<p>在聚簇索引的叶子节点的data区直接存储用户信息的内存地址，我们使用内存地址可以直接找到相应的行数据。</p>
<h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>非聚簇索引在 InnoDB 引擎中，也叫二级索引，以上面 student 表为例，在 student 中非聚簇索引 class_id 对应 B+ 树如下图所示：</p>
<p><img src="/../mysql_pic/4.png" srcset="/img/loading.gif" lazyload></p>
<p>从上图我们可以看出，<strong>在非聚簇索引的叶子节点上的data存储的并不是真正的行数据，而是主键 ID，所以当我们使用非聚簇索引进行查询时，首先会得到一个主键 ID，然后再使用主键 ID 去聚簇索引上找到真正的行数据，我们把这个过程称之为回表查询。</strong></p>
<p><strong>总结：</strong></p>
<p>在 MySQL 的 InnoDB 引擎中，每个索引都会对应一颗 B+ 树，而聚簇索引和非聚簇索引最大的区别在于叶子节点存储的数据不同，聚簇索引叶子节点存储的是行数据，因此通过聚簇索引可以直接找到真正的行数据；而非聚簇索引叶子节点存储的是主键信息，所以使用非聚簇索引还需要回表查询，因此我们可以得出聚簇索引和非聚簇索引的区别主要有以下几个：</p>
<ul>
<li>聚簇索引叶子节点data存储的是行数据；而非聚簇索引叶子节点data存储的是聚簇索引（通常是主键 ID）。</li>
<li>聚簇索引查询效率更高，而非聚簇索引需要进行回表查询，因此性能不如聚簇索引。</li>
<li>聚簇索引一般为主键索引，而主键一个表中只能有一个，因此聚簇索引一个表中也只能有一个，而非聚簇索引则没有数量上的限制。</li>
</ul>
<h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><h4 id="对索引使用左或者左右模糊匹配"><a href="#对索引使用左或者左右模糊匹配" class="headerlink" title="对索引使用左或者左右模糊匹配"></a>对索引使用左或者左右模糊匹配</h4><p>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效。</p>
<p>比如下面的 like 语句，查询 name 后缀为「林」的用户，执行计划中的 type&#x3D;ALL 就代表了全表扫描，而没有走索引。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-type">name</span> 字段为二级索引<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%林&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/../mysql_pic/85.png" srcset="/img/loading.gif" lazyload></p>
<p>如果是查询 name 前缀为林的用户，那么就会走索引扫描，执行计划中的 type&#x3D;range 表示走索引扫描，key&#x3D;index_name 看到实际走了 index_name 索引：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-type">name</span> 字段为二级索引<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;林%&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/../mysql_pic/86.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>为什么 like 关键字左或者左右模糊匹配无法走索引呢？</strong></p>
<p><strong>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</strong></p>
<p>举个例子，下面这张二级索引图是以 name 字段有序排列存储的。</p>
<p><img src="/../mysql_pic/87.png" srcset="/img/loading.gif" lazyload></p>
<p>假设我们要查询 name 字段前缀为「林」的数据，也就是 <code>name like &#39;林%&#39;</code>，扫描索引的过程：</p>
<ul>
<li>首节点查询比较：林这个字的拼音大小比首节点的第一个索引值中的陈字大，但是比首节点的第二个索引值中的周字小，所以选择去节点2继续查询；</li>
<li>节点 2 查询比较：节点2的第一个索引值中的陈字的拼音大小比林字小，所以继续看下一个索引值，发现节点2有与林字前缀匹配的索引值，于是就往叶子节点查询，即叶子节点4；</li>
<li>节点 4 查询比较：节点4的第一个索引值的前缀符合林字，于是就读取该行数据，接着继续往右匹配，直到匹配不到前缀为林的索引值。</li>
</ul>
<p>如果使用 <code>name like &#39;%林&#39;</code> 方式来查询，因为查询的结果可能是「陈林、张林、周林」等之类的，所以不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。</p>
<h4 id="对索引使用函数"><a href="#对索引使用函数" class="headerlink" title="对索引使用函数"></a>对索引使用函数</h4><p>有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。</p>
<p>比如下面这条语句查询条件中对 name 字段使用了 LENGTH 函数，执行计划中的 type&#x3D;ALL，代表了全表扫描：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-type">name</span> 为二级索引<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> length(<span class="hljs-type">name</span>)=<span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/../mysql_pic/88.png" srcset="/img/loading.gif" lazyload></p>
<p><code>为什么对索引使用函数，就无法走索引了呢？</code></p>
<p><strong>因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</strong></p>
<p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p>
<p>举个例子，我通过下面这条语句，对 length(name) 的计算结果建立一个名为 idx_name_length 的索引。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t_user <span class="hljs-keyword">add</span> key idx_name_length ((length(<span class="hljs-type">name</span>)));<br></code></pre></td></tr></table></figure>

<p>然后我再用下面这条查询语句，这时候就会走索引了。</p>
<p><img src="/../mysql_pic/89.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="对索引进行表达式计算"><a href="#对索引进行表达式计算" class="headerlink" title="对索引进行表达式计算"></a>对索引进行表达式计算</h4><p>在查询条件中对索引进行表达式计算，也是无法走索引的。</p>
<p>比如，下面这条查询语句，执行计划中 type &#x3D; ALL，说明是通过全表扫描的方式查询数据的：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id + <span class="hljs-number">1</span> = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<p>但是，如果把查询语句的条件改成 where id &#x3D; 10 - 1，这样就不是在索引字段进行表达式计算了，于是就可以走索引查询了。</p>
<p><code>为什么对索引进行表达式计算，就无法走索引了呢？</code></p>
<p>原因跟对索引使用函数差不多。</p>
<p>因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。</p>
<h4 id="对索引隐式类型转换"><a href="#对索引隐式类型转换" class="headerlink" title="对索引隐式类型转换"></a>对索引隐式类型转换</h4><p>如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。</p>
<p>我在原本的 t_user 表增加了 phone 字段，是二级索引且类型是 varchar。</p>
<p><img src="/../mysql_pic/90.png" srcset="/img/loading.gif" lazyload></p>
<p>然后我在条件查询中，用整型作为输入参数，此时执行计划中 type &#x3D; ALL，所以是通过全表扫描来查询数据的。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">select * from t_user where phone = 1300000001;<br></code></pre></td></tr></table></figure>

<p><img src="/../mysql_pic/91.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>但是如果索引字段是整型类型，查询条件中的输入参数即使字符串，是不会导致索引失效，还是可以走索引扫描。</strong></p>
<p>我们再看第二个例子，id 是整型，但是下面这条语句还是走了索引扫描的。</p>
<p><img src="/../mysql_pic/92.png" srcset="/img/loading.gif" lazyload></p>
<p><code>为什么第一个例子会导致索引失效，而第二例子不会呢？</code></p>
<p>要明白这个原因，首先我们要知道 MySQL 的数据类型转换规则是什么？就是看 MySQL 是会将字符串转成数字处理，还是将数字转换成字符串处理。</p>
<p>我在看《mysql45讲的时候》看到一个简单的测试方式，就是通过 select “10” &gt; 9 的结果来知道MySQL 的数据类型转换规则是什么：</p>
<ul>
<li>如果规则是 MySQL 会将自动「字符串」转换成「数字」，就相当于 select 10 &gt; 9，这个就是数字比较，所以结果应该是 1；</li>
<li>如果规则是 MySQL 会将自动「数字」转换成「字符串」，就相当于 select “10” &gt; “9”，这个是字符串比较，字符串比较大小是逐位从高位到低位逐个比较（按ascii码） ，那么”10”字符串相当于 “1”和“0”字符的组合，所以先是拿 “1” 字符和 “9” 字符比较，因为 “1” 字符比 “9” 字符小，所以结果应该是 0。</li>
</ul>
<p>在 MySQL 中，执行的结果如下图：</p>
<p><img src="/../mysql_pic/93.png" srcset="/img/loading.gif" lazyload></p>
<p>上面的结果为 1，说明 <strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong>。</p>
<p>前面的例子一中的查询语句，我也跟大家说了是会走全表扫描：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//例子一的查询语句</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> phone = <span class="hljs-number">1300000001</span>;<br></code></pre></td></tr></table></figure>

<p>这是因为 phone 字段为字符串，所以 MySQL 要会自动把字符串转为数字，所以这条语句相当于：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> CAST(phone <span class="hljs-keyword">AS</span> signed <span class="hljs-type">int</span>) = <span class="hljs-number">1300000001</span>;<br></code></pre></td></tr></table></figure>

<p>可以看到，<strong>CAST 函数是作用在了 phone 字段，而 phone 字段是索引，也就是对索引使用了函数！而前面我们也说了，对索引使用函数是会导致索引失效的</strong>。</p>
<p>例子二中的查询语句，我跟大家说了是会走索引扫描：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//例子二的查询语句</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id = <span class="hljs-string">&quot;1&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>这时因为字符串部分是输入参数，也就需要将字符串转为数字，所以这条语句相当于：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id = CAST(&quot;1&quot; <span class="hljs-keyword">AS</span> signed <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure>

<p>可以看到，索引字段并没有用任何函数，CAST 函数是用在了输入参数，因此是可以走索引扫描的</p>
<h4 id="联合索引非最左匹配"><a href="#联合索引非最左匹配" class="headerlink" title="联合索引非最左匹配"></a>联合索引非最左匹配</h4><p>对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。</p>
<p>那么<strong>多个普通字段组合在一起创建的索引就叫做联合索引</strong>，也叫组合索引。</p>
<p>创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。</p>
<p>联合索引要能正确使用需要遵循<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。</p>
<p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p>
<ul>
<li>where a&#x3D;1；</li>
<li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li>
<li>where a&#x3D;1 and b&#x3D;2；</li>
</ul>
<p><strong>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</strong></p>
<p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p>
<ul>
<li>where b&#x3D;2；</li>
<li>where c&#x3D;3；</li>
<li>where b&#x3D;2 and c&#x3D;3；</li>
</ul>
<p>有一个比较特殊的查询条件：where a &#x3D; 1 and c &#x3D; 3 ，符合最左匹配吗？</p>
<p>MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。</p>
<p>从 MySQL 5.6 之后，有一个<strong>索引下推功能</strong>，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。</p>
<p>索引下推的大概原理是：截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 <code>(a, b, c)</code> 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。</p>
<p>比如下面这条 where a &#x3D; 1 and c &#x3D; 0 语句，我们可以从执行计划中的 Extra&#x3D;Using index condition 使用了索引下推功能。</p>
<p><img src="/../mysql_pic/94.png" srcset="/img/loading.gif" lazyload></p>
<p><code>为什么联合索引不遵循最左匹配原则就会失效？</code></p>
<p>原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</p>
<p>也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。</p>
<h4 id="WHERE-子句中的-OR"><a href="#WHERE-子句中的-OR" class="headerlink" title="WHERE 子句中的 OR"></a>WHERE 子句中的 OR</h4><p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p>
<p>举个例子，比如下面的查询语句，id 是主键，age 是普通列，从执行计划的结果看，是走了全表扫描。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">select * from t_user where id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> or age <span class="hljs-operator">=</span> <span class="hljs-number">18</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><img src="/../mysql_pic/95.png" srcset="/img/loading.gif" lazyload></p>
<p>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</p>
<p>要解决办法很简单，将 age 字段设置为索引即可。</p>
<p><img src="/../mysql_pic/96.png" srcset="/img/loading.gif" lazyload></p>
<p>可以看到 type&#x3D;index merge， index merge 的意思就是对 id 和 age 分别进行了扫描，然后将这两个结果集进行了合并，这样做的好处就是避免了全表扫描</p>
<p><strong>总结</strong></p>
<p>今天给大家介绍了 6 种会发生索引失效的情况：</p>
<ul>
<li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li>
<li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li>
<li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li>
<li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li>
<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li>
<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li>
</ul>
<h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;tom&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;cat&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;jerry&#x27;</span>);<br>.....<br></code></pre></td></tr></table></figure>

<ul>
<li>优化方案一</li>
</ul>
<p><strong>批量插入数据</strong></p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">Insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li>优化方案二</li>
</ul>
<p><strong>手动控制事务</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">begine;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">7</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>优化方案三</li>
</ul>
<p>主键顺序插入，性能要高于乱序插入。</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">主键乱序插入 :<span class="hljs-number"> 8 </span>1<span class="hljs-number"> 9 </span>21<span class="hljs-number"> 88 </span>2<span class="hljs-number"> 4 </span>15<span class="hljs-number"> 89 </span>5<span class="hljs-number"> 7 </span>3<br>主键顺序插入 :<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 5 </span>7<span class="hljs-number"> 8 </span>9<span class="hljs-number"> 15 </span>21<span class="hljs-number"> 88 </span>89<br></code></pre></td></tr></table></figure>

<h4 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h4><p>如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使 用MySQL数据库提供的load指令进行插入。操作如下：</p>
<p><img src="/../mysql_pic/61.png" srcset="/img/loading.gif" lazyload></p>
<p>可以执行如下指令，将数据脚本文件中的数据加载到表结构中：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 客户端连接服务端时，加上参数 -–local-infile</span><br>mysql –-<span class="hljs-keyword">local</span>-infile -u root -p<br><br><span class="hljs-comment">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> local_infile = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">-- 执行load指令将准备好的数据，加载到表结构中</span><br><span class="hljs-keyword">load</span> data <span class="hljs-keyword">local</span> infile <span class="hljs-string">&#x27;/root/sql1.log&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> tb_user fields<br>terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;,&#x27;</span> lines terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\n&#x27;</span> ;<br></code></pre></td></tr></table></figure>

<p><code>主键顺序插入性能高于乱序插入</code></p>
<p>演示：</p>
<ul>
<li>创建表结构</li>
</ul>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`tb_user`</span> (<br><span class="hljs-symbol">`id`</span> INT(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,<br><span class="hljs-symbol">`username`</span> VARCHAR(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br><span class="hljs-symbol">`password`</span> VARCHAR(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br><span class="hljs-symbol">`name`</span> VARCHAR(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br><span class="hljs-symbol">`birthday`</span> DATE DEFAULT <span class="hljs-literal">NULL</span>,<br><span class="hljs-symbol">`sex`</span> CHAR(<span class="hljs-number">1</span>) DEFAULT <span class="hljs-literal">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>),<br><span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`unique_user_username`</span> (<span class="hljs-symbol">`username`</span>)<br>) ENGINE=INNODB DEFAULT CHARSET=utf8 ;<br></code></pre></td></tr></table></figure>

<ul>
<li>设置参数</li>
</ul>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">-- 客户端连接服务端时，加上参数 -–<span class="hljs-keyword">local</span>-<span class="hljs-keyword">infile</span><br>mysql –-<span class="hljs-keyword">local</span>-<span class="hljs-keyword">infile</span> -<span class="hljs-keyword">u</span> root -p<br><br>-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> local_infile = 1;<br></code></pre></td></tr></table></figure>

<ul>
<li>load加载数据</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">load</span> data <span class="hljs-keyword">local</span> infile <span class="hljs-string">&#x27;/root/load_user_100w_sort.sql&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> tb_user<br>fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;,&#x27;</span> lines terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\n&#x27;</span> ;<br></code></pre></td></tr></table></figure>

<p>我们看到，插入100w的记录，17s就完成了，性能很好。</p>
<p><code>在load时，主键顺序插入性能高于乱序插入</code></p>
<h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p>在上一小节，我们提到，主键顺序插入的性能是要高于乱序插入的。 这一小节，就来介绍一下具体的 原因，然后再分析一下主键又该如何设计。</p>
<ul>
<li>数据组织方式</li>
</ul>
<p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表 (index organized table IOT)。</p>
<p><img src="/../mysql_pic/62.png" srcset="/img/loading.gif" lazyload></p>
<p>行数据，都是存储在聚集索引的叶子节点上的。而我们之前也讲解过InnoDB的逻辑结构图：</p>
<p><img src="/../mysql_pic/63.png" srcset="/img/loading.gif" lazyload></p>
<p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。 那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储 到下一个页中，页与页之间会通过指针连接。</p>
<h4 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h4><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行 溢出)，根据主键排列。</p>
<p> 主键顺序插入效果：</p>
<ul>
<li>从磁盘中申请页， 主键顺序插入</li>
</ul>
<p><img src="/../mysql_pic/64.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>第一个页没有满，继续往第一页插入</li>
</ul>
<p><img src="/../mysql_pic/65.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</li>
</ul>
<p><img src="/../mysql_pic/66.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>当第二页写满了，再往第三页写入</li>
</ul>
<p><img src="/../mysql_pic/67.png" srcset="/img/loading.gif" lazyload></p>
<p>主键乱序插入效果：</p>
<ul>
<li>加入1#,2#页都已经写满了，存放了如图所示的数据</li>
</ul>
<p><img src="/../mysql_pic/68.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>此时再插入id为50的记录，我们来看看会发生什么现象</li>
</ul>
<p>会再次开启一个页，写入新的页中吗？</p>
<p><img src="/../mysql_pic/69.png" srcset="/img/loading.gif" lazyload></p>
<p>不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在47之后。</p>
<p><img src="/../mysql_pic/70.png" srcset="/img/loading.gif" lazyload></p>
<p>但是47所在的1#页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 3#。</p>
<p><img src="/../mysql_pic/71.png" srcset="/img/loading.gif" lazyload></p>
<p>上述的这种现象，称之为 “页分裂”，是比较耗费性能的操作。</p>
<h4 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h4><p>目前表中已有数据的索引结构(叶子节点)如下：</p>
<p><img src="/../mysql_pic/72.png" srcset="/img/loading.gif" lazyload></p>
<p>当我们对已有数据进行删除时，具体的效果如下:</p>
<p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间 变得允许被其他记录声明使用。</p>
<p><img src="/../mysql_pic/73.png" srcset="/img/loading.gif" lazyload></p>
<p>当我们继续删除2#的数据记录</p>
<p><img src="/../mysql_pic/74.png" srcset="/img/loading.gif" lazyload></p>
<p>这个里面所发生的合并页的这个现象，就称之为 “页合并”。</p>
<p><code>知识小贴士： MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</code></p>
<h4 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h4><ul>
<li>满足业务需求的情况下，尽量降低主键的长度</li>
<li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li>
<li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li>
<li>业务操作时，避免对主键的修改。</li>
</ul>
<h3 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h3><p>MySQL的排序，有两种方式(explain分析时看extra字段)：</p>
<ul>
<li>Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</li>
<li>Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要 额外排序，操作效率高。</li>
</ul>
<p>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序 操作时，尽量要优化为 Using index。</p>
<p>接下来，我们来做一个测试：</p>
<ul>
<li>数据准备</li>
</ul>
<p>把之前测试时，为tb_user表所建立的部分索引直接删除掉</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_user_phone <span class="hljs-keyword">on</span> tb_user;<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_user_phone_name <span class="hljs-keyword">on</span> tb_user;<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_user_name <span class="hljs-keyword">on</span> tb_user;<br></code></pre></td></tr></table></figure>

<ul>
<li>执行排序SQL</li>
</ul>
<p>explain select id,age,phone from tb_user order by age ;</p>
<p><img src="/../mysql_pic/75.png" srcset="/img/loading.gif" lazyload></p>
<p>explain select id,age,phone from tb_user order by age, phone ;</p>
<p><img src="/../mysql_pic/76.png" srcset="/img/loading.gif" lazyload></p>
<p>由于 age, phone 都没有索引，所以此时再排序时，出现Using filesort， 排序性能较低。</p>
<ul>
<li>创建索引</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 创建索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_user_age_phone_aa <span class="hljs-keyword">on</span> tb_user(age,phone);<br></code></pre></td></tr></table></figure>

<ul>
<li>创建索引后，根据age, phone进行升序排序</li>
</ul>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age;<br></code></pre></td></tr></table></figure>

<p><img src="/../mysql_pic/77.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age , phone;<br></code></pre></td></tr></table></figure>

<p><img src="/../mysql_pic/77.png" srcset="/img/loading.gif" lazyload></p>
<p>建立索引之后，再次进行排序查询，就由原来的Using filesort， 变为了 Using index，性能 就是比较高的了。</p>
<p>E. 创建索引后，根据age, phone进行降序排序</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">desc</span> , phone <span class="hljs-keyword">desc</span> ;<br></code></pre></td></tr></table></figure>

<p><img src="/../mysql_pic/78.png" srcset="/img/loading.gif" lazyload></p>
<p>也出现 Using index， 但是此时Extra中出现了 Backward index scan，这个代表反向扫描索 引，因为在MySQL中我们创建的索引，默认索引的叶子节点是从小到大排序的，而此时我们查询排序 时，是从大到小，所以，在扫描时，就是反向扫描，就会出现 Backward index scan。 在 MySQL8版本中，支持降序索引，我们也可以创建降序索引。</p>
<ul>
<li>根据phone，age进行升序排序，phone在前，age在后。</li>
</ul>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> phone , age;<br></code></pre></td></tr></table></figure>

<p><img src="/../mysql_pic/79.png" srcset="/img/loading.gif" lazyload></p>
<p>排序时,也需要满足最左前缀法则,否则也会出现 filesort。因为在创建索引的时候， age是第一个 字段，phone是第二个字段，所以排序时，也就该按照这个顺序来，否则就会出现 Using filesort。</p>
<ul>
<li>创建联合索引(age 升序排序，phone 倒序排序)</li>
</ul>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_user_age_phone_ad <span class="hljs-keyword">on</span> tb_user(age <span class="hljs-keyword">asc</span> ,phone <span class="hljs-keyword">desc</span>);<br></code></pre></td></tr></table></figure>

<p>升序&#x2F;降序联合索引结构图示:</p>
<p><img src="/../mysql_pic/80.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/../mysql_pic/81.png" srcset="/img/loading.gif" lazyload></p>
<p>由上述的测试,我们得出order by优化原则:</p>
<ul>
<li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li>
<li>尽量使用覆盖索引。</li>
<li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）。</li>
<li>果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)。</li>
</ul>
<h3 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h3><p>分组操作，我们主要来看看索引对于分组操作的影响。</p>
<p>首先我们先将 tb_user 表的索引全部删除掉.</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_user_pro_age_sta <span class="hljs-keyword">on</span> tb_user;<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_email_5 <span class="hljs-keyword">on</span> tb_user;<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_user_age_phone_aa <span class="hljs-keyword">on</span> tb_user;<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_user_age_phone_ad <span class="hljs-keyword">on</span> tb_user;<br></code></pre></td></tr></table></figure>

<p>接下来，在没有索引的情况下，执行如下SQL，查询执行计划：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> profession , <span class="hljs-built_in">count</span>(*) <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> profession<br></code></pre></td></tr></table></figure>

<p><img src="/../mysql_pic/82.png" srcset="/img/loading.gif" lazyload></p>
<p>使用临时表，性能较低</p>
<p>然后，我们在针对于 profession ， age， status 创建一个联合索引。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">create index idx_user_pro_age_sta on tb<span class="hljs-constructor">_user(<span class="hljs-params">profession</span> , <span class="hljs-params">age</span> , <span class="hljs-params">status</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>紧接着，再执行前面相同的SQL查看执行计划。</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> profession , <span class="hljs-built_in">count</span>(*) <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> profession <br></code></pre></td></tr></table></figure>

<p><img src="/../mysql_pic/83.png" srcset="/img/loading.gif" lazyload></p>
<p>我们发现，如果仅仅根据age分组，就会出现 Using temporary ；而如果是 根据 profession,age两个字段同时分组，则不会出现 Using temporary。原因是因为对于分组操作， 在联合索引中，也是符合最左前缀法则的。</p>
<p>所以，在分组操作中，我们需要通过以下两点进行优化，以提升性能：</p>
<ul>
<li>在分组操作时，可以通过索引来提高效率。</li>
<li>分组操作时，索引的使用也是满足最左前缀法则的。</li>
</ul>
<h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h3><p><code>select count(*) from tb_user</code></p>
<p>在之前的测试中，我们发现，如果数据量很大，在执行count操作时，是非常耗时的。</p>
<ul>
<li><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个 数，效率很高； 但是如果是带条件的count，MyISAM也慢。</p>
</li>
<li><p>InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出 来，然后累积计数。</p>
</li>
</ul>
<p>如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数 据库进行,但是如果是带条件的count又比较麻烦了)。</p>
<p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加，最后返回累计值。 用法：count（*）、count（主键）、count（字段）、count（数字）</p>
<p><img src="/../mysql_pic/84.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h3><p>我们主要需要注意一下update语句执行时的注意事项。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span> course <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;javaEE&#x27;</span> <span class="hljs-keyword">where</span> id = <span class="hljs-number">1</span> ;<br></code></pre></td></tr></table></figure>

<p>当我们在执行删除的SQL语句时，会锁定id为1这一行的数据，然后事务提交之后，行锁释放。</p>
<p>但是当我们在执行如下SQL时。</p>
 <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span> course <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;SpringBoot&#x27;</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;PHP&#x27;</span> ;<br></code></pre></td></tr></table></figure>

<p>当我们开启多个事务，在执行上述的SQL时，我们发现行锁升级为了表锁。 导致该update语句的性能 大大降低</p>
<p><code>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁 升级为表锁 。</code></p>
<p><strong>所以我们应该给条件创建索引，不然行锁会升级为表锁，并发性能降低</strong></p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、 RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有 效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个 角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>
<p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p>
<ul>
<li>全局锁：锁定数据库中的所有表。</li>
<li>表级锁：每次操作锁住整张表。</li>
<li>行级锁：每次操作锁住对应的行数据。</li>
</ul>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语 句，已经更新操作的事务提交语句都将被阻塞。</p>
<p>其典型的使用场景是做**全库的逻辑备份(把表转为SQL文件)**，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p>
<p>为什么全库逻辑备份，就需要加全就锁呢？</p>
<p>下个单总不能表A库存没扣减，表B多了一条订单记录吧。</p>
<p><strong>加全局锁语法</strong></p>
<ul>
<li>加全局锁</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">flush <span class="hljs-keyword">tables</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">lock</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>数据备份</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">mysqldump -uroot –p1234 <span class="hljs-built_in">itcast</span>(数据库名) &gt; itcast<span class="hljs-selector-class">.sql</span><br></code></pre></td></tr></table></figure>

<p>也可以利用可视化软件直接备份</p>
<ul>
<li>释放锁</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">unlock tables<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><strong>特点</strong></p>
<p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p>
<ul>
<li><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</p>
</li>
<li><p>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</p>
</li>
</ul>
<p>在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致 性数据备份。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mysqldump <span class="hljs-comment">--single-transaction -uroot –p123456 itcast &gt; itcast.sql</span><br></code></pre></td></tr></table></figure>

<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、 InnoDB、BDB等存储引擎中。</p>
<p>对于表级锁，主要分为以下三类：</p>
<ul>
<li>表锁</li>
<li>元数据锁（meta data lock，MDL）</li>
<li>意向锁</li>
</ul>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><ul>
<li>表共享读锁（read lock）</li>
<li>表独占写锁（write lock）</li>
</ul>
<p><strong>表锁语法</strong></p>
<ul>
<li>加锁：lock tables 表名… read&#x2F;write。</li>
<li>释放锁：unlock tables &#x2F; 客户端断开连接 。</li>
</ul>
<hr>
<p><strong>特点</strong></p>
<ul>
<li>读锁(表共享读锁)</li>
</ul>
<p><img src="/../mysql_pic/17.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>对指定表加了读锁，不会影响自己和其他客户端的读，但是自己进行DML&#x2F;DDL操作会报错，而其他客户端会阻塞</strong></p>
<ul>
<li>写锁(表独占写锁)</li>
</ul>
<p><img src="/../mysql_pic/18.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>对指定表加了写锁，不会影响自己的读写操作，但是会阻塞其他客户端的读写操作。</strong></p>
<h4 id="元数据锁-MDL-meta-data-lock"><a href="#元数据锁-MDL-meta-data-lock" class="headerlink" title="元数据锁(MDL,meta data lock)"></a>元数据锁(MDL,meta data lock)</h4><p>meta data lock , 元数据锁，简写MDL。</p>
<p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维 护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML(增删改)与 DDL  (Data Definition Language，即数据定义语言，例如建数据库、建表等，都属于数据定义语言)  冲突，保证读写的正确性。</strong></p>
<p>这里的元数据，大家可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务 时，是不能够修改这张表的表结构的。</p>
<p>在MySQL5.5中引入了MDL，<strong>当对一张表进行增删改查的时候，加MDL读锁(共享)<strong>；</strong>当对表结构进行变 更操作的时候，加MDL写锁(排他)。</strong></p>
<p><strong>常见的SQL操作时，所添加的元数据锁：</strong></p>
<p><img src="/../mysql_pic/19.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/../mysql_pic/20.png" srcset="/img/loading.gif" lazyload></p>
<p>可以看到2个客户端交叉执行DML操作是没问题的，因为DML加的是共享锁。</p>
<p><img src="/../mysql_pic/21.png" srcset="/img/loading.gif" lazyload></p>
<p>当左侧执行一个DML语句，右侧执行一个DDL语句时，右侧操作被阻塞，因为DDL加的是DML写锁(与DML读锁互斥)，直到左侧提交事务，右侧才能执行。</p>
<p>我们可以通过下面的SQL，来查看数据库中的元数据锁的情况：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">select <span class="hljs-keyword">object</span><span class="hljs-number">_</span>type,<span class="hljs-keyword">object</span><span class="hljs-number">_</span>schema,<span class="hljs-keyword">object</span><span class="hljs-number">_n</span>ame,lock<span class="hljs-number">_</span>type,lock<span class="hljs-number">_</span>duration from<br>performance<span class="hljs-number">_</span>schema.metadata<span class="hljs-number">_</span>locks ;<br></code></pre></td></tr></table></figure>

<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一 下：</p>
<p><img src="/../mysql_pic/22.png" srcset="/img/loading.gif" lazyload></p>
<p>首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。</p>
<p>当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，它的判断方式是每一行都检查一遍看是否有行锁，效率较低。(加了行锁之后是不能加表锁的)。</p>
<p><img src="/../mysql_pic/23.png" srcset="/img/loading.gif" lazyload></p>
<p>有了意向锁之后 ：</p>
<p>客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁</p>
<p><img src="/../mysql_pic/24.png" srcset="/img/loading.gif" lazyload></p>
<p>而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而 不用逐行判断行锁情况了。</p>
<p><img src="/../mysql_pic/25.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>介绍</strong></p>
<p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行 数据是否加锁，使用意向锁来减少表锁的检查。</p>
<p><strong>分类</strong></p>
<ul>
<li>意向共享锁(IS): 由语句select … lock in share mode添加 。 与 表锁-共享锁 (read)(读锁)兼容，与表锁-排他锁(write)(写锁)互斥。</li>
<li>意向排他锁(IX): 由insert、update、delete、select…for update添加 。与表锁共 享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</li>
</ul>
<p><code>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</code></p>
<p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p>
<p><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;</code></p>
<p><img src="/../mysql_pic/26.png" srcset="/img/loading.gif" lazyload></p>
<p>当客户端1对某条记录加上行锁并且给全表加上意向共享锁时，客户端2可以对表加上表读锁，但是当客户端2给表加上表写锁时，会阻塞。很好理解，线程1要读某条数据，客户端2也可以读，反正没影响，但是客户端2不能修改这条数据吧，客户端2修改了那我客户端1不是读了错的数据吗？</p>
<hr>
<p><img src="/../mysql_pic/27.png" srcset="/img/loading.gif" lazyload></p>
<p>当客户端1使用DML语句时，给某条记录加上了行锁并且给全表加上了意向排他锁，此时客户端2无论是加表读锁还是表写锁都会阻塞，这也很好理解，我客户端1要修改某条数据，客户端1还未提交事务，数据还不确定，客户端2读取肯定是错的，那没必要读啊，那客户端2写就更不用说了，我客户端1都还没改完，你客户端2更别想改了(加表写锁)。</p>
<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p><strong>介绍</strong></p>
<p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB存储引擎中。</p>
<p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的 锁。对于行级锁，主要分为以下三类：</p>
<ul>
<li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在 RC、RR隔离级别下都支持。</li>
</ul>
<p><img src="/../mysql_pic/28.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事 务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</li>
</ul>
<p><img src="/../mysql_pic/29.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。 在RR隔离级别下支持。</li>
</ul>
<p><img src="/../mysql_pic/30.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>InnoDB实现了以下两种类型的行锁：</p>
<ul>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li>
</ul>
<p>（共享锁与共享锁不冲突，共享锁与排他锁冲突，排他锁与排他锁冲突).</p>
<ul>
<li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li>
</ul>
<p>两种行锁的兼容情况如下:</p>
<p><img src="/../mysql_pic/31.png" srcset="/img/loading.gif" lazyload></p>
<p>常见的SQL语句，在执行时，所加的行锁如下：</p>
<p><img src="/../mysql_pic/32.png" srcset="/img/loading.gif" lazyload></p>
<p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁(临键锁)进行搜 索和索引扫描，以防止幻读。</p>
<ul>
<li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li>
<li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记 录加锁，此时 就会<strong>升级为表锁</strong>。</li>
</ul>
<p><img src="/../mysql_pic/33.png" srcset="/img/loading.gif" lazyload></p>
<p>因为行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记 录加锁，此时 就会升级为表锁，name没有索引，所以使用update会加上表锁，客户端2就无法使用更新操作了，会阻塞。</p>
<p>那么我们给name字段创建一个索引就不会升级为表锁了。create index xxx(名字) on table(name);</p>
<p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="hljs-keyword">from</span><br>performance_schema.data_locks;<br></code></pre></td></tr></table></figure>

<h4 id="间隙锁-amp-临键锁"><a href="#间隙锁-amp-临键锁" class="headerlink" title="间隙锁&amp;临键锁"></a>间隙锁&amp;临键锁</h4><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜 索和索引扫描，以防止幻读。</p>
<ul>
<li>索引上的等值查询(唯一索引)，给<strong>不存在</strong>的记录加锁时, 优化为间隙锁 。</li>
</ul>
<p><img src="/../mysql_pic/34.png" srcset="/img/loading.gif" lazyload></p>
<p>当给id为5的数据进行修改操作时，表中没有id为5的数据，那么会给id为3与8之间的间隙加间隙锁，当右侧客户端插入一条id为7的数据时，操作被阻塞。</p>
<ul>
<li>索引上的等值查询(<strong>非唯一普通索引</strong>)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁(间隙锁唯一的目的是防止其他事务插入间隙，间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁)。</li>
</ul>
<p><img src="/../mysql_pic/35.png" srcset="/img/loading.gif" lazyload></p>
<p>我们知道InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引查询值 为18的数据，并加上共享锁，我们是只锁定18这一行就可以了吗？ 并不是，因为是非唯一索引，这个 结构中可能有多个18的存在(<strong>非唯一普通索引</strong>)，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也 就是29）。此时会对18加临键锁，并对29之前的间隙加锁。</p>
<ul>
<li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li>
</ul>
<p><img src="/../mysql_pic/36.png" srcset="/img/loading.gif" lazyload></p>
<p>查询的条件为id&gt;&#x3D;19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部 分：</p>
<ul>
<li>[19]</li>
<li>(19,25]</li>
<li>(25,+∞]</li>
</ul>
<p>所以数据库数据在加锁时，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临 键锁(正无穷及之前的间隙)。</p>
<h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h3><p><img src="/../mysql_pic/5.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>表空间</li>
</ul>
<p>表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在 8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空 间，用于存储记录、索引等数据。</p>
<ul>
<li>段</li>
</ul>
<p>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段 （Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的 非叶子节点。段用来管理多个Extent（区）。</p>
<ul>
<li>区</li>
</ul>
<p>区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一 个区中一共有64个连续的页。</p>
<ul>
<li>页</li>
</ul>
<p>页，是InnoDB 存储引擎磁盘管理的最小单元，每次查寻是读取一个页的数据到内存中，每个页的大小默认为 16KB。为了保证页的连续性， InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p>
<ul>
<li>行</li>
</ul>
<p>行，InnoDB 存储引擎数据是按行进行存放的。</p>
<p>在行中，默认有两个隐藏字段： </p>
<p>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。 Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个 隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发 中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p>
<p><img src="/../mysql_pic/6.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h3><p>先看左边的内存架构</p>
<p><img src="/../mysql_pic/7.png" srcset="/img/loading.gif" lazyload></p>
<p>在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。 接下来介绍一下这四个部分。</p>
<ul>
<li>Buffer pool</li>
</ul>
<p>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能 弥补这两者之间的I&#x2F;O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁 盘I&#x2F;O。</p>
<p>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及 InnoDB的锁信息等等。</p>
<p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增 删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频 率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p>
<p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p>
<ul>
<li><p>free page：空闲page，未被使用。</p>
</li>
<li><p>clean page：被使用page，数据没有被修改过。</p>
</li>
<li><p>dirty page：脏页，被使用page，数据被修改过，页中数据与磁盘的数据产生了不一致。</p>
</li>
<li><p>Change Buffer</p>
</li>
</ul>
<p>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML(增删改)语句时，如果这些数据Page 没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer 中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p>
<p><img src="/../mysql_pic/9.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/../mysql_pic/10.png" srcset="/img/loading.gif" lazyload></p>
<p>先来看一幅图，这个是二级索引的结构图：</p>
<p><img src="/../mysql_pic/8.png" srcset="/img/loading.gif" lazyload></p>
<p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新 可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了 Change Buffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p>
<p>写缓冲区为什么仅适用于非唯一普通索引页？</p>
<p>如上图所示，如果是唯一索引时，是直接去磁盘加载的数据，并不涉及到change Buffer，理由如下。</p>
<p>这是因为如果对索引设置唯一性，在进行修改操作时，InnoDB必须要做唯一性校验，因此必须得查询磁盘，做一次IO操作。这样就会直接将记录查询到Buffer Pool中，然后在缓冲池修改，就不会在change Buffer中操作了。</p>
<ul>
<li>Adaptive Hash Index</li>
</ul>
<p>自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持 hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在 进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需 要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。 InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度， 则建立hash索引，称之为自适应hash索引。 自适应哈希索引，无需人工干预，是系统根据情况自动完成。 参数： adaptive_hash_index</p>
<ul>
<li>Log Buffer</li>
</ul>
<p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log）， 默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事 务，增加日志缓冲区的大小可以节省磁盘 I&#x2F;O。</p>
<p>参数: </p>
<p>innodb_log_buffer_size：缓冲区大小</p>
<p>innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：</p>
<p> 1: 日志在每次事务提交时写入并刷新到磁盘，默认值。</p>
<p> 0: 每秒将日志写入并刷新到磁盘一次。 </p>
<p>  2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。</p>
<h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><p>再看右边的磁盘结构：</p>
<p><img src="/../mysql_pic/11.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>System TableSpace</li>
</ul>
<p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建 的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)</p>
<ul>
<li>File-Per-Table Tablespaces</li>
</ul>
<p>如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索 引 ，并存储在文件系统上的单个数据文件中(xxx.idb)。</p>
<p>开关参数：innodb_file_per_table ，该参数默认开启。</p>
<p>那也就是说，我们每创建一个表，都会产生一个表空间文件</p>
<ul>
<li>General Tablespaces(了解)</li>
</ul>
<p>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空 间。</p>
<ul>
<li>Undo Tablespaces</li>
</ul>
<p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储 undo log日志。</p>
<ul>
<li>Temporary Tablespaces</li>
</ul>
<p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p>
<ul>
<li>Doublewrite Buffer Files</li>
</ul>
<p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件 中，便于系统异常时恢复数据。</p>
<p><img src="/../mysql_pic/12.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>Redo Log</li>
</ul>
<p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所 有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。 以循环方式写入Redo Log日志文件，涉及两个文件：</p>
<p><img src="/../mysql_pic/13.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h3><ul>
<li>事务</li>
</ul>
<p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<ul>
<li>特性<ul>
<li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li>
<li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。(不仅数据要保持一致状态，约束也要保持一致状态)</li>
<li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环 境下运行。</li>
<li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
</li>
</ul>
<p>而对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由InnoDB中的 两份日志来保证的，一份是redo log日志，一份是undo log日志。 而持久性是通过数据库的锁， 加上MVCC来保证的。</p>
<p><img src="/../mysql_pic/14.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>redo log是如何保证事务的持久性的呢？</p>
<p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p>
<p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用 于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p>
<p>脏页：当客户端对buffer pool进行DML时，没有找到相关数据页，buffer pool从磁盘读取相关数据页到buffer pool，再对数据进行修改，此时buffer pool里的数据页和磁盘的数据不一致，这就是脏页。</p>
<p>如果没有redo log，可能会存在什么问题的？ 我们一起来分析一下。</p>
<p>我们知道，在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数 据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果 缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中 的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘 中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后 将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却 没有持久化下来，这就出现问题了，没有保证事务的持久性。</p>
<p><img src="/../mysql_pic/15.png" srcset="/img/loading.gif" lazyload></p>
<p>那么，如何解决上述的问题呢？ 在InnoDB中提供了一份日志 redo log，接下来我们再来分析一 下，通过redo log如何解决这个问题。</p>
<p><img src="/../mysql_pic/16.png" srcset="/img/loading.gif" lazyload></p>
<p>有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。在事务提交时，会将redolog buffer中的数据刷新到redo log磁盘文件中。 过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据 恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此 时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的.</p>
<p>那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新 到磁盘呢 ?</p>
<p> 因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在 往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这 种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</p>
<h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和 MVCC(多版本并发控制) 。</p>
<p>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的 update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p>
<p>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些 日志可能还用于MVCC。</p>
<p>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个undo log segment。</p>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>当前读</li>
</ul>
<p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加 锁。对于我们日常的操作，如：**select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读 **。</p>
<p><img src="/../mysql_pic/41.png" srcset="/img/loading.gif" lazyload></p>
<p>事务1首先查询了一次数据，事务2对表进行了一次修改，事务1再查询，但是数据还是和第一次一样，因为当前的隔离级别是默认的可重复读，第一次和第二次的结果是一样的。</p>
<p><img src="/../mysql_pic/42.png" srcset="/img/loading.gif" lazyload></p>
<p>但是在查询语句后面加上lock in share mode的话就是当前读，数据是最新版本。</p>
<ul>
<li>快照读</li>
</ul>
<p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据， 不加锁，是非阻塞读。</p>
<ul>
<li><ul>
<li>Read Committed：每次select，都生成一个快照读。</li>
<li>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li>
<li>Serializable：快照读会退化为当前读。</li>
</ul>
</li>
</ul>
<h4 id="MVCC基本概念"><a href="#MVCC基本概念" class="headerlink" title="MVCC基本概念"></a>MVCC基本概念</h4><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本， 使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需 要依赖于数据库记录中的<strong>三个隐式字段(也有可能是两个)<strong>、</strong>undo log日志</strong>、<strong>readView</strong>。</p>
<h5 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h5><p><img src="/../mysql_pic/43.png" srcset="/img/loading.gif" lazyload></p>
<p>当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。 实际上除了 这三个字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：</p>
<p><img src="/../mysql_pic/44.png" srcset="/img/loading.gif" lazyload></p>
<p>而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键， 如果有主键，则不会添加该隐藏字段。</p>
<p>进入服务器中的 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;itcast&#x2F; , 查看stu的表结构信息, 通过如下指令：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ibd2sdi</span> stu.ibd<br></code></pre></td></tr></table></figure>

<h5 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h5><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p>
<p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p>
<p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即 被删除。</p>
<h5 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h5><p>有一张原始数据为:</p>
<p><img src="/../mysql_pic/45.png" srcset="/img/loading.gif" lazyload></p>
<p><code>DB_TRX_ID : 代表最近修改事务的ID，记录插入这条记录或最后一次修改该记录的事务ID，是 自增的。</code> </p>
<p><code>DB_ROLL_PTR ：回滚指针，由于这条数据是才插入的，没有被更新过，所以该字段值为null。</code></p>
<p>然后，有四个并发事务同时在访问这张表。</p>
<p><strong>第一步</strong></p>
<p><img src="/../mysql_pic/46.png" srcset="/img/loading.gif" lazyload></p>
<p>当事务2执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p>
<p><img src="/../mysql_pic/47.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>第二步</strong></p>
<p><img src="/../mysql_pic/48.png" srcset="/img/loading.gif" lazyload></p>
<p>当事务3执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记 录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p>
<p><img src="/../mysql_pic/49.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>第三步</strong></p>
<p><img src="/../mysql_pic/50.png" srcset="/img/loading.gif" lazyload></p>
<p>当事务4执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记 录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p>
<p><img src="/../mysql_pic/51.png" srcset="/img/loading.gif" lazyload></p>
<p><code>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条 记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</code></p>
<h5 id="readview"><a href="#readview" class="headerlink" title="readview"></a>readview</h5><p>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务 （未提交的）id。</p>
<p>ReadView中包含了四个核心字段：</p>
<ul>
<li>m_ids  : 当前活跃的事务ID集合</li>
<li>min_trx_id : 最小活跃事务ID</li>
<li>max_trx_id : 预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</li>
<li>creator_trx_id : ReadView创建者的事务ID</li>
</ul>
<p>而在readview中就规定了版本链数据的访问规则：</p>
<p><strong>trx_id 代表当前undolog版本链对应事务ID。</strong></p>
<p><img src="/../mysql_pic/45.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/../mysql_pic/52.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/../mysql_pic/53.png" srcset="/img/loading.gif" lazyload></p>
<p>不同的隔离级别，生成ReadView的时机不同：</p>
<ul>
<li>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</li>
<li>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</li>
</ul>
<h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><h6 id="RC隔离级别-读已提交"><a href="#RC隔离级别-读已提交" class="headerlink" title="RC隔离级别(读已提交)"></a>RC隔离级别(读已提交)</h6><p><strong>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</strong></p>
<p>我们就来分析事务5中，两次快照读读取数据，是如何获取数据的?</p>
<p>在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读 都会生成一个ReadView，那么两次生成的ReadView如下。</p>
<p><img src="/../mysql_pic/54.png" srcset="/img/loading.gif" lazyload></p>
<p>那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则， 到undolog版本链中匹配数据，最终决定此次快照读返回的数据。</p>
<ul>
<li>先来看第一次快照读具体的读取过程：</li>
</ul>
<p><img src="/../mysql_pic/55.png" srcset="/img/loading.gif" lazyload></p>
<p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p>
<ul>
<li>先匹配最上面这条记录，这条记录对应的 trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ， 都不满足，则继续匹配undo log版本链的下一条。</li>
<li>再匹配第二条 ，这条 记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②不满足 ③不满足 ④也 不满足 ，都不满足，则继续匹配undo log版本链的下一条。</li>
<li>再匹配第三条 ，这条记 录对应的trx_id为2，也就是将2带入右侧的匹配规则中。①不满足 ②满足 终止匹配，此次快照 读，返回的数据就是版本链中记录的这条数据。</li>
</ul>
<p><strong>本质就是当前事务操作的最早已经提交的事务的数据。</strong></p>
<hr>
<p> 再来看第二次快照读具体的读取过程:</p>
<p>先不看答案，按照上面说的本质，答案应该是事务3修改后的数据。</p>
<p><img src="/../mysql_pic/56.png" srcset="/img/loading.gif" lazyload></p>
<p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p>
<ul>
<li>先匹配最上面 这条记录，这条记录对应的 trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ， 都不满足，则继续匹配undo log版本链的下一条。</li>
<li>再匹配第二条 ，这条 记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②满足 。终止匹配，此次 快照读，返回的数据就是版本链中记录的这条数据。</li>
</ul>
<h6 id="RR隔离级别-可重复读"><a href="#RR隔离级别-可重复读" class="headerlink" title="RR隔离级别(可重复读)"></a>RR隔离级别(可重复读)</h6><p><strong>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可 重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</strong></p>
<p>那MySQL是如何做到可重复读的呢? 我们简单分析一下就知道了</p>
<p><img src="/../mysql_pic/57.png" srcset="/img/loading.gif" lazyload></p>
<p>我们看到，在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该 ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返 回的结果也是一样的。</p>
<p>所以呢，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。 而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</p>
<p><img src="/../mysql_pic/58.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h2><p> 主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这 些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。</p>
<p>MySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状 复制。</p>
<p><img src="/../mysql_pic/59.png" srcset="/img/loading.gif" lazyload></p>
<p>MySQL 复制的优点主要包含以下三个方面：</p>
<ul>
<li>主库出现问题，可以快速切换到从库提供服务。</li>
<li>实现读写分离，降低主库的访问压力。(主库DML,从库DQL)</li>
<li>可以在从库中执行备份，以避免备份期间影响主库服务。</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>MySQL主从复制的核心就是 二进制日志，具体的过程如下：</p>
<p><img src="/../mysql_pic/60.png" srcset="/img/loading.gif" lazyload></p>
<p>从上图来看，复制分成三步：</p>
<ul>
<li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li>
<li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</li>
<li>slave重做中继日志中的事件，将改变反映它自己的数据。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>MySQL</div>
      <div>http://example.com/2023/04/13/MySQL/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>彭</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>April 13, 2023</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/04/22/SpringBoot/" title="SpringBoot">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">SpringBoot</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">
                        <span class="hidden-mobile">计算机网络</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
