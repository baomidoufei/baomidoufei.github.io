<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2023/04/13/MySQL/"/>
    <url>/2023/04/13/MySQL/</url>
    
    <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是帮助MySQL高效获取数据的数据结构(有序)。</p><p><img src="/../mysql_pic/1.png"></p><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇索引（Clustered Index）一般指的是主键索引（如果存在主键索引的话），聚簇索引也被称之为聚集索引。</p><p>聚簇索引在 InnoDB 中是使用 B+ 树实现的，比如我们创建一张 student 表，它的构建 SQL 如下：</p><p><img src="/../mysql_pic/2.png"></p><p>以上 student 表中有一个聚簇索引（也就是主键索引）id，和一个非聚簇索引 class_id。</p><p>聚簇索引 id 对应的 B+ 树如下图所示：</p><p><img src="/../mysql_pic/3.png"></p><p>在聚簇索引的叶子节点的data区直接存储用户信息的内存地址，我们使用内存地址可以直接找到相应的行数据。</p><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>非聚簇索引在 InnoDB 引擎中，也叫二级索引，以上面 student 表为例，在 student 中非聚簇索引 class_id 对应 B+ 树如下图所示：</p><p><img src="/../mysql_pic/4.png"></p><p>从上图我们可以看出，<strong>在非聚簇索引的叶子节点上的data存储的并不是真正的行数据，而是主键 ID，所以当我们使用非聚簇索引进行查询时，首先会得到一个主键 ID，然后再使用主键 ID 去聚簇索引上找到真正的行数据，我们把这个过程称之为回表查询。</strong></p><p><strong>总结：</strong></p><p>在 MySQL 的 InnoDB 引擎中，每个索引都会对应一颗 B+ 树，而聚簇索引和非聚簇索引最大的区别在于叶子节点存储的数据不同，聚簇索引叶子节点存储的是行数据，因此通过聚簇索引可以直接找到真正的行数据；而非聚簇索引叶子节点存储的是主键信息，所以使用非聚簇索引还需要回表查询，因此我们可以得出聚簇索引和非聚簇索引的区别主要有以下几个：</p><ul><li>聚簇索引叶子节点data存储的是行数据；而非聚簇索引叶子节点data存储的是聚簇索引（通常是主键 ID）。</li><li>聚簇索引查询效率更高，而非聚簇索引需要进行回表查询，因此性能不如聚簇索引。</li><li>聚簇索引一般为主键索引，而主键一个表中只能有一个，因此聚簇索引一个表中也只能有一个，而非聚簇索引则没有数量上的限制。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2023/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="键入网址到网页显示，期间发生了什么？"><a href="#键入网址到网页显示，期间发生了什么？" class="headerlink" title="键入网址到网页显示，期间发生了什么？"></a>键入网址到网页显示，期间发生了什么？</h1><h2 id="一-浏览器的第一步工作是解析URL"><a href="#一-浏览器的第一步工作是解析URL" class="headerlink" title="一.浏览器的第一步工作是解析URL"></a>一.浏览器的第一步工作是解析URL</h2><p>首先浏览器做的第一步工作就是要对URL进行解析，从而生成发送给Web服务器的请求信息。</p><p><img src="/../Intnet_pic/1.png"></p><p>所以图中的长长的 URL 实际上是请求服务器里的文件资源。</p><p><strong>要是上图中的蓝色部分 URL 元素都省略了，那应该是请求哪个文件呢？</strong></p><p>当没有路径名是，就代表访问目录下事先设置的默认文件，也就是&#x2F;index.html或者&#x2F;default.html这些文件，这样就不会发送混乱了。</p><h2 id="二-生产HTTP请求信息"><a href="#二-生产HTTP请求信息" class="headerlink" title="二.生产HTTP请求信息"></a>二.生产HTTP请求信息</h2><p>对URL进行解析之后，浏览器确定了Web服务器和文件名，接下来就是根据这些信息生成HTTP请求消息了。</p><p><img src="/../Intnet_pic/2.png"></p><p><strong>一个孤单 HTTP 数据包表示：“我这么一个小小的数据包，没亲没友，直接发到浩瀚的网络，谁会知道我呢？谁能载我一程呢？谁能保护我呢？我的目的地在哪呢？”。充满各种疑问的它，没有停滞不前，依然踏上了征途！</strong></p><h2 id="三-真实地址查询——–DNS"><a href="#三-真实地址查询——–DNS" class="headerlink" title="三.真实地址查询——–DNS"></a>三.真实地址查询——–DNS</h2><p>通过浏览器解析URL并生成HTTP消息后，需要委托操作系统将消息发送给Web服务器。</p><p>但在发送之前还有一项工作需要完成，那就是查询服务器域名对应的IP地址，因为委托操作系统发送消息时，必须提供通信对象的IP地址。</p><p>所以有一种服务器专门保存了Web服务器域名与IP的对应关系，他就是<strong>DNS服务器</strong></p><h3 id="域名的层级关系"><a href="#域名的层级关系" class="headerlink" title="域名的层级关系"></a>域名的层级关系</h3><p>DNS中的域名都是用句号来分隔的，比如<a href="http://www.server.com/">www.server.com</a> ,这里的句点代表了不同层次之间的界限。</p><p><strong>在域名中，越靠右的位置表示其层级越高</strong></p><p>实际上域名最后还有一个点，比如<a href="http://www.server.com/">www.server.com</a>.       这最后个点代表根域名</p><p>也就是，<code>.</code> 根域是在最顶层，它的下一层就是 <code>.com</code> 顶级域，再下面是 <code>server.com</code>。</p><p>所以域名的层级关系类似一个树状结构：</p><ul><li>根 DNS 服务器（.）</li><li>顶级域 DNS 服务器（.com）</li><li>权威 DNS 服务器（server.com）</li></ul><p><img src="/../Intnet_pic/3.png"></p><p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。</p><p>这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。</p><p>因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p><h3 id="域名解析的工作流程"><a href="#域名解析的工作流程" class="headerlink" title="域名解析的工作流程"></a>域名解析的工作流程</h3><ol><li>客户端首先会发出一个 DNS 请求，问 <a href="http://www.server.com/">www.server.com</a> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP&#x2F;IP 设置中填写的 DNS 服务器地址）。</li><li>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a href="http://www.server.com,则它直接返回/">www.server.com，则它直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li><li>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“<a href="http://www.server.com/">www.server.com</a> 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</li><li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？”</li><li>顶级域名服务器说：“我给你负责 <a href="http://www.server.com/">www.server.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</li><li>本地 DNS 于是转向问权威 DNS 服务器：“老三，<a href="http://www.server.com对应的IP是啥呀？”">www.server.com对应的IP是啥呀？”</a> server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li></ol><p>至此，我们完成了 DNS 的解析过程。现在总结一下，整个过程我画成了一个图。</p><p><img src="/../Intnet_pic/4.png"></p><h3 id="那是不是每次解析域名都要经过那么多的步骤呢？"><a href="#那是不是每次解析域名都要经过那么多的步骤呢？" class="headerlink" title="那是不是每次解析域名都要经过那么多的步骤呢？"></a>那是不是每次解析域名都要经过那么多的步骤呢？</h3><p>当然不是了，还有缓存这个东西的嘛。</p><p>浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。</p><h3 id="数据包表示：“DNS-老大哥厉害呀，找到了目的地了！我还是很迷茫呀，我要发出去，接下来我需要谁的帮助呢-”"><a href="#数据包表示：“DNS-老大哥厉害呀，找到了目的地了！我还是很迷茫呀，我要发出去，接下来我需要谁的帮助呢-”" class="headerlink" title="数据包表示：“DNS 老大哥厉害呀，找到了目的地了！我还是很迷茫呀，我要发出去，接下来我需要谁的帮助呢?”"></a>数据包表示：“DNS 老大哥厉害呀，找到了目的地了！我还是很迷茫呀，我要发出去，接下来我需要谁的帮助呢?”</h3><h2 id="指南好帮手——协议栈"><a href="#指南好帮手——协议栈" class="headerlink" title="指南好帮手——协议栈"></a>指南好帮手——协议栈</h2><p>通过DNS获取到IP后，就可以把HTTP请求的传输工作交给操作系统中的<strong>协议栈</strong>。</p><p>协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则，上面的部分会向下的部分委托工作，下面的部分收到委托的工作并执行。</p><p><img src="/../Intnet_pic/5.png"></p><p>应用程序(浏览器)通过调用Socket库，来委托协议栈工作。协议栈的上半部分有两块，分别是<strong>TCP</strong>和<strong>UDP</strong>协议，这两个传输协议会接受应用层的委托执行收发数据的操作。</p><p>协议栈的下面一半是用<strong>IP</strong>协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包， 而将网络包发送给对方的操作就是由IP负责的。</p><p>此外IP中还包括<strong>ICMP协议</strong>和<strong>ARP协议</strong>。</p><ul><li><strong>ICMP</strong>用于告知网络包传送过程中产生的错误以及各种控制信息。</li><li><strong>ARP</strong>用于根据IP地址查询相应的以太网MAC地址</li></ul><p>IP下面的网卡驱动程序负责控制网卡硬件，而最下面的物理硬件网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p><h3 id="数据包看了这份指南表示：“原来我需要那么多大佬的协助啊，那我先去找TCP大佬！”"><a href="#数据包看了这份指南表示：“原来我需要那么多大佬的协助啊，那我先去找TCP大佬！”" class="headerlink" title="数据包看了这份指南表示：“原来我需要那么多大佬的协助啊，那我先去找TCP大佬！”"></a>数据包看了这份指南表示：“原来我需要那么多大佬的协助啊，那我先去找TCP大佬！”</h3><h2 id="可靠传输——-TCP"><a href="#可靠传输——-TCP" class="headerlink" title="可靠传输——-TCP"></a>可靠传输——-TCP</h2><p>HTTP是基于TCP协议传输的，所以在这我们先了解TCP协议。</p><h3 id="TCP包头格式"><a href="#TCP包头格式" class="headerlink" title="TCP包头格式"></a>TCP包头格式</h3><p>先看看TCP报文头部格式</p><p><img src="/../Intnet_pic/6.png"></p><p><strong>源端口号</strong>和<strong>目的端口号</strong>是必不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</p><p>接下来的<strong>序号</strong>，这个是为了解决乱码问题。</p><p>还有应该有的是<strong>确认序列</strong>，目的是确认发送出去对方是否有收到。如果没有收到就应该重新发送，直到送到，<strong>确认序列是为了解决丢包问题</strong>。</p><p>接下来还有一些<strong>状态位(第四行蓝色部分)<strong>。例如</strong>SYN</strong>是发起一个连接，<strong>ACK</strong>是回复，<strong>RST</strong>是重新连接，<strong>FIN</strong>是结束连接等。TCP是面向连接的，因而双方要维护连接的状态，这些状态位的包的发送，会引起双方的状态变化。</p><p>还有一个重要的是<strong>窗口大小</strong>。TCP要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送太快也别发送太慢。</p><p>除了做流量控制以外，TCP还会做<strong>拥塞控制</strong>，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。</p><h3 id="TCP传输数据之前，要先三次握手建立连接"><a href="#TCP传输数据之前，要先三次握手建立连接" class="headerlink" title="TCP传输数据之前，要先三次握手建立连接"></a>TCP传输数据之前，要先三次握手建立连接</h3><p>在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为<strong>三次握手</strong>。</p><p>这个所谓的「连接」，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。</p><p><img src="/../Intnet_pic/7.png"></p><ul><li>一开始，客户端和服务端都处于<strong>closed</strong>状态。先是服务端主动监听某个端口，处于<strong>listen</strong>状态。’</li><li>然后客户端主动发起连接<strong>SYN</strong>，之后处于<strong>SYN-SENT</strong>状态。</li><li>服务端收到发起的连接，返回<strong>SYN</strong>，并且<strong>ACK</strong>客户端的<strong>SYN</strong>，之后处于<strong>SYN-REVD</strong>状态，</li><li>客户端收到服务端发送的<strong>SYN</strong>和<strong>ACK</strong>之后，发送对<strong>SYN</strong>确认的<strong>ACK</strong>，之后客户端处于<strong>ESTABLISHED</strong>状态，因为它一发一收成功了。</li><li>服务端收到自己<strong>ACK</strong>的<strong>ACK</strong>之后，处于<strong>ESTABLISHED</strong>状态，因为它也一发一收成功了。</li></ul><p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p><h3 id="如何查看TCP的连接状态？"><a href="#如何查看TCP的连接状态？" class="headerlink" title="如何查看TCP的连接状态？"></a>如何查看TCP的连接状态？</h3><p>TCP的连接状态可以在Linux通过<strong>netstat -napt</strong>命令查看</p><p><img src="/../Intnet_pic/8.png"></p><h3 id="TCP分割数据"><a href="#TCP分割数据" class="headerlink" title="TCP分割数据"></a>TCP分割数据</h3><p>如果HTTP请求消息比较长，超过了<strong>MSS</strong>的长度，这时TCP就需要把HTTP的数据拆解成一块块的数据发送，而不是一次性发送所有数据。</p><p><img src="/../Intnet_pic/9.png"></p><ul><li>MTU：一个网络包的最大长度，以太网中一般位1500字节。</li><li>MSS：除去IP和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度。</li></ul><p>数据会被以<strong>MSS</strong>的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据上加上TCP头信息，然后交给IP模块来发送数据。</p><p><img src="/../Intnet_pic/10.png"></p><h3 id="TCP报文生成"><a href="#TCP报文生成" class="headerlink" title="TCP报文生成"></a>TCP报文生成</h3><p>TCP协议里面会有两个端口，一个是浏览器监听的端口(通常是随机生成)，一个是Web服务器监听的端口(HTTP默认端口号是80，HTTPS默认端口号是443).</p><p>双方建立连接之后，TCP报文中的数据部分就是存放HTTP头部+数据，组装好TCP报文之后，就需要交给下面的网络层处理。</p><p>至此，网络包的报文如下图。</p><p><img src="/../Intnet_pic/11.png"></p><p><strong>此时，遇上了 TCP 的 数据包激动表示：“太好了，碰到了可靠传输的 TCP 传输，它给我加上 TCP 头部，我不再孤单了，安全感十足啊！有大佬可以保护我的可靠送达！但我应该往哪走呢？”</strong></p><h2 id="远程定位—-IP"><a href="#远程定位—-IP" class="headerlink" title="远程定位—-IP"></a>远程定位—-IP</h2><p>TCP模块在执行连接，收发，断开等各阶段操作时，都需要委托IP模块将数据封装成<strong>网络包</strong>发送给通信对象</p><h3 id="IP包格式"><a href="#IP包格式" class="headerlink" title="IP包格式"></a>IP包格式</h3><p><img src="/../Intnet_pic/12.png"></p><p>在IP协议里面需要有<strong>源地址IP</strong>和<strong>目的地址IP</strong>：</p><ul><li>源地址IP，即是客户端输出的IP地址；</li><li>目标地址，即通过DNS域名解析得到的Web服务器IP。</li></ul><p>因为HTTP是经过TCP传输的，所以在IP包头的协议号要填写为06（十六进制），表示为TCP协议。</p><h3 id="假设客户端有多个网卡，就会有多个IP地址，那IP头部的源地址应该选择哪个呢？"><a href="#假设客户端有多个网卡，就会有多个IP地址，那IP头部的源地址应该选择哪个呢？" class="headerlink" title="假设客户端有多个网卡，就会有多个IP地址，那IP头部的源地址应该选择哪个呢？"></a>假设客户端有多个网卡，就会有多个IP地址，那IP头部的源地址应该选择哪个呢？</h3><p>当存在多个网卡，在填写源地址IP时，就需要判断应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪一个网卡来发送包。</p><p>这个时候就需要根据<strong>路由表</strong>规则，来判断哪一个网卡作为源地址IP。</p><p>在Linux操作系统中，我们可以使用<strong>route -n</strong>查看当前系统的路由表。</p><p><img src="/../Intnet_pic/13.png"></p><p>举个例子，根据上面的路由表，我们假设 Web 服务器的目标地址是 <code>192.168.10.200</code>。</p><p><img src="/../Intnet_pic/14.png"></p><ol><li>首先先和第一条目的子网掩码（<code>Genmask</code>）进行 <strong>与运算</strong>，得到结果为 <code>192.168.10.0</code>，但是第一个条目的 <code>Destination</code> 是 <code>192.168.3.0</code>，两者不一致所以匹配失败。</li><li>再与第二条目的子网掩码进行 <strong>与运算</strong>，得到的结果为 <code>192.168.10.0</code>，与第二条目的 <code>Destination 192.168.10.0</code> 匹配成功，所以将使用 <code>eth1</code> 网卡的 IP 地址作为 IP 包头的源地址。</li></ol><p>那么假设 Web 服务器的目标地址是 <code>10.100.20.100</code>，那么依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。</p><p>第三条目比较特殊，它目标地址和子网掩码都是 <code>0.0.0.0</code>，这表示<strong>默认网关</strong>，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，<code>Gateway</code> 即是路由器的 IP 地址。</p><h3 id="IP报文生成"><a href="#IP报文生成" class="headerlink" title="IP报文生成"></a>IP报文生成</h3><p>至此，网络包的报文如下图。</p><p><img src="/../Intnet_pic/15.png"></p><p><strong>此时，加上了 IP 头部的数据包表示 ：“有 IP 大佬给我指路了，感谢 IP 层给我加上了 IP 包头，让我有了远程定位的能力！不会害怕在浩瀚的互联网迷茫了！可是目的地好远啊，我下一站应该去哪呢？”</strong></p><h3 id="两点传输——-MAC"><a href="#两点传输——-MAC" class="headerlink" title="两点传输——-MAC"></a>两点传输——-MAC</h3><p>生成了IP头部之后，接下来网络包还需要在IP头部的前面加上<strong>MAC头部</strong></p><h3 id="MAC包头信息"><a href="#MAC包头信息" class="headerlink" title="MAC包头信息"></a>MAC包头信息</h3><p>MAC头部是以太网使用的头部，它包含了接收方和发送方的MAC地址等信息。</p><p><img src="/../Intnet_pic/16.png"></p><p>在 MAC 包头里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>。</p><p>一般在 TCP&#x2F;IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p><ul><li><code>0800</code> ： IP 协议</li><li><code>0806</code> ： ARP 协议</li></ul><p>ARP：地址解析协议，即ARP（Address Resolution Protocol），是根据<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80?fromModule=lemma_inlink">IP地址</a>获取<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/2129?fromModule=lemma_inlink">物理地址</a>的一个<a href="https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE?fromModule=lemma_inlink">TCP&#x2F;IP协议</a>。</p><h3 id="MAC-发送方和接收方如何确认"><a href="#MAC-发送方和接收方如何确认" class="headerlink" title="MAC 发送方和接收方如何确认?"></a>MAC 发送方和接收方如何确认?</h3><p><strong>发送方</strong>的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。</p><p><strong>接收方</strong>的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>redis</title>
    <link href="/2023/03/26/redis/"/>
    <url>/2023/03/26/redis/</url>
    
    <content type="html"><![CDATA[<h2 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a>认识Redis</h2><p>Redis诞生于2009年全称是**Remote Dictionary Server(远程词典服务器)**，是一个基于内存的键值型NoSQL数据库。官网：<a href="https://redis.io/">雷迪斯 (redis.io)</a></p><p><strong>特征：</strong></p><ul><li>键值(key-value)型，value支持多种不同的数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快(基于内存，IO多路复用，良好的编码)</li><li>支持数据持久化(怕断电)</li><li>支持主从集群，分片集群</li><li>支持多语言客户端</li></ul><h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><p>Redis是一个Key-Value的数据库，key一般是String类型，不过value的类型多种多样：</p><h3 id="基本数据类型："><a href="#基本数据类型：" class="headerlink" title="基本数据类型："></a>基本数据类型：</h3><ul><li>String                        hello world</li><li>Hash                          {name: “Jack”,age: 21}</li><li>List                             [A -&gt; B -&gt;C]</li><li>Set                              {A, B, C}</li><li>SortedSet                  {A: 1 , B :2 ,C:3}</li></ul><h3 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h3><ul><li>GEO                            {A：(120.3 , 30.5)}</li><li>BitMap                       01101101011010</li><li>HyperLog                   01101010101010</li></ul><h2 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h2><p>常见的有：</p><ul><li>KEYS : 查看符合模板的所有key，不建议在生产环境设备上使用</li><li>DEL: 删除一个指定的key</li><li>EXISTS: 判断key是否存在</li><li>EXPIRE: 给一个key设置有效期，有效期到期时key会被自动删除</li><li>TTL：查看一个KEY的剩余有效期</li></ul><p>通过help [command]可以查看一个命令的具体用法。</p><h3 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sqf">redis&gt; <span class="hljs-built_in">KEYS</span> *<span class="hljs-built_in">name</span>*<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;lastname&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;firstname&quot;</span><br>redis&gt; <span class="hljs-built_in">KEYS</span> a??<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;age&quot;</span><br>redis&gt; <span class="hljs-built_in">KEYS</span> *<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;age&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;lastname&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;firstname&quot;</span><br></code></pre></td></tr></table></figure><h3 id="DEL"><a href="#DEL" class="headerlink" title="DEL"></a>DEL</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams">redis&gt; <span class="hljs-keyword">SET</span> key1 <span class="hljs-comment">&quot;Hello&quot;</span><br><span class="hljs-string">&quot;OK&quot;</span><br>redis&gt; <span class="hljs-keyword">SET</span> <span class="hljs-comment">key2</span> <span class="hljs-comment">&quot;World&quot;</span><br><span class="hljs-string">&quot;OK&quot;</span><br>redis&gt; DEL <span class="hljs-comment">key1 key2 key3</span><br>(integer) 2<br></code></pre></td></tr></table></figure><h3 id="EXISTS"><a href="#EXISTS" class="headerlink" title="EXISTS"></a>EXISTS</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">redis<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> key1 &quot;Hello&quot;<br>&quot;OK&quot;<br>redis<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">EXISTS</span> key1<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">1</span><br>redis<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">EXISTS</span> nosuchkey<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">0</span><br>redis<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> key2 &quot;World&quot;<br>&quot;OK&quot;<br>redis<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">EXISTS</span> key1 key2 nosuchkey<br>(<span class="hljs-type">integer</span>) <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="Expire-amp-TTL"><a href="#Expire-amp-TTL" class="headerlink" title="Expire&amp;TTL"></a>Expire&amp;TTL</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gams">redis&gt; <span class="hljs-keyword">SET</span> mykey <span class="hljs-comment">&quot;Hello&quot;</span><br><span class="hljs-string">&quot;OK&quot;</span><br>redis&gt; EXPIRE <span class="hljs-comment">mykey 10</span><br>(integer) 1<br>redis&gt; TTL <span class="hljs-comment">mykey</span><br>(integer) 10<br>redis&gt; <span class="hljs-keyword">SET</span> <span class="hljs-comment">mykey</span> <span class="hljs-comment">&quot;Hello World&quot;</span><br><span class="hljs-string">&quot;OK&quot;</span><br>redis&gt; TTL <span class="hljs-comment">mykey</span><br>(integer) -1<br>redis&gt; EXPIRE <span class="hljs-comment">mykey 10 XX</span><br>(integer) 0<br>redis&gt; TTL <span class="hljs-comment">mykey</span><br>(integer) -1<br>redis&gt; EXPIRE <span class="hljs-comment">mykey 10 NX</span><br>(integer) 1<br>redis&gt; TTL <span class="hljs-comment">mykey</span><br>(integer) 10<br>redis&gt; <br></code></pre></td></tr></table></figure><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>字符串类型是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同又可以分为3类。</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增，自减操作</li><li>float：浮点类型，可以做自增，自减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512MB.</p><h3 id="String类型的常见命令"><a href="#String类型的常见命令" class="headerlink" title="String类型的常见命令"></a>String类型的常见命令</h3><ul><li>SET:添加或者修改已经存在的一个string类型的键值对</li><li>GET：根据key获取string类型的value</li><li>MSET：批量添加多个String类型的value</li><li>MGET：根据多个key获取多个string的value</li><li>INCR：让一个整形的key自增1</li><li>INCREBY：让一个整形的key自增并指定步长，例如incrby num 2 </li><li>INCRBYFLOAT:让一个浮点类型的数字自增并指定步长</li><li>SETNX:添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期。</li></ul><h3 id="思考：Redis没有类似Mysql中Table的概念，我们该如何区分不同类型的Key呢？"><a href="#思考：Redis没有类似Mysql中Table的概念，我们该如何区分不同类型的Key呢？" class="headerlink" title="思考：Redis没有类似Mysql中Table的概念，我们该如何区分不同类型的Key呢？"></a>思考：Redis没有类似Mysql中Table的概念，我们该如何区分不同类型的Key呢？</h3><ul><li>例如：需要储存用户和商品信息到Redis，有一个用户ID是1，有一个商品ID恰好也是1</li></ul><p>**Redis的key允许有多个单词形成层级结构，多个单词之间用“:”隔开，格式如下： **</p><p>项目名：业务名：类型：id</p><p>IT:USER:1</p><p>IT:PRODUCT:1</p><p><strong>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储</strong></p><p>KEY：                                                   Value:</p><p>IT:USER:1                                             {“id”:1,    “name”:”jack”, “age”:21}</p><h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><p>Hash类型，也叫散列，其value是一个无需字典，类型与Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><p><img src="/../redis_pic/1.png"></p><p>Hash结构可以将对象中的每个字段独立存储，可以针对某个单位做CRUD：</p><p><img src="/../redis_pic/2.png"></p><h3 id="Hash类型的常用命令"><a href="#Hash类型的常用命令" class="headerlink" title="Hash类型的常用命令"></a>Hash类型的常用命令</h3><p><img src="/../redis_pic/3.png"></p><h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看作是一个双向链表结构。既可以支持正检索也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等</p><h3 id="List类型常用命令"><a href="#List类型常用命令" class="headerlink" title="List类型常用命令"></a>List类型常用命令</h3><p><img src="/../redis_pic/4.png"></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>如何利用List结构模拟一个栈？</p><ul><li>入口和出口在同一边</li></ul><p>如何利用List结构模拟一个队列？</p><ul><li>入口和出口在不同边</li></ul><p>如何利用List结构模拟一个阻塞队列？</p><ul><li>入口和出口在不同边</li><li>出队时采用BLPOP或BRPOP</li></ul><h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集，并集，差集等功能</li></ul><h3 id="Set类型常用命令"><a href="#Set类型常用命令" class="headerlink" title="Set类型常用命令"></a>Set类型常用命令</h3><p><img src="/../redis_pic/5.png"></p><h3 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h3><p>Redis的SortedSet是一个可排序的Set集合，与Java中的TreeSet有些类似，但是底层数据结构却差别很大。SortedSet中的每一个元素都带有一个Score属性，可以基于score属性对元素进行排序，底层的实现是一个跳表(SkipList)加Hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><h4 id="SortedSet常用命令"><a href="#SortedSet常用命令" class="headerlink" title="SortedSet常用命令"></a>SortedSet常用命令</h4><p><img src="/../redis_pic/6.png"></p><h3 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h3><p>Spring默认提供了一个StringRedisTmplate，它的key和value的序列化方式默认就是String方式。省去了我们自定义RedisTemplate的过程：</p><p><img src="/../redis_pic/7.png"></p><h2 id="集群中的Session不同步问题-简历"><a href="#集群中的Session不同步问题-简历" class="headerlink" title="集群中的Session不同步问题(简历)"></a>集群中的Session不同步问题(简历)</h2><p>session共享问题：多台Tomcat并不共享Session存储空间，当Nginx负载均衡将请求切换到不同Tomcat服务时导致数据丢失问题。</p><p>那么寻找session的替代方案应该满足：</p><ul><li>数据共享</li><li>内存存储(session基于内存，读写效率比较高)</li><li>key-value结构</li></ul><p>刚好redis满足与以上条件：首先redis独立于tomcat，每个tomcat都</p><p>都可以访问到redis，且redis基于内存存储，是一个key-value结构的远程词典服务器</p><p><img src="/../redis_pic/8.png"></p><h2 id="基于Redis实现共享Session登录流程-需细看代码"><a href="#基于Redis实现共享Session登录流程-需细看代码" class="headerlink" title="基于Redis实现共享Session登录流程(需细看代码)"></a>基于Redis实现共享Session登录流程(需细看代码)</h2><p><img src="/../redis_pic/9.png"></p><h2 id="利用双重拦截实现Redis刷新避免用户在redis中被定时清除-简历"><a href="#利用双重拦截实现Redis刷新避免用户在redis中被定时清除-简历" class="headerlink" title="利用双重拦截实现Redis刷新避免用户在redis中被定时清除(简历)"></a>利用双重拦截实现Redis刷新避免用户在redis中被定时清除(简历)</h2><p><img src="/../redis_pic/10.png"></p><p>刷新拦截器</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>public <span class="hljs-keyword">class</span> RefreshInterceptor implements HandlerInterceptor &#123;<br><br><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-comment">//构造函数注入StringRedisTemplate</span><br>    public <span class="hljs-constructor">RefreshInterceptor(StringRedisTemplate <span class="hljs-params">stringRedisTemplate</span>)</span> &#123;<br>        this.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    @Override<br>    public boolean pre<span class="hljs-constructor">Handle(HttpServletRequest <span class="hljs-params">request</span>, HttpServletResponse <span class="hljs-params">response</span>, Object <span class="hljs-params">handler</span>)</span> throws Exception &#123;<br>        <span class="hljs-comment">//1.获取请求头中的token</span><br>        String token = request.get<span class="hljs-constructor">Header(<span class="hljs-string">&quot;authorization&quot;</span>)</span>;<br>        <span class="hljs-keyword">if</span>(token<span class="hljs-operator"> == </span>null)&#123;<br>            <span class="hljs-comment">//刷新redis的拦截器，直接放行</span><br>            return <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//2.利用token查询用户信息</span><br>        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.ops<span class="hljs-constructor">ForHash()</span>.entries(LOGIN_USER_KEY + token);<br>        <span class="hljs-keyword">if</span>(userMap.is<span class="hljs-constructor">Empty()</span>)&#123;<br>            <span class="hljs-comment">//刷新redis的拦截器，直接放行</span><br>            return <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//4将将查询到的hash数据转化为UserDTO</span><br>        UserDTO userDTO = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BeanUtil</span>.</span></span>fill<span class="hljs-constructor">BeanWithMap(<span class="hljs-params">userMap</span>, <span class="hljs-params">new</span> UserDTO()</span>, <span class="hljs-literal">false</span>);<br><br>        <span class="hljs-comment">//5.存在，将用户信息存入ThreadLocal</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserHolder</span>.</span></span>save<span class="hljs-constructor">User(<span class="hljs-params">userDTO</span>)</span>;<br><br>        <span class="hljs-comment">//6刷新token有效期</span><br>        stringRedisTemplate.expire(LOGIN_USER_KEY + token,LOGIN_USER_TTL, TimeUnit.MINUTES);<br>        <span class="hljs-comment">//7.放行</span><br>        return <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    @Override<br>    public void after<span class="hljs-constructor">Completion(HttpServletRequest <span class="hljs-params">request</span>, HttpServletResponse <span class="hljs-params">response</span>, Object <span class="hljs-params">handler</span>, Exception <span class="hljs-params">ex</span>)</span> throws Exception &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserHolder</span>.</span></span>remove<span class="hljs-constructor">User()</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>登录校验拦截器</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object <span class="hljs-keyword">handler</span>)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">if</span> (UserHolder.getUser() == <span class="hljs-keyword">null</span>)&#123;<br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么需要两个拦截器，因为如果是一个拦截器，那么不会拦截所有请求信息，比如首页，商户详情页，这些都是不需要登入就能访问的页面，访问这些页面不被拦截就不会刷新redis中的用户token和信息。</p><h2 id="什么是缓存？"><a href="#什么是缓存？" class="headerlink" title="什么是缓存？"></a>什么是缓存？</h2><p>缓存就是数据交换的缓冲区，简称Cache，是临时存储数据的地方，一般读写性能较高</p><h3 id="redis缓存模型"><a href="#redis缓存模型" class="headerlink" title="redis缓存模型"></a>redis缓存模型</h3><p><img src="/../redis_pic/11.png"></p><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p><img src="/../redis_pic/12.png"></p><h3 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h3><p>在这里有三种主动更新策略，我们采用–》由缓存的调用者，在更新数据库的同时更新缓存</p><p>那么在这里有3个问题：</p><p>1.删除缓存还是更新缓存？</p><ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li></ul><p>2.如何保证缓存与数据库的操作同时成功或者失败？</p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul><p>3.先操作缓存还是先操作数据库？</p><ul><li>先删除缓存，再操作数据库</li></ul><p>正常情况</p><p><img src="/../redis_pic/13.png"></p><p>异常情况</p><p><img src="/../redis_pic/14.png"></p><p>开始缓存的内容和数据库的内容都是10，线程1删除缓存，缓存为空，因为可能更新数据库耗时比较久，那么此时线程2进来，缓存未命中，查询数据库还是未更新前的10，那么缓存此时被线程2更新为10，线程1才更新数据库为20，这就造成了，数据库更新为20，缓存为依然10。</p><ul><li>先操作数据库，再删除缓存</li></ul><p>正常情况：</p><p><img src="/../redis_pic/15.png"></p><p>异常情况：</p><p><img src="/../redis_pic/16.png"></p><p>开始缓存和数据库都为10，此时缓存突然失效，线程1查询缓存未命中，查询数据库为10，写入缓存还未开始，线程2更新数据库为20，然后删除缓存(无用操作，因为缓存已被删除)，然后线程1再写入缓存10，此时缓存为10，数据库为20。</p><p>那么这两种都有问题该使用哪种呢？用第二种，因为第二种发生概率小，缓存的读写操作速度非常快，在这个时间内，线程2完成操作概率很小。而第一种方法不然。</p><h3 id="缓存更新策略最佳实践方案"><a href="#缓存更新策略最佳实践方案" class="headerlink" title="缓存更新策略最佳实践方案"></a>缓存更新策略最佳实践方案</h3><p>1.低一致性需求：使用Rdis自带的内存淘汰机制</p><p>2.高一执行需求：主动更新，并以超时剔除作为兜底方案</p><p> 读操作：</p><ul><li>缓存命中直接返回</li><li>缓存未命中则查询数据库，并写入缓存，设定超时时间</li></ul><p>写操作：</p><ul><li>先写数据库，然后再删除缓存</li><li>要确保数据库与缓存的原子性(单体用事务注解，分布式另说，还未学)</li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</strong></p><p><img src="/../redis_pic/17.png"></p><p>这些请求可能是不怀好意的人开启多线程故意攻击数据库的</p><p>解决办法：</p><ul><li>缓存空对象</li></ul><p>​      优点：1.实现简单，维护方便</p><p>​  缺点：</p><p>​2.额外的内存消耗</p><p>​3.可能造成短期的不一致</p><p><img src="/../redis_pic/18.png"></p><ul><li><p>布隆过滤</p><p>​        优点：内存占用较少，没有多余的key。</p><p>​缺点：实现复杂，存在误判的可能。</p></li></ul><p>还有一些主动措施：</p><ul><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验(可考虑做)</li><li>做好热点参数的限流(可考虑做)</li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在同一时段内<strong>大量的缓存key同时失效</strong>或者<strong>Redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力。</p><p><img src="/../redis_pic/19.png"></p><p>解决方案:</p><ul><li>给不同的key的TTL添加随机值(简单，random)</li><li>利用Redis集群提高服务的可用性(后续学习)</li><li>给缓存业务添加降级限流策略(待做)</li><li>给业务添加多级缓存(后续学习)</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿也叫热点key问题，就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务比较复杂</strong>的key突然失效了，无数的请求会在瞬间给数据库带来巨大的冲击。</p><p><img src="/../redis_pic/20.png"></p><p>解决方案:</p><p>1.互斥锁：</p><p><img src="/../redis_pic/21.png"></p><p>这个方法也有问题，就是大量线程在等待，影响了性能。</p><p>2.逻辑过期</p><p><img src="/../redis_pic/22.png"></p><p>逻辑过期不是真的过期，数据一直在，可能得等redis的自动淘汰策略才能把数据自动删除，与互斥锁方案有区别的地放是，其他线程不用等待，获取锁失败直接返回旧数据而不是等待。 </p><p>互斥锁与逻辑过期方案对比</p><p><img src="/../redis_pic/23.png"></p><h3 id="基于互斥锁解决缓存击穿问题"><a href="#基于互斥锁解决缓存击穿问题" class="headerlink" title="基于互斥锁解决缓存击穿问题"></a>基于互斥锁解决缓存击穿问题</h3><p><img src="/../redis_pic/24.png"></p><p>那么如何利用reids获取锁呢？</p><p>利用String类型的Setnx命令(当没有操作对象时可以执行，当有操作对象时不执行)</p><p>Setnx lock  xx   ss(设置有效期，防止因为故障没有释放锁，让它到时删除)</p><p>那么如何删除锁呢？</p><p>Del 🔒</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//设置锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">tryLock</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> key</span>)&#123;<br>        <span class="hljs-title class_">Boolean</span> aBoolean = stringRedisTemplate.<span class="hljs-title function_">opsForValue</span>().<span class="hljs-title function_">setIfAbsent</span>(key, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">SECONDS</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">BooleanUtil</span>.<span class="hljs-title function_">isTrue</span>(aBoolean);<br>    &#125;<br>    <span class="hljs-comment">//释放锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">unlock</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> key</span>)&#123;<br>        stringRedisTemplate.<span class="hljs-title function_">delete</span>(key);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="基于逻辑过期方式解决缓存击穿问题"><a href="#基于逻辑过期方式解决缓存击穿问题" class="headerlink" title="基于逻辑过期方式解决缓存击穿问题"></a>基于逻辑过期方式解决缓存击穿问题</h3><p><img src="/../redis_pic/25.png"></p><p>具体代码自己看</p><h2 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h2><h3 id="全局ID生成器-简历"><a href="#全局ID生成器-简历" class="headerlink" title="全局ID生成器(简历)"></a>全局ID生成器(简历)</h3><p>是一种分布式系统下全局唯一ID的工具，一般要满足下列特性：</p><ul><li>唯一性</li><li>高性能</li><li>安全性</li><li>递增性</li><li>高可用</li></ul><p>那么可以采用redis里的INCREBY</p><p><img src="/../redis_pic/26.png"></p><h3 id="实现优惠券秒杀下单"><a href="#实现优惠券秒杀下单" class="headerlink" title="实现优惠券秒杀下单"></a>实现优惠券秒杀下单</h3><p><img src="/../redis_pic/27.png"></p><p>以上流程和秒杀没什么关系，只是一个基本流程，秒杀还得进一步优化。</p><h3 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h3><p><img src="/../redis_pic/28.png"></p><p>在高并发情况下，容易发生线程安全问题。超卖问题(比如100库存卖了110)就是经典的多线程安全问题，针对这一问题的常见解决方案就是加锁。</p><p>而锁又分为悲观锁和乐观锁。</p><h4 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h4><p><img src="/../redis_pic/29.png"></p><p>因为悲观锁确保线程串行执行，那么在高并发的情况下性能较低，不太合适</p><p>乐观锁：</p><p><strong>版本号法</strong>：</p><p><img src="/../redis_pic/30.png"></p><p>看版本是否和之前自己查询的一样，如果一样则说明自己这个操作之前没有其他线程对数据进行了修改，如果不一样，那么其他线程对数据进行了修改，如果此时本线程还要修改的话就可能导致超卖问题再次发生。</p><p>在这里发现version和stock的操作一样，那么可以使用stock代替version的功能就变成了CAS法</p><p><strong>CAS法</strong>：</p><p><img src="/../redis_pic/31.png"></p><p>但是这里也有一个问题就是，乐观锁法失败率过高，过于小心，只要和之前查询的不一致就失败了。</p><p>所以这里可以做出改进，查询数据和之前一致就可以执行—&gt;只要库存大于0就可以执行。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">boolean</span> flag = seckillVoucherService.update()  <span class="hljs-comment">//mybatis-plus</span><br>                    .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>                    .<span class="hljs-literal">eq</span>(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId)<br>                    .<span class="hljs-literal">gt</span>(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>                    .update();<br></code></pre></td></tr></table></figure><p>总结：超卖问题的线程安全问题解决方案有哪些？</p><p>1.悲观锁:添加同步锁，让线程串行执行</p><ul><li>优点：简单粗暴</li><li>缺点：性能一般</li></ul><p>2.乐观锁：不加锁，在更新时判断是否有其他线程在修改</p><ul><li>优点：性能好</li><li>缺点：存在成功率低的问题</li></ul><h3 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl">UserDTO userDTO = UserHolder.getUser();<br>      Long userid = userDTO.getId();<br>      <span class="hljs-regexp">//</span><span class="hljs-number">5</span>.一人一单<br>      //查询优惠券订单<br>          <span class="hljs-keyword">int</span> count = query().e<span class="hljs-string">q(&quot;voucher_id&quot;, voucherId)</span>.e<span class="hljs-string">q(&quot;user_id&quot;, userid)</span>.count();<br>          <span class="hljs-regexp">//</span>判断数量<br>          <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>              <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;您已重复购买！&quot;</span>);<br>          &#125;<br></code></pre></td></tr></table></figure><p>这段代码会有什么问题呢？在高并发多线程的情况下，多个线程交叉执行，查询到的count都为0，那么都往下走创建了订单，和超卖问题一样，但是这里是一人一单，是要插入数据而不是判断有没有修改数据，所以不能用超卖问题的乐观锁+库存大于0的方法。</p><p>此时只能用悲观锁解决。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">synchronized</span><span class="hljs-params">(userid.toString()</span></span><span class="hljs-selector-class">.intern</span>())<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">synchronized(userid.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>.intern<span class="hljs-literal">()</span>)&#123;<br>UserDTO userDTO = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserHolder</span>.</span></span>get<span class="hljs-constructor">User()</span>;<br>    Long userid = userDTO.get<span class="hljs-constructor">Id()</span>;<br>    <span class="hljs-comment">//5.一人一单</span><br>    <span class="hljs-comment">//查询优惠券订单</span><br>    <span class="hljs-built_in">int</span> count = query<span class="hljs-literal">()</span>.eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="hljs-string">&quot;user_id&quot;</span>,userid).count<span class="hljs-literal">()</span>;<br>            <span class="hljs-comment">//判断数量</span><br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Result</span>.</span></span>fail(<span class="hljs-string">&quot;您已重复购买！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//6.扣减库存</span><br>   boolean flag = seckillVoucherService.update<span class="hljs-literal">()</span>  <span class="hljs-comment">//mybatis-plus</span><br>                   .set<span class="hljs-constructor">Sql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)</span><br>                   .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId)<br>                   .gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>                   .update<span class="hljs-literal">()</span>;<br><br>           <span class="hljs-keyword">if</span> (!flag) &#123;<br>               return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Result</span>.</span></span>fail(<span class="hljs-string">&quot;秒杀优惠券库存不足&quot;</span>);<br>           &#125;<br>           <span class="hljs-comment">//7.创建订单</span><br>           VoucherOrder voucherOrder = <span class="hljs-keyword">new</span> <span class="hljs-constructor">VoucherOrder()</span>;<br>           <span class="hljs-comment">//订单id</span><br>           long orderId = redisIdWorker.next<span class="hljs-constructor">Id(<span class="hljs-string">&quot;order&quot;</span>)</span>;<br>           voucherOrder.set<span class="hljs-constructor">Id(<span class="hljs-params">orderId</span>)</span>;<br>           voucherOrder.set<span class="hljs-constructor">UserId(<span class="hljs-params">userid</span>)</span>;<br>           <span class="hljs-comment">//代金券id</span><br>           voucherOrder.set<span class="hljs-constructor">VoucherId(<span class="hljs-params">voucherId</span>)</span>;<br>          save(voucherOrder);<br>           <span class="hljs-comment">//8.返回订单id</span><br>           return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Result</span>.</span></span>ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure><p>对用户id上锁。并且注意用intern()。对同一个用户加锁，那么才避免被同一个用户下多单，而不是对这个方法加锁，如果对这个方法加锁，那么是每个用户的线程串行执行。</p><p>那么这样就解决了吗？</p><p>在单体项目中确实解决了，但是在集群中并没有</p><p><img src="/../redis_pic/32.png"></p><p>因为在集群中，不一样的机器上JVM不是同一个，那么锁监视器分别不同，所以以上分发会失效</p><p>这时候就需要采用分布式锁。<strong>因为集群中不同的机器上JVM不同！所以锁监视器都是全新的！如果不采用分布式锁的话那么同一个用户可以在每台机器上都下单一个(高并发的情况下，两台机器同时被下单才有可能)</strong></p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p><img src="/../redis_pic/33.png"></p><p>既然在多JVM情况下synchronized会失效，那么就需要一个每个JVM都能访问的锁，即分布式锁。</p><p><strong>分布式锁：</strong>满足分布式系统或集群模式下多进程可见并且互斥的锁。</p><h3 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a>基于Redis的分布式锁</h3><p><img src="/../redis_pic/34.png"></p><h3 id="分布式锁误删问题"><a href="#分布式锁误删问题" class="headerlink" title="分布式锁误删问题"></a>分布式锁误删问题</h3><p><img src="/../redis_pic/35.png"></p><p>首先线程1获取锁成功，但是因为某些原因，未能释放锁，直到锁超时自动释放，此时线程2获取到锁，就在此时线程又恢复正常，释放了锁，线程3又获取到锁，这时候就出现了线程安全问题，可能会出现一个用户购买多个秒杀券的问题。</p><p>那么如何解决这个问题呢？</p><p><img src="/../redis_pic/36.png"></p><p>释放锁时需要判断redis的value(线程标识)，如果一致可以删除，不一致则不能删除。</p><p><img src="/../redis_pic/37.png"></p><p>本以为解决了问题，结果还有问题！</p><p><img src="/../redis_pic/38.png"></p><p>虽然线程1判断了锁是自己的，但是就在准备释放自己的锁时，释放的动作阻塞了(可能是JVM的原因)， 锁自动释放了，然后线程2拿到了锁，此时线程1释放锁动作又恢复了正常，又把线程2的锁释放了，线程3拿到锁，又又又发生了线程安全问题。究其原因是因为判断锁和锁释放不是原子性的。那么如何解决两个操作的原子性呢？答案是<strong>Lua脚本</strong></p><p>Redis提供了Lua脚本功能，在一个脚本中编写多条redis命令，确保多条命令执行时的原子性</p><p>redis.call(‘命令名称’，‘key’，‘其他参数，、、、、’)</p><p>例如我们要执行Set name jack,则脚本是这样：</p><p>redis.call(‘set’,’name’,’jack’)</p><p><img src="/../redis_pic/39.png"></p><p>java中调用lua脚本</p><p><img src="/../redis_pic/40.png"></p><h2 id="达人探店"><a href="#达人探店" class="headerlink" title="达人探店"></a>达人探店</h2><h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2023/03/20/RabbitMq/"/>
    <url>/2023/03/20/RabbitMq/</url>
    
    <content type="html"><![CDATA[<h2 id="1-1-MQ概述"><a href="#1-1-MQ概述" class="headerlink" title="1.1 MQ概述"></a>1.1 MQ概述</h2><p>MQ全称 Message Queue(消息队列)，是在消息传输的过程中保存消息的容器。多用于分布式系统之间进行通信</p><p><img src="/../mq_pic/1.png"></p><ul><li>MQ,消息队列，储存消息的中间件</li><li>分布式系统通信有两种方式：<strong>直接远程调用</strong>和<strong>借助第三方完成间接通信</strong>(MQ)</li><li>发送方称为生产者，接收方称为消费者</li></ul><p>参照：<a href="https://developer.aliyun.com/article/769883">超详细的RabbitMQ入门，看这篇就够了！-阿里云开发者社区 (aliyun.com)</a></p><h2 id="1-2-MQ的优势"><a href="#1-2-MQ的优势" class="headerlink" title="1.2 MQ的优势"></a>1.2 MQ的优势</h2><p><strong>优势：</strong></p><ul><li><strong>应用解耦</strong></li><li><strong>异步提速</strong></li><li><strong>削峰填谷</strong></li></ul><p><strong>劣势</strong>：</p><ul><li><strong>系统可用性降低</strong></li><li><strong>系统复杂性提高</strong></li><li><strong>一致性问题</strong></li></ul><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p>不使用MQ：</p><p><img src="/../mq_pic/2.png"></p><p><strong>系统的耦合性越高，容错性越低，可维护性就越低</strong></p><p>一个模块的服务失败，那么整个服务流程都将失败，容错性低。</p><p>如果还要增加X模块,Y模块的话，还需修改订单系统的代码，耦合性太高，不方便维护。</p><p>使用MQ：</p><p><img src="/../mq_pic/3.png"></p><p>订单系统发出消息给MQ，返回下单成功，那么用户体验会很好，不再管理后续服务是否成功。</p><p>如果一个服务模块失败了，那么这个模块一定时间后恢复正常会重新取得消息，完成服务，容错性提高了。</p><p>如果还要增加服务模块的话，无需修改订单系统的代码，直接增加模块获取MQ信息，可维护性提高。</p><h3 id="异步提速"><a href="#异步提速" class="headerlink" title="异步提速"></a>异步提速</h3><p>不使用MQ：</p><p><img src="/../mq_pic/4.png"></p><p>订单系统与各服务模块间的调用是同步的，总耗费时间是300+300+300+20&#x3D;920ms</p><p>用户点击完成下单按钮后，需要等待920ms才能得到下单响应，太慢，用户体验差。</p><p>使用MQ：</p><p><img src="/../mq_pic/5.png"></p><p>用户点击完成下单按钮后，只需得到25ms(20+5)就能得到下单响应。</p><p>提升用户体验和系统吞吐量(单位时间内处理请求的数目)。</p><h3 id="削谷填峰"><a href="#削谷填峰" class="headerlink" title="削谷填峰"></a>削谷填峰</h3><p>不使用rabbitmq:</p><p><img src="/../mq_pic/6.png"></p><p>无法承受那么高的访问量，宕机。</p><p>使用rabbitmq:</p><p><img src="/../mq_pic/7.png"></p><p><img src="/../mq_pic/8.png"></p><h2 id="1-4MQ的劣势"><a href="#1-4MQ的劣势" class="headerlink" title="1.4MQ的劣势"></a>1.4MQ的劣势</h2><p><img src="/../mq_pic/9.png"></p><h3 id="MQ的几个常见问题"><a href="#MQ的几个常见问题" class="headerlink" title="MQ的几个常见问题"></a>MQ的几个常见问题</h3><ul><li><p><strong>系统的可用性降低</strong></p><p>系统引入的外部依赖越多，系统稳定性越差。一旦MQ宕机，就会对业务造成影响。如何保证MQ的高可用？</p></li><li><p><strong>系统复杂度提高</strong></p><p>MQ的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过MQ进行异步调用。如何保证消息没有被重复消费？怎么处理消息丢失情况？怎么保证消息传递的顺序性？</p></li><li><p>一致性问题</p><p>A系统处理完业务，通过MQ给B，C, D三个系统发消息数据，如果B系统，C系统处理成功，D系统失败。如何保证消息数据处理的一致性？</p></li></ul><h3 id="MQ的使用场景"><a href="#MQ的使用场景" class="headerlink" title="MQ的使用场景"></a>MQ的使用场景</h3><ul><li>生产者不需要从消费者处获取反馈。引入消息队列之前的直接调用，其接口的返回值应该为空，这才让明明下层的动作还没做完，上层却当成功做完了继续往后走，即所谓异步成为了可能。</li><li>容许短暂不一致性</li><li>解耦，提速，削峰这方面的收益超过了加入MQ，管理MQ这些成本。</li></ul><h2 id="1-5-常见的MQ产品"><a href="#1-5-常见的MQ产品" class="headerlink" title="1.5 常见的MQ产品"></a>1.5 常见的MQ产品</h2><p>RabbitMQ,ActiveMQ,RocketMQ,Kafka.</p><p><img src="/../mq_pic/10.png"></p><h2 id="1-6-AMQP"><a href="#1-6-AMQP" class="headerlink" title="1.6 AMQP"></a>1.6 AMQP</h2><p>AMQP，即Advanced Message Queuing Protocol(高级消息队列协议),一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件同产品，不同的开发语言等条件的限制。类比HTTP。</p><p><img src="/../mq_pic/11.png"></p><h3 id="RabbitMQ基础架构"><a href="#RabbitMQ基础架构" class="headerlink" title="RabbitMQ基础架构"></a>RabbitMQ基础架构</h3><p><img src="/../mq_pic/12.png"></p><h3 id="RabbitMQ的核心概念"><a href="#RabbitMQ的核心概念" class="headerlink" title="RabbitMQ的核心概念"></a>RabbitMQ的核心概念</h3><p><strong>Connection（连接）、Channel（信道）、Exchange（交换机）、Queue（队列）、Virtual host（虚拟主机）</strong></p><p>其中，中间的Broker表示RabbitMQ服务，每个Broker里面至少有一个Virtual host虚拟主机，每个虚拟主机中有自己的Exchange交换机、Queue队列以及Exchange交换机与Queue队列之间的绑定关系Binding。producer（生产者）和consumer（消费者）通过与Broker建立Connection来保持连接，然后在Connection的基础上建立若干Channel信道，用来发送与接收消息。</p><p><strong>Connection（连接）</strong><br>每个producer（生产者）或者consumer（消费者）要通过RabbitMQ发送与消费消息，首先就要与RabbitMQ建立连接，这个连接就是Connection。Connection是一个TCP长连接。</p><p><strong>Channel（信道）</strong><br>Channel是在Connection的基础上建立的虚拟连接，RabbitMQ中大部分的操作都是使用Channel完成的，比如：声明Queue、声明Exchange、发布消息、消费消息等。</p><p>看到此处，你是否有这样一个疑问：既然已经有了Connection，我们完全可以使用Connection完成Channel的工作，为什么还要引入Channel这样一个虚拟连接的概念呢？因为现在的程序都是支持多线程的，如果没有Channel，那么每个线程在访问RabbitMQ时都要建立一个Connection这样的TCP连接，对于操作系统来说，建立和销毁TCP连接是非常大的开销，在系统访问流量高峰时，会严重影响系统性能。</p><p>Channel就是为了解决这种问题，通常情况下，每个线程创建单独的Channel进行通讯，每个Channel都有自己的channel id帮助Broker和客户端识别Channel，所以Channel之间是完全隔离的。</p><p>Connection与Channel之间的关系可以比作光纤电缆，如果把Connection比作一条光纤电缆，那么Channel就相当于是电缆中的一束光纤。</p><p><strong>Virtual host（虚拟主机）</strong></p><p>Virtual host是一个虚拟主机的概念，一个Broker中可以有多个Virtual host，每个Virtual host都有一套自己的Exchange和Queue，同一个Virtual host中的Exchange和Queue不能重名，不同的Virtual host中的Exchange和Queue名字可以一样。这样，不同的用户在访问同一个RabbitMQ Broker时，可以创建自己单独的Virtual host，然后在自己的Virtual host中创建Exchange和Queue，很好地做到了不同用户之间相互隔离的效果。</p><p><strong>Queue（队列）</strong><br>Queue是一个用来存放消息的队列，生产者发送的消息会被放到Queue中，消费者消费消息时也是从Queue中取走消息。</p><p><strong>Exchange（交换机）</strong><br>Exchange是一个比较重要的概念，它是消息到达RabbitMQ的第一站，主要负责根据不同的分发规则将消息分发到不同的Queue，供订阅了相关Queue的消费者消费到指定的消息。那Exchange有哪些分发消息的规则呢？这就要说到Exchange的5种类型了：简单模式，work queues, publish&#x2F;Subscribe发布与订阅模式， Routing路由模式， Topics主题模式 ，RPC远程调用模式(不太算)</p><p><strong>Binding</strong>(绑定)</p><p>exchange和queue之间的虚拟连接，binging中可以包含routing key。Binding信息被保存到exchange中的查询表中，用于message的分发依据。</p><p><strong>Broker</strong></p><p>接收和分发消息的应用，RabbitMQ Server就是Message Broker</p><h2 id="1-7-JMS"><a href="#1-7-JMS" class="headerlink" title="1.7 JMS"></a>1.7 JMS</h2><ul><li>JMS即Java消息服务(JavaMessage Service)应用程序接口，是一个Java平台中关于面向中间件的API。</li><li>JMS是Java EE规范中的一种，类比JDBC。</li><li>很多消息中间件都实现了JMS规范，例如ActiveMQ。RabbitMQ官方没有提供JMS的实现包，但是开源社区有。</li></ul><h2 id="1-8-在linux上安装下载RabbitMQ"><a href="#1-8-在linux上安装下载RabbitMQ" class="headerlink" title="1.8 在linux上安装下载RabbitMQ"></a>1.8 在linux上安装下载RabbitMQ</h2><p>我们在Centos7虚拟机中使用Docker来安装。</p><p>在线拉取镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull rabbitmq:<span class="hljs-number">3</span>-management<br></code></pre></td></tr></table></figure><p>执行下面的命令来运行MQ容器：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker run <span class="hljs-string">\</span><br> -e RABBITMQ_DEFAULT_USER=pjf <span class="hljs-string">\</span><br> -e RABBITMQ_DEFAULT_PASS=<span class="hljs-number">123456</span> <span class="hljs-string">\</span><br> --name mq <span class="hljs-string">\</span><br> --hostname mq1 <span class="hljs-string">\</span><br> -p <span class="hljs-number">15672</span>:<span class="hljs-number">15672</span> <span class="hljs-string">\</span><br> -p <span class="hljs-number">5672</span>:<span class="hljs-number">5672</span> <span class="hljs-string">\</span><br> -d <span class="hljs-string">\</span><br> rabbitmq:<span class="hljs-number">3</span>-management<br></code></pre></td></tr></table></figure><h2 id="1-9-RabbitMQ工作模式"><a href="#1-9-RabbitMQ工作模式" class="headerlink" title="1.9 RabbitMQ工作模式"></a>1.9 RabbitMQ工作模式</h2><h3 id="基本消息队列（BasicQueue）"><a href="#基本消息队列（BasicQueue）" class="headerlink" title="基本消息队列（BasicQueue）"></a>基本消息队列（BasicQueue）</h3><p><img src="/../mq_pic/13.png"></p><ul><li>P：生产者,也就是发送消息的程序</li><li>C：消费者，消息的接收者，会一直等待消息的到来</li><li>queue:消息队列，图中红色的部分，类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中获取消息</li></ul><h3 id="工作消息队列（WorkQueue）"><a href="#工作消息队列（WorkQueue）" class="headerlink" title="工作消息队列（WorkQueue）"></a>工作消息队列（WorkQueue）</h3><p><img src="/../mq_pic/14.png"></p><p>两个或者多个消费者是竞争关系，只有一个可以得到消息</p><p>应用场景:对于任务过重或者任务较多的情况使用工作队列可以提高任务处理的速度</p><p>通过在yml中设置prefetch来控制消费者预取的消息数量（先把消息拿过来，不一定马上处理）</p><h3 id="发布订阅（Publish-Subscribe）"><a href="#发布订阅（Publish-Subscribe）" class="headerlink" title="发布订阅（Publish Subscribe）"></a>发布订阅（Publish Subscribe）</h3><p>发布订阅模式与之前案例的区别就是允许将同一消息发给多个消费者。实现方式是加入了交换机Exchange。</p><p>交换机负责消息路由，而不是存储，路由失败则消息丢失。</p><p><strong>SpringAMQP提供了声明交换机，队列，绑定关系的API</strong></p><p><img src="/../mq_pic/22.png"></p><p>根据交换机类型不同分为三种</p><ul><li>Fanout Exchange:广播</li><li>Direct Exchange:路由</li><li>Topic Exchange:主题</li></ul><p><img src="/../mq_pic/15.png"></p><p>实现思路：</p><p>1.在consumer服务中，利用代码声明队列，交换机，并将两者绑定</p><p>2.在consumer服务中，编写两个消费者方法，分别监听fanout.queue1和fanout.queue2</p><p>3.在publisher中编写测试方法，向it.fanout(交换机)中发送消息</p><p>编写一个配置类，把交换机，队列，绑定关系声明为Bean</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAMQPconfig</span> &#123;<br>    <span class="hljs-comment">//声明交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">FanoutExchange</span> <span class="hljs-title function_">fanoutExchange</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FanoutExchange</span>(<span class="hljs-string">&quot;fanout.exchange&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Queue</span> <span class="hljs-title function_">fanoutQueue1</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;fanout.queue1&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Binding</span> <span class="hljs-title function_">binding1</span>(<span class="hljs-params">FanoutExchange fanoutExchange,Queue fanoutQueue1</span>)&#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-title class_">BindingBuilder</span>.<span class="hljs-title function_">bind</span>(fanoutQueue1).<span class="hljs-title function_">to</span>(fanoutExchange);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Queue</span> <span class="hljs-title function_">fanoutQueue2</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;fanout.queue2&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Binding</span> <span class="hljs-title function_">binding2</span>(<span class="hljs-params">FanoutExchange fanoutExchange,Queue fanoutQueue2</span>)&#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-title class_">BindingBuilder</span>.<span class="hljs-title function_">bind</span>(fanoutQueue2).<span class="hljs-title function_">to</span>(fanoutExchange);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript">监听<br><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">&quot;fanout.queue1&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">fanoutlistener1</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> msg</span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;fanout.queue1收到消息队列得消息:&quot;</span>+msg);<br>    &#125;<br>    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">&quot;fanout.queue2&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">fanoutlistener2</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> msg</span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;fanout.queue2收到消息队列得消息:&quot;</span>+msg);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript">发送消息<br><span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">fanoutsend</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-title class_">String</span> fanoutName =<span class="hljs-string">&quot;fanout.exchange&quot;</span>;<br>       <span class="hljs-title class_">String</span> msg =<span class="hljs-string">&quot;hello,fanout!!&quot;</span>;<br>       rabbitTemplate.<span class="hljs-title function_">convertAndSend</span>(fanoutName,<span class="hljs-string">&quot;&quot;</span>,msg);<br>   &#125;<br></code></pre></td></tr></table></figure><p><img src="/../mq_pic/16.png"></p><p><img src="/../mq_pic/17.png"></p><p>发现用Bean声明队列，交换机和绑定太麻烦</p><p>可以使用@RabbitListener注解声明队列，交换机和绑定</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RabbitListener</span>(bindings = <span class="hljs-variable">@QueueBinding</span>(<br>            value = <span class="hljs-variable">@Queue</span>(name = <span class="hljs-string">&quot;direct.queue1&quot;</span>),<br>            exchange = <span class="hljs-variable">@Exchange</span>(name = <span class="hljs-string">&quot;it.direct&quot;</span>,type = ExchangeTypes.DIRECT),<br>            key = &#123;<span class="hljs-string">&quot;red&quot;</span>,<span class="hljs-string">&quot;blue&quot;</span>&#125;<br>    ))<br>public void <span class="hljs-built_in">directlistener1</span>(String msg)&#123;<br>       <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;direct.queue1收到消息队列得消息:&quot;</span>+msg);<br>    &#125;<br><br>@<span class="hljs-selector-tag">RabbitListener</span>(bindings = <span class="hljs-variable">@QueueBinding</span>(<br>            value = <span class="hljs-variable">@Queue</span>(name = <span class="hljs-string">&quot;direct.queue2&quot;</span>),<br>            exchange = <span class="hljs-variable">@Exchange</span>(name = <span class="hljs-string">&quot;it.direct&quot;</span>,type = ExchangeTypes.DIRECT),<br>            key = &#123;<span class="hljs-string">&quot;red&quot;</span>,<span class="hljs-string">&quot;yellow&quot;</span>&#125;<br>    ))<br><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">directlistener2</span>(String msg)&#123;<br>        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;direct.queue2收到消息队列得消息:&quot;</span>+msg);<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到it.direct已经被创建，并且绑定了2个队列，各有2个Routinkey</p><p><img src="/../mq_pic/23.png"></p><p><img src="/../mq_pic/24.png"></p><p><img src="/../mq_pic/18.png"></p><p><img src="/../mq_pic/19.png"></p><p>TopicExchange与DirectExchange类似，区别在于routingkey必须是多个单词的列表，并且以 “.”分割、eg:china.news     china.weather</p><p><strong>TopicExchange指定BingdingKey时可以指定通配符</strong></p><p><strong>#:代指0个或多个单词</strong></p><p><em>：*<em>代指1个单词</em></em></p><p>TopicExchange与DirectExchange代码几乎一样，只有routingkey是包含通配符的，交换机类型是Topic的。</p><h2 id="生产者与消费者流程"><a href="#生产者与消费者流程" class="headerlink" title="生产者与消费者流程"></a>生产者与消费者流程</h2><p><strong>生产者：</strong></p><p>1.建立Connection</p><p>2.创建channel</p><p>3.利用channel声明队列</p><p>4.利用channel向队列发送消息</p><p><strong>消费者：</strong></p><p>1.建立Connection</p><p>2.创建channel</p><p>3.利用channel声明队列</p><p>4.定义consumer的消费行为handleDelivery()</p><p>5.利用channel将消费者与队列绑定</p><h2 id="2-0-SpringAMQP"><a href="#2-0-SpringAMQP" class="headerlink" title="2.0 SpringAMQP"></a>2.0 SpringAMQP</h2><p><img src="/../mq_pic/20.png"></p><p><img src="/../mq_pic/21.png"></p><p>传统的利用AMQP代码复杂，所以用SpringAMQP简化开发</p><h2 id="利用SpringAMQP完成简单通信"><a href="#利用SpringAMQP完成简单通信" class="headerlink" title="利用SpringAMQP完成简单通信"></a>利用SpringAMQP完成简单通信</h2><h3 id="1-引入AMQP依赖"><a href="#1-引入AMQP依赖" class="headerlink" title="1.引入AMQP依赖"></a>1.引入AMQP依赖</h3><p>因为publisher和consumer服务都需要amqp依赖，因此这里把依赖直接放到父工程中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-在publisher中编写测试方法，向消息队列中发送信息"><a href="#2-在publisher中编写测试方法，向消息队列中发送信息" class="headerlink" title="2.在publisher中编写测试方法，向消息队列中发送信息"></a>2.在publisher中编写测试方法，向消息队列中发送信息</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.234</span><span class="hljs-number">.132</span> <span class="hljs-comment"># rabbitMQ的ip地址</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">pjf</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br></code></pre></td></tr></table></figure><h3 id="3-编写生产者测试代码"><a href="#3-编写生产者测试代码" class="headerlink" title="3.编写生产者测试代码"></a>3.编写生产者测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAMQPTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">springamqpsend</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queuename</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;hello amqp&quot;</span>;<br>        rabbitTemplate.convertAndSend(queuename,msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><p>要先有这个队列才行，没有这个队列的记得创建队列哦</p><p>空队列没有消息的，记得自己创建队列，因为这个不会主动创建队列</p><p><strong>所以得自己去管理界面先创建simple.queue</strong></p><h3 id="4-编写消费者测试代码"><a href="#4-编写消费者测试代码" class="headerlink" title="4. 编写消费者测试代码"></a>4. 编写消费者测试代码</h3><p>同样需要引入依赖，编写配置信息</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAMQPListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">&quot;simple.queue&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">listener</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> msg</span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;收到消息队列得消息&quot;</span>+msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动启动文件后收到消息</p><p>实在太优雅了！！！</p><h2 id="2-1消息转换器"><a href="#2-1消息转换器" class="headerlink" title="2.1消息转换器"></a>2.1消息转换器</h2><p>AMQP原生API发送消息是字节形式，但是SpringAMQP的rabbitTemplate.convertAndSend中的参数是Object类型，</p><p>Spring的对消息对象的处理是由org.springframework.amqp.support.converter.MessageConveter来处理的，默认实现是SimpleMessageConverter,基于JDK的ObjectOutPutStream完成序列化，效率和安全性低。</p><p>解决方法：</p><p>我们在publisher服务中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在生产者服务声明MessageConverter:覆盖原有转换器</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Bean</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title class_">MessageConverter</span> <span class="hljs-title function_">messageConversionException</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>   &#125;<br></code></pre></td></tr></table></figure><p>注意，在生产者和消费者都需要做以上步骤，引依赖和写转换器。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2023/03/14/Spring/"/>
    <url>/2023/03/14/Spring/</url>
    
    <content type="html"><![CDATA[<h2 id="静态资源映射"><a href="#静态资源映射" class="headerlink" title="静态资源映射"></a>静态资源映射</h2><p>一般情况下，SpringBoot只能访问static或者是templates下的静态资源文件，如果想改变静态资源文件的位置需要开启静态资源文件映射(通过配置类的方式)</p><p><strong>classpath:&#x2F;</strong>  对应的就是resources这个目录。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>protected void add<span class="hljs-constructor">ResourceHandlers(ResourceHandlerRegistry <span class="hljs-params">registry</span>)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;开启静态资源映射&quot;</span>);<br>   registry.add<span class="hljs-constructor">ResourceHandler(<span class="hljs-string">&quot;/backend/**&quot;</span>)</span>.add<span class="hljs-constructor">ResourceLocations(<span class="hljs-string">&quot;classpath:/backend/&quot;</span>)</span>;<br>registry.add<span class="hljs-constructor">ResourceHandler(<span class="hljs-string">&quot;/front/**&quot;</span>)</span>.add<span class="hljs-constructor">ResourceLocations(<span class="hljs-string">&quot;classpath:/front/&quot;</span>)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>**是通配符，指一切资源</p><p>如果访问localhost:8080&#x2F;backend&#x2F;index.html,则会映射到resources&#x2F;backend&#x2F;index.html</p><h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p>在日常开发中，我们系统的每个业务方法可能包括多个原子性的数据库操作，比如下面的 <code>savePerson()</code>方法中就有两个原子性的数据库操作。这些原子性的数据库操作是由依赖的，它们要么都执行，要么都不执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">savePerson</span><span class="hljs-params">()</span> &#123;<br>personDao.save(person);<br>personDetailDao.save(personDetail);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><p>事务能否生效数据库是否支持事务是关键。比如常用的MySQL默认的是使用支持事务的innodb引擎。但是如果把数据库变为myisam，那么程序不支持事务了。</p><p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：</p><blockquote><ol><li>将小明的余额减少 1000 元。</li><li>将小红的余额增加 1000 元。</li></ol></blockquote><h3 id="事务的特性-ACID-了解吗？"><a href="#事务的特性-ACID-了解吗？" class="headerlink" title="事务的特性(ACID)了解吗？"></a>事务的特性(ACID)了解吗？</h3><ul><li><p><strong>原子性（Atomicity）</strong>:原子性是指事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。</p><p>可采用“A向B转账”这个例子来说明解释</p><p>在DBMS中，默认情况下一条SQL就是一个单独事务，事务是自动提交的。只有显式的使用start transaction开启一个事务，才能将一个代码块放在事务中执行。</p></li><li><p><strong>一致性（Consistency）：</strong> 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等</p></li><li><p><strong>隔离性（Isolation）</strong>： 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p></li><li><p><strong>持久性（Durability）:</strong> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>重学操作系统</title>
    <link href="/2023/03/11/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/03/11/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h2><p><img src="/../os_pic/1.png"></p><p><strong>操作系统(OS)</strong> 是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件</p><p><img src="/../os_pic/2.png"></p><p>补充：进程是一个程序的执行过程。执行前需要将该程序放到内存中，才能被CPU处理。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="/../os_pic/4.png"></p><h2 id="系统资源管理"><a href="#系统资源管理" class="headerlink" title="系统资源管理"></a>系统资源管理</h2><p><img src="/../os_pic/3.png"></p><ul><li><p>Step1—&gt;文件管理</p></li><li><p>Step2—&gt;存储器管理(内存管理)</p></li><li><p>Step3—&gt;处理机管理</p></li><li><p>Step4—&gt;设备管理</p></li></ul><h2 id="作为用户和计算机硬件之间的接口"><a href="#作为用户和计算机硬件之间的接口" class="headerlink" title="作为用户和计算机硬件之间的接口"></a>作为用户和计算机硬件之间的接口</h2><p><img src="/../os_pic/5.png"></p><p><img src="/../os_pic/6.png"></p><h3 id="联机命令接口"><a href="#联机命令接口" class="headerlink" title="联机命令接口"></a>联机命令接口</h3><p><img src="/../os_pic/7.png"></p><p>联机命令接口&#x3D;交互式命令接口</p><h3 id="脱机命令接口"><a href="#脱机命令接口" class="headerlink" title="脱机命令接口"></a>脱机命令接口</h3><p><img src="/../os_pic/8.png"></p><h3 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h3><p>程序接口(允许用户通过程序<strong>间接</strong>使用)：由一组<strong>系统调用组成</strong>(程序接口&#x3D;系统调用)</p><h2 id="接口总结"><a href="#接口总结" class="headerlink" title="接口总结"></a>接口总结</h2><p><img src="/../os_pic/9.png"></p><p><img src="/../os_pic/10.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/../os_pic/11.png"></p><h2 id="操作系统的四大特征"><a href="#操作系统的四大特征" class="headerlink" title="操作系统的四大特征"></a>操作系统的四大特征</h2><p><img src="/../os_pic/12.png"></p><p>四大特征：并发,共享，虚拟，异步</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="并发的概念及与并行的区别"><a href="#并发的概念及与并行的区别" class="headerlink" title="并发的概念及与并行的区别"></a>并发的概念及与并行的区别</h3><p><img src="/../os_pic/13.png"></p><p><img src="/../os_pic/14.png"></p><h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p><img src="/../os_pic/15.png"></p><p>但是同时共享访问也有“同时”访问的，不是微观上的交替，比如扬声器一边播放游戏声音一边播放音乐声音</p><h2 id="并发与共享的关系"><a href="#并发与共享的关系" class="headerlink" title="并发与共享的关系"></a>并发与共享的关系</h2><p><img src="/../os_pic/16.png"></p><h2 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h2><h3 id="虚拟-空分复用技术"><a href="#虚拟-空分复用技术" class="headerlink" title="虚拟-空分复用技术"></a>虚拟-空分复用技术</h3><p><img src="/../os_pic/17.png"></p><h3 id="虚拟-时分复用"><a href="#虚拟-时分复用" class="headerlink" title="虚拟-时分复用"></a>虚拟-时分复用</h3><p><img src="/../os_pic/18.png"></p><p>显然，如果失去了并发性，则一个时间段内系统中只需要运行一道程序，那么就失去了实习虚拟性的意义了。因此，没有并发性，就谈不上虚拟性。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p><img src="/../os_pic/19.png"></p><p>这点在Java高并发中体现明显，需要用到锁🔒解决</p><h2 id="操作系统四大特征总结"><a href="#操作系统四大特征总结" class="headerlink" title="操作系统四大特征总结"></a>操作系统四大特征总结</h2><p><img src="/../os_pic/20.png"></p><h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h2><p><img src="/../os_pic/21.png"></p><h3 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h3><p><img src="/../os_pic/22.png"></p><p>CPU计算快，但纸带输入太慢，造成CPU浪费</p><h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h3><p><img src="/../os_pic/23.png"></p><p>提前把程序输入到磁带中，提高输入输出速度</p><h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><p><img src="/../os_pic/24.png"></p><h3 id="单道批处理与多道批处理对比"><a href="#单道批处理与多道批处理对比" class="headerlink" title="单道批处理与多道批处理对比"></a>单道批处理与多道批处理对比</h3><p><img src="/../os_pic/25.png"></p><p><img src="/../os_pic/26.png"></p><h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3><p><img src="/../os_pic/27.png"></p><h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><p><img src="/../os_pic/28.png"></p><h3 id="其他几种操作系统-了解即可"><a href="#其他几种操作系统-了解即可" class="headerlink" title="其他几种操作系统(了解即可)"></a>其他几种操作系统(了解即可)</h3><p><img src="/../os_pic/29.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C/C++的五个区</title>
    <link href="/2023/02/28/CC++%E7%9A%84%E4%BA%94%E4%B8%AA%E5%8C%BA/"/>
    <url>/2023/02/28/CC++%E7%9A%84%E4%BA%94%E4%B8%AA%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="c语言中的5大内存分区"><a href="#c语言中的5大内存分区" class="headerlink" title="c语言中的5大内存分区"></a><a href="https://www.cnblogs.com/souhaite/p/10941824.html">c语言中的5大内存分区</a></h1><p>在C&#x2F;C++中，内存分成5个区，他们分别是<strong>堆、栈、自由存储区、全局&#x2F;静态存储区和常量存储区</strong>。</p><p>1.<strong>栈</strong>，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量存储区。里面的变量通常是局部变量、函数参数等。</p><p>2.<strong>堆</strong>，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p><p>3.<strong>自由存储区</strong>，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。</p><p>4.<strong>全局&#x2F;静态存储区</strong>，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。</p><p>5.<strong>常量存储区</strong>，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多）</p><p>明确区分堆与栈<br>在bbs上，堆与栈的区分问题，似乎是一个永恒的话题，由此可见，初学者对此往往是混淆不清的，所以我决定拿他第一个开刀。</p><p>首先，我们举一个例子：<br>void f() { int* p&#x3D;new int[5]; }<br>这条短短的一句话就包含了堆与栈，看到new，我们首先就应该想到，我们分配了一块堆内存，那么指针p呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针p。在程序会先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块内存的首地址，放入栈中，他在VC6下的汇编代码如下：</p><p>00401028 push 14h<br>0040102A call operator new (00401060)<br>0040102F add esp,4<br>00401032 mov dword ptr [ebp-8],eax<br>00401035 mov eax,dword ptr [ebp-8]<br>00401038 mov dword ptr [ebp-4],eax</p><p>这里，我们为了简单并没有释放内存，那么该怎么去释放呢？是delete p么？澳，错了，应该是delete []p，这是为了告诉编译器：我删除的是一个数组，VC6就会根据相应的Cookie信息去进行释放内存的工作。<br>好了，我们回到我们的主题：堆和栈究竟有什么区别？<br>主要的区别由以下几点：<br>1、管理方式不同；<br>2、空间大小不同；<br>3、能否产生碎片不同；<br>4、生长方向不同；<br>5、分配方式不同；<br>6、分配效率不同；</p><p>管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。<br>空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：<br>打开工程，依次操作菜单如下：Project-&gt;Setting-&gt;Link，在Category 中选中Output，然后在Reserve中设定堆栈的最大值和commit。<br>注意：reserve最小值为4Byte；commit是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。</p><p>碎片问题：对于堆来讲，频繁的new&#x2F;delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。</p><p>生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。</p><p>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p><p>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C&#x2F;C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构&#x2F;操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p><p>从这里我们可以看到，堆和栈相比，由于大量new&#x2F;delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。</p><p>虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。<br>无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果,就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候debug可是相当困难的：）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper</title>
    <link href="/2023/02/26/Zookeeper/"/>
    <url>/2023/02/26/Zookeeper/</url>
    
    <content type="html"><![CDATA[<h2 id="Zookeeper概念"><a href="#Zookeeper概念" class="headerlink" title="Zookeeper概念"></a>Zookeeper概念</h2><p><img src="/../zk_pic/zk1.png"></p><h2 id="Zookeeper数据模型"><a href="#Zookeeper数据模型" class="headerlink" title="Zookeeper数据模型"></a>Zookeeper数据模型</h2><p><img src="/../zk_pic/zk2.png"></p><h2 id="Linux下的服务端命令"><a href="#Linux下的服务端命令" class="headerlink" title="Linux下的服务端命令"></a>Linux下的服务端命令</h2><p>比较简单：</p><p><img src="/../zk_pic/zk3.png"></p><h2 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h2><p><img src="/../zk_pic/zk4.png"></p><p><img src="/../zk_pic/zk5.png"></p><h2 id="Zookeeper客户端curator常用操作API"><a href="#Zookeeper客户端curator常用操作API" class="headerlink" title="Zookeeper客户端curator常用操作API"></a>Zookeeper客户端curator常用操作API</h2><p><img src="/../zk_pic/zk06.png"></p><h2 id="常用分布式锁"><a href="#常用分布式锁" class="headerlink" title="常用分布式锁"></a>常用分布式锁</h2><p><img src="/../zk_pic/zk7.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯</title>
    <link href="/2023/02/26/%E5%9B%9E%E6%BA%AF/"/>
    <url>/2023/02/26/%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="回朔法的思想："><a href="#回朔法的思想：" class="headerlink" title="回朔法的思想："></a>回朔法的思想：</h3><p>回朔法的重要思想在于： 通过枚举法，对所有可能性进行遍历。 但是枚举的顺序是 一条路走到黑，发现黑之后，退一步，再向前尝试没走过的路。直到所有路都试过。因此回朔法可以简单的理解为： 走不通就退一步的方枚举法就叫回朔法。而这里回退点也叫做回朔点。</p><h3 id="回朔关键点"><a href="#回朔关键点" class="headerlink" title="回朔关键点"></a>回朔关键点</h3><p>通过分析发现，回朔法实现的三大技术关键点分别是：</p><ol><li>一条路走到黑</li><li>回退一步</li><li>另寻他路</li></ol><h3 id="关键点的实现"><a href="#关键点的实现" class="headerlink" title="关键点的实现"></a>关键点的实现</h3><p>那么如何才能用代码实现上述三个关键点呢？</p><ol><li>for 循环</li><li>递归</li></ol><h4 id="解释如下"><a href="#解释如下" class="headerlink" title="解释如下"></a>解释如下</h4><ul><li>for循环的作用在于另寻他路： 你可以用for循环可以实现一个路径选择器的功能，该路径选择器可以逐个选择当前节点下的所有可能往下走下去的分支路径。 例如： 现在你走到了节点a，a就像个十字路口，你从上面来到达了a，可以继续向下走。若此时向下走的路有i条，那么你肯定要逐个的把这i条都试一遍才行。而for的作用就是可以让你逐个把所有向下的i个路径既不重复，也不缺失的都试一遍</li><li>递归可以实现一条路走到黑和回退一步： 一条路走到黑： 递归意味着继续向着for给出的路径向下走一步。 如果我们把递归放在for循环内部，那么for每一次的循环，都在给出一个路径之后，进入递归，也就继续向下走了。直到递归出口（走无可走）为止。 那么这就是一条路走到黑的实现方法。 递归从递归出口出来之后，就会实现回退一步。</li></ul><p>因此for循环和递归配合可以实现回朔： 当递归从递归出口出来之后。上一层的for循环就会继续执行了。而for循环的继续执行就会给出当前节点下的下一条可行路径。而后递归调用，就顺着这条从未走过的路径又向下走一步。这就是回朔</p><p>说了这么多，回朔法的通常模板是什么呢？ 递归和for又是如何配合的呢？</p><h4 id="回朔代码模板"><a href="#回朔代码模板" class="headerlink" title="回朔代码模板"></a>回朔代码模板</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>():<br>    <br>    <span class="hljs-keyword">if</span> (回朔点）：<span class="hljs-comment"># 这条路走到底的条件。也是递归出口</span><br>        保存该结果<br>        <span class="hljs-keyword">return</span>   <br>    <br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> route <span class="hljs-keyword">in</span> all_route_set :  逐步选择当前节点下的所有可能route<br>            <br>            <span class="hljs-keyword">if</span> 剪枝条件：<br>                剪枝前的操作<br>                <span class="hljs-keyword">return</span>   <span class="hljs-comment">#不继续往下走了，退回上层，换个路再走</span><br>            <br>            <span class="hljs-keyword">else</span>：<span class="hljs-comment">#当前路径可能是条可行路径</span><br>            <br>                保存当前数据  <span class="hljs-comment">#向下走之前要记住已经走过这个节点了。例如push当前节点</span><br>        <br>                self.backward() <span class="hljs-comment">#递归发生，继续向下走一步了。</span><br>                <br>                回朔清理     <span class="hljs-comment"># 该节点下的所有路径都走完了，清理堆栈，准备下一个递归。例如弹出当前节点</span><br></code></pre></td></tr></table></figure><p>这里剪枝操作指的是： 对于有些问题，你走着走着，若某种情况发生了，你就已经直到不能继续往下走了，再走也没有用了。而这个情况就被称之为剪枝条件。</p><p>而DFS就是一个最典型的回朔法的应用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum</span>(<span class="hljs-params">self, candidates: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(candidates) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        candidates.sort()<br>        path = []<br>        res = []<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        ！！！重点！！！</span><br><span class="hljs-string">        在python中，如果传参是mutable var, 那么传参相当于引用，因此调用后，如果调用函数的内部对该传入变量进行修改，就会导致直接改变原始对象。这就是典型的privacy leak！！发生了。</span><br><span class="hljs-string">        例如在这个，list就是该mutable var，而如果以path或res 为传参，放在__DFS 中， 那么就相当于在__DFS内部，实际上用的都是一个物理地址下的res和path，类似于全局变量。</span><br><span class="hljs-string">        因此combinationSum下的局部变量path和res也在——DFS运行的过程中发生了改变。</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        利用这个性质，我们可以把mutable var当成传入参数，从而实现全局变量的效果。</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        self.__DFS(candidates, target, <span class="hljs-number">0</span>, path, res)<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        DFS的实现</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__DFS</span>(<span class="hljs-params">self, candidates, target, begin, path, res</span>):<br>        path = path.copy()<br>        <span class="hljs-comment"># 递归出口 就是余数为0</span><br>        <span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span>:<br>            res.append(path)   <span class="hljs-comment">#记录该符合条件的结果</span><br>            <span class="hljs-keyword">return</span><br>        <br>        <span class="hljs-comment">#若当前路径有可能可行。</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(begin, <span class="hljs-built_in">len</span>(candidates)):  <span class="hljs-comment"># 我们现在到begin的节点上了</span><br>            <span class="hljs-keyword">if</span> target - candidates[i] &lt; <span class="hljs-number">0</span>:  <span class="hljs-comment"># 剪枝条件</span><br>                <span class="hljs-keyword">return</span>                      <span class="hljs-comment"># 如果当前节点就不行了，就不用继续了,这里到不用继续了即包括该depth不用继续了，也包括该节点更大到child也不用继续了，该节点pop出来</span><br>            <br>            path.append(candidates[i])  <span class="hljs-comment">#记录当前为止</span><br>            self.__DFS(candidates, target - candidates[i], i, path, res)<span class="hljs-comment"># 向下继续走，记住递归不是return，递归到实现是调用！一旦return发生，递归停止。</span><br>            path.pop()  <span class="hljs-comment"># 回朔清理。当前节点下的所有情况都进行完了，该节点也不应该在path里面了。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/2023/02/23/Docker/"/>
    <url>/2023/02/23/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="1-初识Docker"><a href="#1-初识Docker" class="headerlink" title="1.初识Docker"></a>1.初识Docker</h1><h2 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1.什么是Docker"></a>1.1.什么是Docker</h2><p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p><ul><li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li><li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li></ul><h3 id="1-1-1-应用部署的环境问题"><a href="#1-1-1-应用部署的环境问题" class="headerlink" title="1.1.1.应用部署的环境问题"></a>1.1.1.应用部署的环境问题</h3><p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p><ul><li><p>依赖关系复杂，容易出现兼容性问题</p></li><li><p>开发、测试、生产环境有差异</p></li></ul><p><img src="/../docker_pic/image-20210731141907366.png" alt="image-20210731141907366"></p><p>例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</p><h3 id="1-1-2-Docker解决依赖兼容问题"><a href="#1-1-2-Docker解决依赖兼容问题" class="headerlink" title="1.1.2.Docker解决依赖兼容问题"></a>1.1.2.Docker解决依赖兼容问题</h3><p>而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？</p><p>Docker为了解决依赖的兼容问题的，采用了两个手段：</p><ul><li><p>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</p></li><li><p>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</p></li></ul><p><img src="/../docker_pic/image-20210731142219735.png" alt="image-20210731142219735"></p><p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p><p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p><h3 id="1-1-3-Docker解决操作系统环境差异"><a href="#1-1-3-Docker解决操作系统环境差异" class="headerlink" title="1.1.3.Docker解决操作系统环境差异"></a>1.1.3.Docker解决操作系统环境差异</h3><p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下：</p><p><img src="/../docker_pic/image-20210731143401460.png" alt="image-20210731143401460"></p><p>结构包括：</p><ul><li>计算机硬件：例如CPU、内存、磁盘等</li><li>系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供<strong>内核指令</strong>，用于操作计算机硬件。</li><li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li></ul><p>应用于计算机交互的流程如下：</p><p>1）应用调用操作系统应用（函数库），实现各种功能</p><p>2）系统函数库是对内核指令集的封装，会调用内核指令</p><p>3）内核指令操作计算机硬件</p><p>Ubuntu和CentOSpringBoot都是基于Linux内核，无非是系统应用不同，提供的函数库有差异：</p><p><img src="/../docker_pic/image-20210731144304990.png" alt="image-20210731144304990"></p><p>此时，如果将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了：</p><p><img src="/../docker_pic/image-20210731144458680.png" alt="image-20210731144458680"></p><p>Docker如何解决不同系统环境的问题？</p><ul><li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li><li>Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行</li></ul><p>如图：</p><p><img src="/../docker_pic/image-20210731144820638.png" alt="image-20210731144820638"></p><h3 id="1-1-4-小结"><a href="#1-1-4-小结" class="headerlink" title="1.1.4.小结"></a>1.1.4.小结</h3><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li></ul><p>Docker如何解决开发、测试、生产环境有差异的问题？</p><ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul><p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p><ul><li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li><li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li><li>启动、移除都可以通过一行命令完成，方便快捷</li></ul><h2 id="1-2-Docker和虚拟机的区别"><a href="#1-2-Docker和虚拟机的区别" class="headerlink" title="1.2.Docker和虚拟机的区别"></a>1.2.Docker和虚拟机的区别</h2><p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p><p>两者有什么差异呢？</p><p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟</strong>硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</p><p><strong>Docker</strong>仅仅是封装函数库，并没有模拟完整的操作系统，如图：</p><p><img src="/../docker_pic/image-20210731145914960.png" alt="image-20210731145914960"></p><p>对比来看：</p><p><img src="/../docker_pic/image-20210731152243765.png" alt="image-20210731152243765"></p><p>小结：</p><p>Docker和虚拟机的差异：</p><ul><li><p>docker是一个系统进程；虚拟机是在操作系统中的操作系统</p></li><li><p>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</p></li></ul><h2 id="1-3-Docker架构"><a href="#1-3-Docker架构" class="headerlink" title="1.3.Docker架构"></a>1.3.Docker架构</h2><h3 id="1-3-1-镜像和容器"><a href="#1-3-1-镜像和容器" class="headerlink" title="1.3.1.镜像和容器"></a>1.3.1.镜像和容器</h3><p>Docker中有几个重要的概念：</p><p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p><p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p><p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p><p>而<strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p><p><strong>容器</strong>呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p><p><img src="/../docker_pic/image-20210731153059464.png" alt="image-20210731153059464"></p><p>例如你下载了一个QQ，如果我们将QQ在磁盘上的运行<strong>文件</strong>及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。</p><h3 id="1-3-2-DockerHub"><a href="#1-3-2-DockerHub" class="headerlink" title="1.3.2.DockerHub"></a>1.3.2.DockerHub</h3><p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。</p><ul><li><p>DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。</p></li><li><p>国内也有类似于DockerHub 的公开服务，比如 <a href="https://c.163yun.com/hub">网易云镜像服务</a>、<a href="https://cr.console.aliyun.com/">阿里云镜像库</a>等。</p></li></ul><p>我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像：</p><p><img src="/../docker_pic/image-20210731153743354.png" alt="image-20210731153743354"></p><h3 id="1-3-3-Docker架构"><a href="#1-3-3-Docker架构" class="headerlink" title="1.3.3.Docker架构"></a>1.3.3.Docker架构</h3><p>我们要使用Docker来操作镜像、容器，就必须要安装Docker。</p><p>Docker是一个CS架构的程序，由两部分组成：</p><ul><li><p>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</p></li><li><p>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</p></li></ul><p>如图：</p><p><img src="/../docker_pic/image-20210731154257653.png" alt="image-20210731154257653"></p><h3 id="1-3-4-小结"><a href="#1-3-4-小结" class="headerlink" title="1.3.4.小结"></a>1.3.4.小结</h3><p>镜像：</p><ul><li>将应用程序及其依赖、环境、配置打包在一起</li></ul><p>容器：</p><ul><li>镜像运行起来就是容器，一个镜像可以运行多个容器</li></ul><p>Docker结构：</p><ul><li><p>服务端：接收命令或远程请求，操作镜像或容器</p></li><li><p>客户端：发送命令或者请求到Docker服务端</p></li></ul><p>DockerHub：</p><ul><li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li></ul><h2 id="1-4-安装Docker"><a href="#1-4-安装Docker" class="headerlink" title="1.4.安装Docker"></a>1.4.安装Docker</h2><p>企业部署一般都是采用Linux操作系统，而其中又数CentOS发行版占比最多，因此我们在CentOS下安装Docker。参考课前资料中的文档：</p><p><img src="/../docker_pic/image-20210731155002425.png" alt="image-20210731155002425"></p><h1 id="2-Docker的基本操作"><a href="#2-Docker的基本操作" class="headerlink" title="2.Docker的基本操作"></a>2.Docker的基本操作</h1><h2 id="2-1-镜像操作"><a href="#2-1-镜像操作" class="headerlink" title="2.1.镜像操作"></a>2.1.镜像操作</h2><h3 id="2-1-1-镜像名称"><a href="#2-1-1-镜像名称" class="headerlink" title="2.1.1.镜像名称"></a>2.1.1.镜像名称</h3><p>首先来看下镜像的名称组成：</p><ul><li>镜名称一般分两部分组成：[repository]:[tag]。</li><li>在没有指定tag时，默认是latest，代表最新版本的镜像</li></ul><p>如图：</p><p><img src="/../docker_pic/image-20210731155141362.png" alt="image-20210731155141362"></p><p>这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。</p><h3 id="2-1-2-镜像命令"><a href="#2-1-2-镜像命令" class="headerlink" title="2.1.2.镜像命令"></a>2.1.2.镜像命令</h3><p>常见的镜像操作命令如图：</p><p><img src="/../docker_pic/image-20210731155649535.png" alt="image-20210731155649535"></p><h3 id="2-1-3-案例1-拉取、查看镜像"><a href="#2-1-3-案例1-拉取、查看镜像" class="headerlink" title="2.1.3.案例1-拉取、查看镜像"></a>2.1.3.案例1-拉取、查看镜像</h3><p>需求：从DockerHub中拉取一个nginx镜像并查看</p><p>1）首先去镜像仓库搜索nginx镜像，比如<a href="https://hub.docker.com/">DockerHub</a>:</p><p><img src="/../docker_pic/image-20210731155844368.png" alt="image-20210731155844368"></p><p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p><p><img src="/../docker_pic/image-20210731155856199.png" alt="image-20210731155856199"></p><p>3）通过命令：docker images 查看拉取到的镜像</p><p><img src="/../docker_pic/image-20210731155903037.png" alt="image-20210731155903037"></p><h3 id="2-1-4-案例2-保存、导入镜像"><a href="#2-1-4-案例2-保存、导入镜像" class="headerlink" title="2.1.4.案例2-保存、导入镜像"></a>2.1.4.案例2-保存、导入镜像</h3><p>需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来</p><p>1）利用docker xx –help命令查看docker save和docker load的语法</p><p>例如，查看save命令用法，可以输入命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker save --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/../docker_pic/image-20210731161104732.png" alt="image-20210731161104732"></p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker save -o [保存的目标文件名称] [镜像名称]<br></code></pre></td></tr></table></figure><p>2）使用docker save导出镜像到磁盘 </p><p>运行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker save -o nginx.tar nginx:latest<br></code></pre></td></tr></table></figure><p>结果如图：</p><p><img src="/../docker_pic/image-20210731161354344.png" alt="image-20210731161354344"></p><p>3）使用docker load加载镜像</p><p>先删除本地的nginx镜像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker rmi nginx:latest<br></code></pre></td></tr></table></figure><p>然后运行命令，加载本地文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker load -i nginx.tar<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/../docker_pic/image-20210731161746245.png" alt="image-20210731161746245"></p><h3 id="2-1-5-练习"><a href="#2-1-5-练习" class="headerlink" title="2.1.5.练习"></a>2.1.5.练习</h3><p>需求：去DockerHub搜索并拉取一个Redis镜像</p><p>目标：</p><p>1）去DockerHub搜索Redis镜像</p><p>2）查看Redis镜像的名称和版本</p><p>3）利用docker pull命令拉取镜像</p><p>4）利用docker save命令将 redis:latest打包为一个redis.tar包</p><p>5）利用docker rmi 删除本地的redis:latest</p><p>6）利用docker load 重新加载 redis.tar文件</p><h2 id="2-2-容器操作"><a href="#2-2-容器操作" class="headerlink" title="2.2.容器操作"></a>2.2.容器操作</h2><h3 id="2-2-1-容器相关命令"><a href="#2-2-1-容器相关命令" class="headerlink" title="2.2.1.容器相关命令"></a>2.2.1.容器相关命令</h3><p>容器操作的命令如图：</p><p><img src="/../docker_pic/image-20210731161950495.png" alt="image-20210731161950495"></p><p>容器保护三个状态：</p><ul><li>运行：进程正常运行</li><li>暂停：进程暂停，CPU不再运行，并不释放内存</li><li>停止：进程终止，回收进程占用的内存、CPU等资源</li></ul><p>其中：</p><ul><li><p>docker run：创建并运行一个容器，处于运行状态</p></li><li><p>docker pause：让一个运行的容器暂停</p></li><li><p>docker unpause：让一个容器从暂停状态恢复运行</p></li><li><p>docker stop：停止一个运行的容器</p></li><li><p>docker start：让一个停止的容器再次运行</p></li><li><p>docker rm：删除一个容器</p></li></ul><h3 id="2-2-2-案例-创建并运行一个容器"><a href="#2-2-2-案例-创建并运行一个容器" class="headerlink" title="2.2.2.案例-创建并运行一个容器"></a>2.2.2.案例-创建并运行一个容器</h3><p>创建并运行nginx容器的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run --name containerName -p 80:80 -d nginx<br></code></pre></td></tr></table></figure><p>命令解读：</p><ul><li>docker run ：创建并运行一个容器</li><li>–name : 给容器起一个名字，比如叫做mn</li><li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li><li>-d：后台运行容器</li><li>nginx：镜像名称，例如nginx</li></ul><p>这里的<code>-p</code>参数，是将容器端口映射到宿主机端口。</p><p>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。</p><p>现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了：</p><p><img src="/../docker_pic/image-20210731163255863.png" alt="image-20210731163255863"></p><h3 id="2-2-3-案例-进入容器，修改文件"><a href="#2-2-3-案例-进入容器，修改文件" class="headerlink" title="2.2.3.案例-进入容器，修改文件"></a>2.2.3.案例-进入容器，修改文件</h3><p><strong>需求</strong>：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您”</p><p><strong>提示</strong>：进入容器要用到docker exec命令。</p><p><strong>步骤</strong>：</p><p>1）进入容器。进入我们刚刚创建的nginx容器的命令为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it mn bash<br></code></pre></td></tr></table></figure><p>命令解读：</p><ul><li><p>docker exec ：进入容器内部，执行一个命令</p></li><li><p>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p></li><li><p>mn ：要进入的容器的名称</p></li><li><p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p></li></ul><p>2）进入nginx的HTML所在目录 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</p><p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p><p><img src="/../docker_pic/image-20210731164159811.png" alt="image-20210731164159811"></p><p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p><p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p><p>我们执行命令，进入该目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/share/nginx/html<br></code></pre></td></tr></table></figure><p> 查看目录下文件：</p><p><img src="/../docker_pic/image-20210731164455818.png" alt="image-20210731164455818"></p><p>3）修改index.html的内容</p><p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sed -i -e <span class="hljs-string">&#x27;s#Welcome to nginx#传智教育欢迎您#g&#x27;</span> -e <span class="hljs-string">&#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27;</span> index.html<br></code></pre></td></tr></table></figure><p>在浏览器访问自己的虚拟机地址，例如我的是：<a href="http://192.168.150.101，即可看到结果：">http://192.168.150.101，即可看到结果：</a></p><p><img src="/../docker_pic/image-20210731164717604.png" alt="image-20210731164717604"></p><h3 id="2-2-4-小结"><a href="#2-2-4-小结" class="headerlink" title="2.2.4.小结"></a>2.2.4.小结</h3><p>docker run命令的常见参数有哪些？</p><ul><li>–name：指定容器名称</li><li>-p：指定端口映射</li><li>-d：让容器后台运行</li></ul><p>查看容器日志的命令：</p><ul><li>docker logs</li><li>添加 -f 参数可以持续查看日志</li></ul><p>查看容器状态：</p><ul><li>docker ps</li><li>docker ps -a 查看所有容器，包括已经停止的</li></ul><h2 id="2-3-数据卷（容器数据管理）"><a href="#2-3-数据卷（容器数据管理）" class="headerlink" title="2.3.数据卷（容器数据管理）"></a>2.3.数据卷（容器数据管理）</h2><p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。</p><p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p><p><img src="/../docker_pic/image-20210731172440275.png" alt="image-20210731172440275"></p><p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p><h3 id="2-3-1-什么是数据卷"><a href="#2-3-1-什么是数据卷" class="headerlink" title="2.3.1.什么是数据卷"></a>2.3.1.什么是数据卷</h3><p><strong>数据卷（volume）</strong>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p><p><img src="/../docker_pic/image-20210731173541846.png" alt="image-20210731173541846"></p><p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p><p>这样，我们操作宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html目录，就等于操作容器内的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html目录了</p><h3 id="2-3-2-数据集操作命令"><a href="#2-3-2-数据集操作命令" class="headerlink" title="2.3.2.数据集操作命令"></a>2.3.2.数据集操作命令</h3><p>数据卷操作的基本语法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker volume [COMMAND]<br></code></pre></td></tr></table></figure><p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p><ul><li>create 创建一个volume</li><li>inspect 显示一个或多个volume的信息</li><li>ls 列出所有的volume</li><li>prune 删除未使用的volume</li><li>rm 删除一个或多个指定的volume</li></ul><h3 id="2-3-3-创建和查看数据卷"><a href="#2-3-3-创建和查看数据卷" class="headerlink" title="2.3.3.创建和查看数据卷"></a>2.3.3.创建和查看数据卷</h3><p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p><p>① 创建数据卷</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker volume create html<br></code></pre></td></tr></table></figure><p>② 查看所有数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker volume <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/../docker_pic/image-20210731173746910.png" alt="image-20210731173746910"></p><p>③ 查看数据卷详细信息卷</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker volume inspect html<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/../docker_pic/image-20210731173809877.png" alt="image-20210731173809877"></p><p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p><p><strong>小结</strong>：</p><p>数据卷的作用：</p><ul><li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li></ul><p>数据卷操作：</p><ul><li>docker volume create：创建数据卷</li><li>docker volume ls：查看所有数据卷</li><li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li><li>docker volume rm：删除指定数据卷</li><li>docker volume prune：删除所有未使用的数据卷</li></ul><h3 id="2-3-4-挂载数据卷"><a href="#2-3-4-挂载数据卷" class="headerlink" title="2.3.4.挂载数据卷"></a>2.3.4.挂载数据卷</h3><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run \<br>  --name mn \<br>  -v html:/root/html \<br>  -p 8080:80<br>  nginx \<br></code></pre></td></tr></table></figure><p>这里的-v就是挂载数据卷的命令：</p><ul><li><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的&#x2F;root&#x2F;html这个目录中</li></ul><h3 id="2-3-5-案例-给nginx挂载数据卷"><a href="#2-3-5-案例-给nginx挂载数据卷" class="headerlink" title="2.3.5.案例-给nginx挂载数据卷"></a>2.3.5.案例-给nginx挂载数据卷</h3><p><strong>需求</strong>：创建一个nginx容器，修改容器内的html目录内的index.html内容</p><p><strong>分析</strong>：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。</p><p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p><p>步骤：</p><p>① 创建容器并挂载数据卷到容器内的HTML目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx<br></code></pre></td></tr></table></figure><p>② 进入html数据卷所在位置，并修改HTML内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看html数据卷的位置</span><br>docker volume inspect html<br><span class="hljs-comment"># 进入该目录</span><br><span class="hljs-built_in">cd</span> /var/lib/docker/volumes/html/_data<br><span class="hljs-comment"># 修改文件</span><br>vi index.html<br></code></pre></td></tr></table></figure><h3 id="2-3-6-案例-给MySQL挂载本地目录"><a href="#2-3-6-案例-给MySQL挂载本地目录" class="headerlink" title="2.3.6.案例-给MySQL挂载本地目录"></a>2.3.6.案例-给MySQL挂载本地目录</h3><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p><ul><li>带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录</li><li>直接挂载模式：宿主机目录 —&gt; 容器内目录</li></ul><p>如图：</p><p><img src="/../docker_pic/image-20210731175155453.png" alt="image-20210731175155453"></p><p><strong>语法</strong>：</p><p>目录挂载与数据卷挂载的语法是类似的：</p><ul><li>-v [宿主机目录]:[容器内目录]</li><li>-v [宿主机文件]:[容器内文件]</li></ul><p><strong>需求</strong>：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</p><p>实现思路如下：</p><p>1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像</p><p>2）创建目录&#x2F;tmp&#x2F;mysql&#x2F;data</p><p>3）创建目录&#x2F;tmp&#x2F;mysql&#x2F;conf，将课前资料提供的hmy.cnf文件上传到&#x2F;tmp&#x2F;mysql&#x2F;conf</p><p>4）去DockerHub查阅资料，创建并运行MySQL容器，要求：</p><p>① 挂载&#x2F;tmp&#x2F;mysql&#x2F;data到mysql容器内数据存储目录</p><p>② 挂载&#x2F;tmp&#x2F;mysql&#x2F;conf&#x2F;hmy.cnf到mysql容器的配置文件</p><p>③ 设置MySQL密码</p><h3 id="2-3-7-小结"><a href="#2-3-7-小结" class="headerlink" title="2.3.7.小结"></a>2.3.7.小结</h3><p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p><ul><li>-v volume名称:容器内目录</li><li>-v 宿主机文件:容器内文</li><li>-v 宿主机目录:容器内目录</li></ul><p>数据卷挂载与目录直接挂载的</p><ul><li>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</li><li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li></ul><h1 id="3-Dockerfile自定义镜像"><a href="#3-Dockerfile自定义镜像" class="headerlink" title="3.Dockerfile自定义镜像"></a>3.Dockerfile自定义镜像</h1><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p><p>而要自定义镜像，就必须先了解镜像的结构才行。</p><h2 id="3-1-镜像结构"><a href="#3-1-镜像结构" class="headerlink" title="3.1.镜像结构"></a>3.1.镜像结构</h2><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p><p>我们以MySQL为例，来看看镜像的组成结构：</p><p><img src="/../docker_pic/image-20210731175806273.png" alt="image-20210731175806273"></p><p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p><p>我们要构建镜像，其实就是实现上述打包的过程。</p><h2 id="3-2-Dockerfile语法"><a href="#3-2-Dockerfile语法" class="headerlink" title="3.2.Dockerfile语法"></a>3.2.Dockerfile语法</h2><p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p><p>我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。</p><p>而描述上述信息的文件就是Dockerfile文件。</p><p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p><p><img src="/../docker_pic/image-20210731180321133.png" alt="image-20210731180321133"></p><p>更新详细语法说明，请参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p><h2 id="3-3-构建Java项目"><a href="#3-3-构建Java项目" class="headerlink" title="3.3.构建Java项目"></a>3.3.构建Java项目</h2><h3 id="3-3-1-基于Ubuntu构建Java项目"><a href="#3-3-1-基于Ubuntu构建Java项目" class="headerlink" title="3.3.1.基于Ubuntu构建Java项目"></a>3.3.1.基于Ubuntu构建Java项目</h3><p>需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目</p><ul><li><p>步骤1：新建一个空文件夹docker-demo</p><p><img src="/../docker_pic/image-20210801101207444.png" alt="image-20210801101207444"></p></li><li><p>步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录</p><p><img src="/../docker_pic/image-20210801101314816.png" alt="image-20210801101314816"></p></li><li><p>步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录</p><p><img src="/../docker_pic/image-20210801101410200.png" alt="image-20210801101410200"></p></li><li><p>步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录</p><p><img src="/../docker_pic/image-20210801101455590.png" alt="image-20210801101455590"></p><p>其中的内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 指定基础镜像</span><br><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">16.04</span><br><span class="hljs-comment"># 配置环境变量，JDK的安装目录</span><br><span class="hljs-keyword">ENV</span> JAVA_DIR=/usr/local<br><br><span class="hljs-comment"># 拷贝jdk和java项目的包</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="hljs-variable">$JAVA_DIR</span>/</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span><br><br><span class="hljs-comment"># 安装JDK</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> <span class="hljs-variable">$JAVA_DIR</span> \</span><br><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span><br><span class="language-bash"> &amp;&amp; <span class="hljs-built_in">mv</span> ./jdk1.8.0_144 ./java8</span><br><br><span class="hljs-comment"># 配置环境变量</span><br><span class="hljs-keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8<br><span class="hljs-keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin<br><br><span class="hljs-comment"># 暴露端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8090</span><br><span class="hljs-comment"># 入口，java项目的启动命令</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span><br></code></pre></td></tr></table></figure></li><li><p>步骤5：进入docker-demo</p><p>将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下</p></li><li><p>步骤6：运行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker build -t javaweb:1.0 .<br></code></pre></td></tr></table></figure></li></ul><p>最后访问 <a href="http://192.168.150.101:8090/hello/count%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84ip%E6%94%B9%E6%88%90%E4%BD%A0%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BAip">http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip</a></p><h3 id="3-3-2-基于java8构建Java项目"><a href="#3-3-2-基于java8构建Java项目" class="headerlink" title="3.3.2.基于java8构建Java项目"></a>3.3.2.基于java8构建Java项目</h3><p>虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p><p>例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。</p><p>需求：基于java:8-alpine镜像，将一个Java项目构建为镜像</p><p>实现思路如下：</p><ul><li><p>① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile</p></li><li><p>② 拷贝课前资料提供的docker-demo.jar到这个目录中</p></li><li><p>③ 编写Dockerfile文件：</p><ul><li><p>a ）基于java:8-alpine作为基础镜像</p></li><li><p>b ）将app.jar拷贝到镜像中</p></li><li><p>c ）暴露端口</p></li><li><p>d ）编写入口ENTRYPOINT</p><p>内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span>-alpine<br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./app.jar /tmp/app.jar</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8090</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>④ 使用docker build命令构建镜像</p></li><li><p>⑤ 使用docker run创建容器并运行</p></li></ul><h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4.小结"></a>3.4.小结</h2><p>小结：</p><ol><li><p>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</p></li><li><p>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</p></li><li><p>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</p></li></ol><h1 id="4-Docker-Compose"><a href="#4-Docker-Compose" class="headerlink" title="4.Docker-Compose"></a>4.Docker-Compose</h1><p>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p><p><img src="/../docker_pic/image-20210731180921742.png" alt="image-20210731180921742"></p><h2 id="4-1-初识DockerCompose"><a href="#4-1-初识DockerCompose" class="headerlink" title="4.1.初识DockerCompose"></a>4.1.初识DockerCompose</h2><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json">version<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3.8&quot;</span><br> services<span class="hljs-punctuation">:</span><br>  mysql<span class="hljs-punctuation">:</span><br>    image<span class="hljs-punctuation">:</span> mysql<span class="hljs-punctuation">:</span><span class="hljs-number">5.7</span><span class="hljs-number">.25</span><br>    environment<span class="hljs-punctuation">:</span><br>     MYSQL_ROOT_PASSWORD<span class="hljs-punctuation">:</span> <span class="hljs-number">123</span> <br>    volumes<span class="hljs-punctuation">:</span><br>     - <span class="hljs-string">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span><br>     - <span class="hljs-string">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span><br>  web<span class="hljs-punctuation">:</span><br>    build<span class="hljs-punctuation">:</span> .<br>    ports<span class="hljs-punctuation">:</span><br>     - <span class="hljs-string">&quot;8090:8090&quot;</span><br><br></code></pre></td></tr></table></figure><p>上面的Compose文件就描述一个项目，其中包含两个容器：</p><ul><li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li><li>web：一个基于<code>docker build</code>临时构建的镜像容器，映射端口时8090</li></ul><p>DockerCompose的详细语法参考官网：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p><p>其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。</p><h2 id="4-2-安装DockerCompose"><a href="#4-2-安装DockerCompose" class="headerlink" title="4.2.安装DockerCompose"></a>4.2.安装DockerCompose</h2><p>参考课前资料</p><h2 id="4-3-部署微服务集群"><a href="#4-3-部署微服务集群" class="headerlink" title="4.3.部署微服务集群"></a>4.3.部署微服务集群</h2><p><strong>需求</strong>：将之前学习的cloud-demo微服务集群利用DockerCompose部署</p><p><strong>实现思路</strong>：</p><p>① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件</p><p>② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名</p><p>③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar</p><p>④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中</p><p>⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署</p><h3 id="4-3-1-compose文件"><a href="#4-3-1-compose文件" class="headerlink" title="4.3.1.compose文件"></a>4.3.1.compose文件</h3><p>查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录：</p><p><img src="/../docker_pic/image-20210731181341330.png" alt="image-20210731181341330"></p><p>内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.2&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">nacos:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nacos/nacos-server</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MODE:</span> <span class="hljs-string">standalone</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8848:8848&quot;</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7.25</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-number">123</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;$PWD/mysql/data:/var/lib/mysql&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;</span><br>  <span class="hljs-attr">userservice:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./user-service</span><br>  <span class="hljs-attr">orderservice:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./order-service</span><br>  <span class="hljs-attr">gateway:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./gateway</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;10010:10010&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到，其中包含5个service服务：</p><ul><li><code>nacos</code>：作为注册中心和配置中心<ul><li><code>image: nacos/nacos-server</code>： 基于nacos&#x2F;nacos-server镜像构建</li><li><code>environment</code>：环境变量<ul><li><code>MODE: standalone</code>：单点模式启动</li></ul></li><li><code>ports</code>：端口映射，这里暴露了8848端口</li></ul></li><li><code>mysql</code>：数据库<ul><li><code>image: mysql:5.7.25</code>：镜像版本是mysql:5.7.25</li><li><code>environment</code>：环境变量<ul><li><code>MYSQL_ROOT_PASSWORD: 123</code>：设置数据库root账户的密码为123</li></ul></li><li><code>volumes</code>：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据</li></ul></li><li><code>userservice</code>、<code>orderservice</code>、<code>gateway</code>：都是基于Dockerfile临时构建的</li></ul><p>查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表：</p><p><img src="/../docker_pic/image-20210801095205034.png" alt="image-20210801095205034"></p><p>查看微服务目录，可以看到都包含Dockerfile文件：</p><p><img src="/../docker_pic/image-20210801095320586.png" alt="image-20210801095320586"></p><p>内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span>-alpine<br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./app.jar /tmp/app.jar</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span><br></code></pre></td></tr></table></figure><h3 id="4-3-2-修改微服务配置"><a href="#4-3-2-修改微服务配置" class="headerlink" title="4.3.2.修改微服务配置"></a>4.3.2.修改微服务配置</h3><p>因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。</p><p>如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://mysql:3306/cloud_order?useSSL=false</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">orderservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">nacos:8848</span> <span class="hljs-comment"># nacos服务地址</span><br></code></pre></td></tr></table></figure><h3 id="4-3-3-打包"><a href="#4-3-3-打包" class="headerlink" title="4.3.3.打包"></a>4.3.3.打包</h3><p>接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。</p><p>可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 服务打包的最终名称 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>app<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>打包后：</p><p><img src="/../docker_pic/image-20210801095951030.png" alt="image-20210801095951030"></p><h3 id="4-3-4-拷贝jar包到部署目录"><a href="#4-3-4-拷贝jar包到部署目录" class="headerlink" title="4.3.4.拷贝jar包到部署目录"></a>4.3.4.拷贝jar包到部署目录</h3><p>编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。</p><p>user-service：</p><p><img src="/../docker_pic/image-20210801100201253.png" alt="image-20210801100201253"></p><p>order-service：</p><p><img src="/../docker_pic/image-20210801100231495.png" alt="image-20210801100231495"></p><p>gateway：</p><p><img src="/../docker_pic/image-20210801100308102.png" alt="image-20210801100308102"></p><h3 id="4-3-5-部署"><a href="#4-3-5-部署" class="headerlink" title="4.3.5.部署"></a>4.3.5.部署</h3><p>最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。</p><p>上传到任意目录：</p><p><img src="/../docker_pic/image-20210801100955653.png" alt="image-20210801100955653"></p><p>部署：</p><p>进入cloud-demo目录，然后运行下面的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker-compose up -d<br></code></pre></td></tr></table></figure><h1 id="5-Docker镜像仓库"><a href="#5-Docker镜像仓库" class="headerlink" title="5.Docker镜像仓库"></a>5.Docker镜像仓库</h1><h2 id="5-1-搭建私有镜像仓库"><a href="#5-1-搭建私有镜像仓库" class="headerlink" title="5.1.搭建私有镜像仓库"></a>5.1.搭建私有镜像仓库</h2><p>参考课前资料《CentOS7安装Docker.md》</p><h2 id="5-2-推送、拉取镜像"><a href="#5-2-推送、拉取镜像" class="headerlink" title="5.2.推送、拉取镜像"></a>5.2.推送、拉取镜像</h2><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p><p>① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080&#x2F;</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure><p>② 推送镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker push 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure><p>③ 拉取镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringMvc</title>
    <link href="/2023/02/22/JavaWeb/"/>
    <url>/2023/02/22/JavaWeb/</url>
    
    <content type="html"><![CDATA[<h2 id="Seesion和Cookie"><a href="#Seesion和Cookie" class="headerlink" title="Seesion和Cookie"></a>Seesion和Cookie</h2><ul><li>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li><li>有效期不同，Cookie  可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li><li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li><li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li><li>session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到。Cookie有个setPath的方法，可以设置可访问的路径，那么同一个网站中不同路径下的cookie互相是访问不到的</li></ul><h2 id="什么是-Cookie："><a href="#什么是-Cookie：" class="headerlink" title="什么是 Cookie："></a>什么是 Cookie：</h2><p>Cookie是服务器发送到客户端并保存在本地的一小块数据，它会在客户端下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。cookie中的数据以{key：value}的形式存在。</p><h3 id="cookie机制原理："><a href="#cookie机制原理：" class="headerlink" title="cookie机制原理："></a>cookie机制原理：</h3><p>比如服务端要想记录用户的状态，就使用response向浏览器发送一个Cookie。客户端浏览器会将这个cookie保存起来。浏览器再次请求服务端时，浏览器会把这个cookie带上。服务端检查这个cookie来获取用户状态。</p><h3 id="Cookie常用属性："><a href="#Cookie常用属性：" class="headerlink" title="Cookie常用属性："></a>Cookie常用属性：</h3><ul><li>name cookie的名字，Cookie一旦创建，名称便不可更改</li><li>value cookie的值</li><li>domain 可以访问该cookie的域名。如果设置为“.baidu.com”，则所有以“baidu.com”结尾的域名都可以访问该Cookie；第一个字符必须为“.”</li><li>maxAge Cookie失效的时间，单位秒。 正数，则超过maxAge秒之后失效。 负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。 为0，表示删除该Cookie。</li><li>isHttpOnly HttpOnly属性是用来限制非HTTP协议程序接口对客户端Cookie进行访问，将取Cookie的操作放到服务端，这样能有效的防止XSS攻击。</li></ul><h3 id="创建Cookie："><a href="#创建Cookie：" class="headerlink" title="创建Cookie："></a>创建Cookie：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;cookieSessionId&quot;</span>,<span class="hljs-string">&quot;qwertyuiop&quot;</span>); <span class="hljs-comment">//构造函数</span><br>cookie.setDomain(<span class="hljs-string">&quot;.baidu.com&quot;</span>);             <span class="hljs-comment">// 设置域名</span><br>cookie.setPath(<span class="hljs-string">&quot;/&quot;</span>);                        <span class="hljs-comment">// 设置路径</span><br>cookie.setMaxAge(Integer.MAX_VALUE);        <span class="hljs-comment">// 设置有效期为永久</span><br>response.addCookie(cookie);                 <span class="hljs-comment">// 回写到客户端</span><br></code></pre></td></tr></table></figure><h3 id="Cookie更新与删除："><a href="#Cookie更新与删除：" class="headerlink" title="Cookie更新与删除："></a>Cookie更新与删除：</h3><p>Cookie本身并没有提供修改和删除的方法，一般通过使用相同name的Cookie来覆盖原来的Cookie,以达到更新或删除的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;cookieSessionId&quot;</span>,<span class="hljs-string">&quot;new-qwertyuiop&quot;</span>);<br>response.addCookie(cookie);<br><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;cookieSessionId&quot;</span>,<span class="hljs-string">&quot;new-qwertyuiop&quot;</span>);<br>cookie.setMaxAge(<span class="hljs-number">0</span>);<span class="hljs-comment">//设置一个立即失效的cookie覆盖原cookie</span><br>response.addCookie(cookie);<br></code></pre></td></tr></table></figure><h3 id="如何获取与发送cookie"><a href="#如何获取与发送cookie" class="headerlink" title="如何获取与发送cookie"></a>如何获取与发送cookie</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//服务端从客户端取得cookie</span><br>Cookie[] cookies = request.getCookies();<br><br><span class="hljs-comment">//服务端向客户端发送cookie</span><br>response.addCookie(cookie);   <br></code></pre></td></tr></table></figure><p>对于Cookie来说，Cookie的同源只关注域名，是忽略协议和端口的。所以一般情况下，<a href="https://localhost:80和http://localhost:8080的Cookie是共享的。单个">https://localhost:80和http://localhost:8080的Cookie是共享的。单个</a> Cookie 保存的数据不能超过 4K。</p><h3 id="cookie的优缺点："><a href="#cookie的优缺点：" class="headerlink" title="cookie的优缺点："></a>cookie的优缺点：</h3><ul><li>优点： 适合用于存放需要每个请求都必须携带的数据 服务端也可以直接操作 Cookie 可以通过 domain 以及 path 控制数据存储的范围</li><li>缺点： 容量有限，规范只要求每个域名下最低提供 4kb 的存储空间 每次请求都会携带，如果存放了大量不必要的数据很显然会影响页面性能 不安全，永远不要在 Cookie 中存放用户的敏感数据 前端 API 不友好，CRUD 都是通过 document.cookie 进行，没有提供相关操作的方法</li></ul><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><blockquote><p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p></blockquote><h3 id="session机制原理："><a href="#session机制原理：" class="headerlink" title="session机制原理："></a>session机制原理：</h3><p>当客户端请求创建一个session时，服务端会先检查客户端的请求里面有没有带着session标识-sessionId。如果有，则说明服务器以前已为此客户端创建过session，于是就根据这个sessionId把session检索出来。如果客户端请求中不包含sessionId，则为客户端创建一个session并且生成一个与这个session相关联的sessionId。 这个sessionId将被在本次响应中返回给客户端保存。保存sessionId的方式大多情况下用的是cookie。</p><h3 id="创建session"><a href="#创建session" class="headerlink" title="创建session"></a>创建session</h3><p>HttpSession session &#x3D; request.getSession();</p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h3 id="当接收一个请求时，springMvc的处理流程"><a href="#当接收一个请求时，springMvc的处理流程" class="headerlink" title="当接收一个请求时，springMvc的处理流程"></a>当接收一个请求时，springMvc的处理流程</h3><p><img src="/../web_pic/1.png"></p><h3 id="拦截器概念"><a href="#拦截器概念" class="headerlink" title="拦截器概念"></a>拦截器概念</h3><p><img src="/../web_pic/2.png"></p><h3 id="拦截器与过滤器的区别"><a href="#拦截器与过滤器的区别" class="headerlink" title="拦截器与过滤器的区别"></a>拦截器与过滤器的区别</h3><p><img src="/../web_pic/3.png"></p><h2 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h2><p>MVC是一种软件架构的思想，将软件按照模型，视图，控制器来划分</p><p>M：Model,模型层，指工程中的JavaBean,作用是处理数据</p><p>JavaBean分为两类：</p><ul><li>一类称为实体类Bean:专门存储业务数据的，如Student,User等</li><li>一类称为业务处理Bean：指Service或Dao，专门用于处理业务逻辑和数据访问。</li></ul><p>V：View,视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</p><p>C：Controller,控制层，指工程中的Servlet,作用是接收请求和响应浏览器</p><p>MVC的工作流程：</p><p>用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller,Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Juc</title>
    <link href="/2023/02/22/Juc/"/>
    <url>/2023/02/22/Juc/</url>
    
    <content type="html"><![CDATA[<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>一、<strong>简介</strong><br>volatile是Java提供的一种轻量级的同步机制。Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized（synchronized通常称为重量级锁），volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。</p><p>二、<strong>并发编程的3个基本概念</strong><br>1.<strong>原子性</strong><br>     定义： 即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><pre><code class="hljs">原子性是拒绝多线程操作的，不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。简而言之，在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。例如 a=1是原子性操作，但是a++和a +=1就不是原子性操作。Java中的原子性操作包括：</code></pre><p>（1）基本类型的读取和赋值操作，且赋值必须是值赋给变量，变量之间的相互赋值不是原子性操作。</p><p>（2）所有引用reference的赋值操作</p><p>（3）java.concurrent.Atomic.* 包中所有类的一切操作</p><p>2.<strong>可见性</strong><br>   定义：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p>   在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。Java提供了volatile来保证可见性，当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，其他线程读取共享变量时，会直接从主内存中读取。当然，synchronize和Lock都可以保证可见性。synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><p>3.<strong>有序性</strong><br>   定义：即程序执行的顺序按照代码的先后顺序执行。</p><p>   Java内存模型中的有序性可以总结为：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。</p><p>   在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序不会影响单线程的运行结果，但是对多线程会有影响。Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）。另外，可以通过synchronized和Lock来保证有序性，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p><p>三、<strong>锁的互斥和可见性</strong><br>   锁提供了两种主要特性：互斥（mutual exclusion） 和可见性（visibility）。</p><p>（1）互斥即一次只允许一个线程持有某个特定的锁，一次就只有一个线程能够使用该共享数据。</p><p>（2）可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。也即当一条线程修改了共享变量的值，新值对于其他线程来说是可以立即得知的。如果没有同步机制提供的这种可见性保证，线程看到的共享变  量可能是修改前的值或不一致的值，这将引发许多严重问题。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：</p><pre><code class="hljs">a.对变量的写操作不依赖于当前值。b.该变量没有包含在具有其他变量的不变式中。</code></pre><p>  实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。事实上就是保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p><p>四、<strong>Java的内存模型JMM以及共享变量的可见性</strong><br> JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。</p><p><img src="/../JUC_pic/JUC.png" alt="juc"></p><p>   对于普通的共享变量来讲，线程A将其修改为某个值发生在线程A的本地内存中，此时还未同步到主内存中去；而线程B已经缓存了该变量的旧值，所以就导致了共享变量值的不一致。解决这种共享变量在多线程模型中的不可见性问题，较粗暴的方式自然就是加锁，但是此处使用synchronized或者Lock这些方式太重量级了，比较合理的方式其实就是volatile。</p><p>  需要注意的是，JMM是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应cpu缓存和物理内存</p><p>五、<strong>volatile变量的特性</strong><br> 1.保证可见性，不保证原子性<br>  （1）当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去；</p><p>  （2）这个写会操作会导致其他线程中的volatile变量缓存无效。</p><p> 2.禁止指令重排<br>    重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：</p><p> （1）重排序操作不会对存在数据依赖关系的操作进行重排序。</p><p>　 比如：a&#x3D;1;b&#x3D;a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。</p><p> （2）重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变</p><p>　 比如：a&#x3D;1;b&#x3D;2;c&#x3D;a+b这三个操作，第一步（a&#x3D;1)和第二步(b&#x3D;2)由于不存在数据依赖关系， 所以可能会发生重排序，但是c&#x3D;a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c&#x3D;a+b&#x3D;3。</p><pre><code class="hljs">重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果，下例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行status=true再执行a=2。而此时线程B会顺利到达4处，而线程A中a=2这个操作还未被执行，所以b=a+1的结果也有可能依然等于2。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestVolatile</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//状态切换为true</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> changeStatus&#123;<br>        a = <span class="hljs-number">2</span>;   <span class="hljs-comment">//1</span><br>        status = <span class="hljs-literal">true</span>;  <span class="hljs-comment">//2</span><br>                            &#125;<span class="hljs-comment">//若状态为true，则为running</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(status)&#123;   <span class="hljs-comment">//3</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a + <span class="hljs-number">1</span>;  <span class="hljs-comment">//4</span><br>        System.out.println(b);<br>        &#125;<br>                     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​     使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序,volatile禁止指令重排序也有一些规则：</p><pre><code class="hljs"> a.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； b.在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见。</code></pre><p>六、<strong>volatile不适用的场景</strong><br> 1.volatile不适合复合操作<br>  例如，int++不是一个原子性操作，可以由读取、加、赋值3步组成，所以结果并不能达到30000。.</p><p><img src="/../JUC_pic/juc1.png"></p><p>  2.解决方法<br> （1）采用synchronized</p><p><img src="/../JUC_pic/juc2.png"></p><p> （2）采用Lock</p><p><img src="/../JUC_pic/juc3.png"></p><p> （3）采用java并发包中的原子操作类，原子操作类是通过CAS循环的方式来保证其原子性的</p><p><img src="/../JUC_pic/juc3.png"></p><p>七、<strong>volatile原理</strong><br>  volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p><p>（1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p><p>（2）它会强制将对缓存的修改操作立即写入主存；</p><p>（3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p><p>八、<strong>单例模式的双重锁为什么要加volatile</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestInstance</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> TestInstance instance;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestInstance <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span>(TestInstance.class)&#123; <br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestInstance</span>();<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>   需要volatile关键字的原因是，在并发情况下，如果没有volatile关键字，在第5行会出现问题。instance &#x3D; new TestInstance();可以分解为3行伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">a. memory = allocate() <span class="hljs-comment">//分配内存</span><br>b. ctorInstanc(memory) <span class="hljs-comment">//初始化对象</span><br>c. instance = memory <span class="hljs-comment">//设置instance指向刚分配的地址 </span><br></code></pre></td></tr></table></figure><p>   上面的代码在编译运行时，可能会出现重排序从a-b-c排序为a-c-b。在多线程的情况下会出现以下问题。当线程A在执行第5行代码时，B线程进来执行到第2行代码。假设此时A执行的过程中发生了指令重排序，即先执行了a和c，没有执行b。那么由于A线程执行了c导致instance指向了一段地址，所以B线程判断instance不为null，会直接跳到第6行并返回一个未初始化的对象。</p><h2 id="创建多线程的几种方式"><a href="#创建多线程的几种方式" class="headerlink" title="创建多线程的几种方式"></a>创建多线程的几种方式</h2><h3 id="继承Thread类创建线程"><a href="#继承Thread类创建线程" class="headerlink" title="继承Thread类创建线程"></a>继承Thread类创建线程</h3><p><strong>通过继承Thread</strong>类来创建并启动多线程的一般步骤如下：</p><p>1】定义Tread类的子类MyThread，并重写run()方法.run()方法的方法体（线程执行体）就是线程要执行的任务。</p><p>2】创建My<a href="https://so.csdn.net/so/search?q=Thread%E7%B1%BB&spm=1001.2101.3001.7020">Thread类</a>的实例</p><p>3】调用子类实例的start()方法来启动线程</p><p>创建Thread1类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;a&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建Thread2类</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    public void run() &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;b&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在主方法中：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        Thread t1 =<span class="hljs-keyword">new</span> <span class="hljs-type">Thread1</span>();<br>        Thread t2 =<span class="hljs-keyword">new</span> <span class="hljs-type">Thread2</span>();<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现-Runnable接口创建线程"><a href="#实现-Runnable接口创建线程" class="headerlink" title="实现 Runnable接口创建线程"></a><strong>实现 Runnable接口创建线程</strong></h3><p>通过实现Runnable接口创建并启动线程的一般步骤如下：</p><p>1】定义Runnable接口的实现类，必须重写run(）方法，这个run()方法和Thread中的run()方法一样，是线程的执行体</p><p>2】创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象</p><p>3】调用start()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;: &quot;</span>+i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">RunnableTest</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableTest</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r,<span class="hljs-string">&quot;线程1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r,<span class="hljs-string">&quot;线程2&quot;</span>);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">线程2: 0</span><br><span class="hljs-section">线程2: 1</span><br><span class="hljs-section">线程1: 0</span><br><span class="hljs-section">线程2: 2</span><br><span class="hljs-section">线程1: 1</span><br><span class="hljs-section">线程2: 3</span><br><span class="hljs-section">线程1: 2</span><br><span class="hljs-section">线程2: 4</span><br><span class="hljs-section">线程1: 3</span><br><span class="hljs-section">线程1: 4</span><br></code></pre></td></tr></table></figure><h3 id="继承Thread和实现Runnable接口的区别"><a href="#继承Thread和实现Runnable接口的区别" class="headerlink" title="继承Thread和实现Runnable接口的区别"></a>继承Thread和实现Runnable接口的区别</h3><ul><li>实现Runnable接口避免单继承局限</li><li>当子类实现Runnable接口，此时子类</li></ul><h3 id="线程池创建"><a href="#线程池创建" class="headerlink" title="线程池创建"></a>线程池创建</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">来自项目中的代码<br><span class="hljs-comment">//定义一个线程池</span><br>    <span class="hljs-keyword">private</span> static final ExecutorService CACHE_REBUILD_EXECUTOR =      <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">FixedThreadPool(10)</span>;<br>  .<br>  .<br>  .<br>  .<br>  <span class="hljs-comment">//6.3获取锁成功 ，开启独立线程进行缓存重建</span><br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CACHE_REBUILD_EXECUTOR</span>.</span></span>submit(<span class="hljs-literal">()</span>-&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//查询数据库</span><br>                    R r1 = dbFallback.apply(id);<br>                    <span class="hljs-comment">//写入redis</span><br>                    this.set<span class="hljs-constructor">WithLogicExpire(<span class="hljs-params">key</span>,<span class="hljs-params">r1</span>,<span class="hljs-params">time</span>,<span class="hljs-params">unit</span>)</span>;<br>                &#125; catch (Exception e) &#123;<br>                    throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">RuntimeException(<span class="hljs-params">e</span>)</span>;<br>                &#125;finally &#123;<br>                    <span class="hljs-comment">//释放🔒</span><br>                    unlock(lockKey);<br>                &#125;<br>            &#125;);<br>    <br>  <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Jvm</title>
    <link href="/2023/02/22/Jvm/"/>
    <url>/2023/02/22/Jvm/</url>
    
    <content type="html"><![CDATA[<p>一、JVM 内存区域<br>Java虚拟机在运行时，会把内存空间分为若干个区域，根据《Java虚拟机规范（Java SE 7 版）》的规定，Java虚拟机所管理的内存区域分为如下部分：<em><strong>方法区、堆内存、虚拟机栈、本地方法栈、程序计数器</strong></em>。</p><p><img src="/../Jvm_pic/1.png" alt="Jvm"></p><p>参考：<a href="https://cloud.tencent.com/developer/article/1698363">内存篇：JVM内存结构 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p>1、<em><strong>方法区</strong></em></p><p>方法区主要用于存储虚拟机加载的<em><strong>类信息、常量、静态变量，以及编译器编译后的代码</strong></em>等数据。在<em><strong>jdk1.7</strong></em>及<em><strong>其之前</strong></em>，方法区是堆的一个“<em><strong>逻辑部分</strong></em>”（一片连续的堆空间），但为了与堆做区分，方法区还有个名字叫“非堆”，也有人用“永久代”（<em><strong>HotSpot</strong></em>对方法区的实现方法）来表示方法区。（<em><strong>永久代&#x3D;&#x3D;方法区</strong></em>）</p><p>从<em><strong>jdk1.7</strong></em>已经开始准备“去永久代”的规划，jdk1.7的HotSpot中，已经把原本放在方法区中的<em><strong>静态变量</strong></em>、<em><strong>字符串常量池</strong></em>等<em><strong>移到堆内存</strong></em>中，（常量池除字符串常量池还有class常量池等），这里只是把字符串常量池移到堆内存中；在<em><strong>jdk1.8</strong></em>中，方法区已经不存在，原方法区中存储的类信息、编译后的代码数据等已经移动到了<em><strong>元空间</strong></em>（MetaSpace）中，<em><strong>元空间并没有处于堆内存上</strong></em>，而是直接占用的<em><strong>本地内存</strong></em>（NativeMemory）。根据网上的资料结合自己的理解对jdk1.3~1.6、jdk1.7、jdk1.8中方法区的变迁画了张图如下（如有不合理的地方希望读者指出）：</p><p><img src="/../Jvm_pic/Jvm%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81.png"></p><p>去永久代的原因有：</p><p>（1）字符串存在永久代中，容易出现性能问题和内存溢出。</p><p>（2）类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</p><p>（3）永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p><p>2、<em><strong>堆内存</strong></em></p><p>堆内存主要用于存放<strong>对象和数组</strong>，它是JVM管理的内存中最大的一块区域，<strong>堆内存和方法区都被所有线程共享</strong>，在虚拟机启动时创建。在垃圾收集的层面上来看，由于现在收集器基本上都采用分代收集算法，因此堆还可以分为<strong>新生代（YoungGeneration）和老年代（OldGeneration）</strong>，<strong>新生代还可以分为 Eden、From Survivor、To Survivor</strong>。</p><p>堆具有以下特点：</p><ul><li>堆内存最大</li><li>堆是被线程共享，</li><li>堆的目的就是存放对象，几乎所有的对象实例都在此分配。当然，随着优化技术的更新，某些数据也会被放在栈上等。</li></ul><p>因为堆占用内存空间最大，堆也是Java垃圾回收的主要区域（重点对象），因此也称作“GC堆”（Garbage Collected Heap）</p><p><img src="/../Jvm_pic/2.png"></p><p> 同样，对上图呈现内容汇总分析：</p><ul><li>堆的GC操作采用分代收集算法。</li><li>堆区分了新生代和老年代。</li><li>新生代又分为：Eden空间、From Survivor（S0）空间、To Survivor（S1）空间。</li></ul><p>Java虚拟机规范规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。也就是说堆的内存是一块块拼凑起来的。要增加堆空间时，往上“拼凑”（可扩展性）即可，但当堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><p>3、<em><strong>程序计数器</strong></em></p><p>程序计数器是一块非常小的内存空间，可以看做是当前线程执行字节码的行号指示器，<strong>每个线程都有一个独立的程序计数器，因此程序计数器是线程私有的一块空间</strong>，此外，<strong>程序计数器是Java虚拟机规定的唯一不会发生内存溢出的区域</strong>。</p><p>4、<em><strong>虚拟机栈</strong></em></p><p><strong>虚拟机栈也是每个线程私有的一块内存空间</strong>，它描述的是方法的内存模型，直接看下图所示：</p><p><img src="/../Jvm_pic/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png"></p><p>虚拟机会为<strong>每个线程</strong>分配一个虚拟机栈，每个虚拟机栈中都有若干个栈帧，每个栈帧中<strong>存储了局部变量表、操作数栈、动态链接、返回地址等</strong>。一个栈帧就对应 Java 代码中的一个方法，当线程执行到一个方法时，就代表这个方法对应的栈帧已经进入虚拟机栈并且处于栈顶的位置，每一个 Java 方法从被调用到执行结束，就对应了一个栈帧从入栈到出栈的过程。</p><ul><li>局部变量表(Local Variable Table)是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。包括8种基本数据类型（int、short、byte、char、double、float、long、boolean）、对象引用（reference类型）和returnAddress类型（指向一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<strong>StackOverflowError</strong>异常；如果虚拟机栈动态扩展时无法申请到足够的内存时会抛出<strong>OutOfMemoryError</strong>异常。</li><li>操作数栈(Operand Stack)也称作操作栈，是一个后入先出栈(LIFO)。随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈&#x2F;入栈操作。</li><li>动态链接：Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态链接(Dynamic Linking)。</li><li>方法返回：无论方法是否正常完成，都需要返回到方法被调用的位置，程序才能继续进行。</li></ul><p>5、<em><strong>本地方法栈</strong></em></p><p>本地方法栈与虚拟机栈的区别是，虚拟机栈执行的是 Java 方法，本地方法栈执行的是本地方法（Native Method）,其他基本上一致，在 HotSpot 中直接把本地方法栈和虚拟机栈合二为一，这里暂时不做过多叙述。</p><p>6、<em><strong>元空间</strong></em></p><p>上面说到，jdk1.8 中，已经不存在永久代（方法区），替代它的一块空间叫做 “ 元空间 ”，和永久代类似，都是 JVM 规范对方法区的实现，但是<strong>元空间并不在虚拟机中，而是使用本地内存</strong>，元空间的大小仅受本地内存限制，但可以通过 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 来指定元空间的大小。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式1</title>
    <link href="/2023/02/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/"/>
    <url>/2023/02/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/</url>
    
    <content type="html"><![CDATA[<h1 id="1，设计模式概述"><a href="#1，设计模式概述" class="headerlink" title="1，设计模式概述"></a>1，设计模式概述</h1><h2 id="1-1-软件设计模式的产生背景"><a href="#1-1-软件设计模式的产生背景" class="headerlink" title="1.1 软件设计模式的产生背景"></a>1.1 软件设计模式的产生背景</h2><p>“设计模式”最初并不是出现在软件设计中，而是被用于建筑领域的设计中。</p><p>1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任<code>克里斯托夫·亚历山大（Christopher Alexander）</code>在他的著作《建筑模式语言：城镇、建筑、构造》中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。</p><p>1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）著称。  </p><h2 id="1-2-软件设计模式的概念"><a href="#1-2-软件设计模式的概念" class="headerlink" title="1.2 软件设计模式的概念"></a>1.2 软件设计模式的概念</h2><p>软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。</p><h2 id="1-3-学习设计模式的必要性"><a href="#1-3-学习设计模式的必要性" class="headerlink" title="1.3 学习设计模式的必要性"></a>1.3 学习设计模式的必要性</h2><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。</p><p>正确使用设计模式具有以下优点。</p><ul><li>可以提高程序员的思维能力、编程能力和设计能力。</li><li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li></ul><h2 id="1-4-设计模式分类"><a href="#1-4-设计模式分类" class="headerlink" title="1.4 设计模式分类"></a>1.4 设计模式分类</h2><ul><li><p><strong>创建型模式</strong></p><p>用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</p></li><li><p><strong>结构型模式</strong></p><p>用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</p></li><li><p><strong>行为型模式</strong></p><p>用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</p></li></ul><h1 id="2，UML图"><a href="#2，UML图" class="headerlink" title="2，UML图"></a>2，UML图</h1><p>统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</p><p>UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。</p><h2 id="2-1-类图概述"><a href="#2-1-类图概述" class="headerlink" title="2.1 类图概述"></a>2.1 类图概述</h2><p>类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。</p><h2 id="2-2-类图的作用"><a href="#2-2-类图的作用" class="headerlink" title="2.2 类图的作用"></a>2.2 类图的作用</h2><ul><li>在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解；</li><li>类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。</li></ul><h2 id="2-3-类图表示法"><a href="#2-3-类图表示法" class="headerlink" title="2.3 类图表示法"></a>2.3 类图表示法</h2><h3 id="2-3-1-类的表示方式"><a href="#2-3-1-类的表示方式" class="headerlink" title="2.3.1 类的表示方式"></a>2.3.1 类的表示方式</h3><p>在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。 </p><p><img src="/../img/Employee.jpg" alt="img"></p><p>属性&#x2F;方法名称前加的加号和减号表示了这个属性&#x2F;方法的可见性，UML类图中表示可见性的符号有三种：</p><ul><li><p>+：表示public</p></li><li><p>-：表示private</p></li><li><p>#：表示protected</p></li></ul><p>属性的完整表示方式是： <strong>可见性  名称 ：类型 [ &#x3D; 缺省值]</strong>  </p><p>方法的完整表示方式是： <strong>可见性  名称(参数列表) [ ： 返回类型]</strong></p><blockquote><p>注意：</p><p>​1，中括号中的内容表示是可选的</p><p>​2，也有将类型放在变量名前面，返回值类型放在方法名前面</p></blockquote><p><strong>举个栗子：</strong></p><p><img src="/../img/demo.png" alt="img"></p><p>上图Demo类定义了三个方法：</p><ul><li>method()方法：修饰符为public，没有参数，没有返回值。</li><li>method1()方法：修饰符为private，没有参数，返回值类型为String。</li><li>method2()方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为String，返回值类型是int。</li></ul><h3 id="2-3-2-类与类之间关系的表示方式"><a href="#2-3-2-类与类之间关系的表示方式" class="headerlink" title="2.3.2 类与类之间关系的表示方式"></a>2.3.2 类与类之间关系的表示方式</h3><h4 id="2-3-2-1-关联关系"><a href="#2-3-2-1-关联关系" class="headerlink" title="2.3.2.1 关联关系"></a>2.3.2.1 关联关系</h4><p>关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。</p><p>关联又可以分为单向关联，双向关联，自关联。</p><p><strong>1，单向关联</strong></p><p><img src="/../img/customer_address.png" alt="img"></p><p>在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。</p><p><strong>2，双向关联</strong></p><p><img src="/img/customer_product.png" alt="img"></p><p>从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。</p><p>在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List&lt;Product&gt;，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。</p><p><strong>3，自关联</strong></p><p><img src="/../img/node.png" alt="img"></p><p>自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。</p><h4 id="2-3-2-2-聚合关系"><a href="#2-3-2-2-聚合关系" class="headerlink" title="2.3.2.2 聚合关系"></a>2.3.2.2 聚合关系</h4><p>聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。</p><p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p><p>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：</p><p><img src="/../img/image-20191229173422328.png" alt="img"></p><h4 id="2-3-2-3-组合关系"><a href="#2-3-2-3-组合关系" class="headerlink" title="2.3.2.3 组合关系"></a>2.3.2.3 组合关系</h4><p>组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。</p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p><p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：</p><p><img src="/../img/image-20191229173455149.png" alt="img"></p><h4 id="2-3-2-4-依赖关系"><a href="#2-3-2-4-依赖关系" class="headerlink" title="2.3.2.4 依赖关系"></a>2.3.2.4 依赖关系</h4><p>依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p><p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：</p><p><img src="/../img/image-20191229173518926.png" alt="img"></p><h4 id="2-3-2-5-继承关系"><a href="#2-3-2-5-继承关系" class="headerlink" title="2.3.2.5 继承关系"></a>2.3.2.5 继承关系</h4><p>继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。</p><p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示：</p><p><img src="/../img/image-20191229173539838.png" alt="img"></p><h4 id="2-3-2-6-实现关系"><a href="#2-3-2-6-实现关系" class="headerlink" title="2.3.2.6 实现关系"></a>2.3.2.6 实现关系</h4><p>实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p><p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。</p><p><img src="/../img/image-20191229173554296.png" alt="img"></p><h1 id="3，软件设计原则"><a href="#3，软件设计原则" class="headerlink" title="3，软件设计原则"></a>3，软件设计原则</h1><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p><h2 id="3-1-开闭原则"><a href="#3-1-开闭原则" class="headerlink" title="3.1 开闭原则"></a>3.1 开闭原则</h2><p><strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p><p>想要达到这样的效果，我们需要使用接口和抽象类。</p><p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p><p>下面以 <code>搜狗输入法</code> 的皮肤为例介绍开闭原则的应用。</p><p>【例】<code>搜狗输入法</code> 的皮肤设计。</p><p>分析：<code>搜狗输入法</code> 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。</p><p><img src="/../img/open-close.png" alt="img"></p><h2 id="3-2-里氏代换原则"><a href="#3-2-里氏代换原则" class="headerlink" title="3.2 里氏代换原则"></a>3.2 里氏代换原则</h2><p>里氏代换原则是面向对象设计的基本原则之一。</p><p>里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p><p>下面看一个里氏替换原则中经典的一个例子</p><p>【例】正方形不是长方形。</p><p>在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。</p><p><img src="/../img/%E6%AD%A3%E6%96%B9%E5%BD%A2%E4%B8%8D%E6%98%AF%E9%95%BF%E6%96%B9%E5%BD%A2.png" alt="img"></p><p>代码如下：</p><p><strong>长方形类（Rectangle）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> length;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> width;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getLength</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLength</span><span class="hljs-params">(<span class="hljs-type">double</span> length)</span> &#123;<br>        <span class="hljs-built_in">this</span>.length = length;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getWidth</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> width;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWidth</span><span class="hljs-params">(<span class="hljs-type">double</span> width)</span> &#123;<br>        <span class="hljs-built_in">this</span>.width = width;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>正方形（Square）：</strong></p><p>由于正方形的长和宽相同，所以在方法setLength和setWidth中，对长度和宽度都需要赋相同值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWidth</span><span class="hljs-params">(<span class="hljs-type">double</span> width)</span> &#123;<br>        <span class="hljs-built_in">super</span>.setLength(width);<br>        <span class="hljs-built_in">super</span>.setWidth(width);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLength</span><span class="hljs-params">(<span class="hljs-type">double</span> length)</span> &#123;<br>        <span class="hljs-built_in">super</span>.setLength(length);<br>        <span class="hljs-built_in">super</span>.setWidth(length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类RectangleDemo是我们的软件系统中的一个组件，它有一个resize方法依赖基类Rectangle，resize方法是RectandleDemo类中的一个方法，用来实现宽度逐渐增长的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RectangleDemo</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(Rectangle rectangle)</span> &#123;<br>        <span class="hljs-keyword">while</span> (rectangle.getWidth() &lt;= rectangle.getLength()) &#123;<br>            rectangle.setWidth(rectangle.getWidth() + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//打印长方形的长和宽</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLengthAndWidth</span><span class="hljs-params">(Rectangle rectangle)</span> &#123;<br>        System.out.println(rectangle.getLength());<br>        System.out.println(rectangle.getWidth());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Rectangle</span> <span class="hljs-variable">rectangle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>();<br>        rectangle.setLength(<span class="hljs-number">20</span>);<br>        rectangle.setWidth(<span class="hljs-number">10</span>);<br>        resize(rectangle);<br>        printLengthAndWidth(rectangle);<br><br>        System.out.println(<span class="hljs-string">&quot;============&quot;</span>);<br><br>        <span class="hljs-type">Rectangle</span> <span class="hljs-variable">rectangle1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Square</span>();<br>        rectangle1.setLength(<span class="hljs-number">10</span>);<br>        resize(rectangle1);<br>        printLengthAndWidth(rectangle1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们运行一下这段代码就会发现，假如我们把一个普通长方形作为参数传入resize方法，就会看到长方形宽度逐渐增长的效果，当宽度大于长度,代码就会停止，这种行为的结果符合我们的预期；假如我们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度都在不断增长，代码会一直运行下去，直至系统产生溢出错误。所以，普通的长方形是适合这段代码的，正方形不适合。<br>我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。</p><p>如何改进呢？此时我们需要重新设计他们之间的关系。抽象出来一个四边形接口(Quadrilateral)，让Rectangle类和Square类实现Quadrilateral接口</p><p><img src="/../img/%E6%AD%A3%E6%96%B9%E5%BD%A2%E4%B8%8D%E6%98%AF%E9%95%BF%E6%96%B9%E5%BD%A2%E6%94%B9%E8%BF%9B.png" alt="img"></p><h2 id="3-3-依赖倒转原则"><a href="#3-3-依赖倒转原则" class="headerlink" title="3.3 依赖倒转原则"></a>3.3 依赖倒转原则</h2><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p><p>下面看一个例子来理解依赖倒转原则</p><p>【例】组装电脑</p><p>现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。</p><p><strong>类图如下：</strong></p><p><img src="/../img/%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99.png" alt="img"></p><p>代码如下：</p><p><strong>希捷硬盘类（XiJieHardDisk）:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XiJieHardDisk</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HardDisk</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(String data)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;使用希捷硬盘存储数据&quot;</span> + data);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;使用希捷希捷硬盘取数据&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;数据&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Intel处理器（IntelCpu）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelCpu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cpu</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;使用Intel处理器&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>金士顿内存条（KingstonMemory）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KingstonMemory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Memory</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;使用金士顿作为内存条&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>电脑（Computer）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> XiJieHardDisk hardDisk;<br>    <span class="hljs-keyword">private</span> IntelCpu cpu;<br>    <span class="hljs-keyword">private</span> KingstonMemory memory;<br><br>    <span class="hljs-keyword">public</span> IntelCpu <span class="hljs-title function_">getCpu</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cpu;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCpu</span><span class="hljs-params">(IntelCpu cpu)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cpu = cpu;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> KingstonMemory <span class="hljs-title function_">getMemory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> memory;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMemory</span><span class="hljs-params">(KingstonMemory memory)</span> &#123;<br>        <span class="hljs-built_in">this</span>.memory = memory;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> XiJieHardDisk <span class="hljs-title function_">getHardDisk</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> hardDisk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHardDisk</span><span class="hljs-params">(XiJieHardDisk hardDisk)</span> &#123;<br>        <span class="hljs-built_in">this</span>.hardDisk = hardDisk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;计算机工作&quot;</span>);<br>        cpu.run();<br>        memory.save();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> hardDisk.get();<br>        System.out.println(<span class="hljs-string">&quot;从硬盘中获取的数据为：&quot;</span> + data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试类（TestComputer）：</strong></p><p>测试类用来组装电脑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestComputer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Computer</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>();<br>        computer.setHardDisk(<span class="hljs-keyword">new</span> <span class="hljs-title class_">XiJieHardDisk</span>());<br>        computer.setCpu(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IntelCpu</span>());<br>        computer.setMemory(<span class="hljs-keyword">new</span> <span class="hljs-title class_">KingstonMemory</span>());<br><br>        computer.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码可以看到已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件。</p><p>根据依赖倒转原则进行改进：</p><p>代码我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类。</p><p><strong>类图如下：</strong></p><p><img src="/../img/%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99%E6%94%B9%E8%BF%9B.png" alt="img"></p><p><strong>电脑（Computer）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> HardDisk hardDisk;<br>    <span class="hljs-keyword">private</span> Cpu cpu;<br>    <span class="hljs-keyword">private</span> Memory memory;<br><br>    <span class="hljs-keyword">public</span> HardDisk <span class="hljs-title function_">getHardDisk</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> hardDisk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHardDisk</span><span class="hljs-params">(HardDisk hardDisk)</span> &#123;<br>        <span class="hljs-built_in">this</span>.hardDisk = hardDisk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Cpu <span class="hljs-title function_">getCpu</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cpu;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCpu</span><span class="hljs-params">(Cpu cpu)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cpu = cpu;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Memory <span class="hljs-title function_">getMemory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> memory;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMemory</span><span class="hljs-params">(Memory memory)</span> &#123;<br>        <span class="hljs-built_in">this</span>.memory = memory;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;计算机工作&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。</p><h2 id="3-4-接口隔离原则"><a href="#3-4-接口隔离原则" class="headerlink" title="3.4 接口隔离原则"></a>3.4 接口隔离原则</h2><p>客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。</p><p>下面看一个例子来理解接口隔离原则</p><p>【例】安全门案例</p><p>我们需要创建一个<code>黑马</code>品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下：</p><p><img src="/../img/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99.png" alt="img"></p><p>上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图：</p><p><img src="/../img/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%991.png" alt="img"></p><p>代码如下：</p><p><strong>AntiTheft（接口）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AntiTheft</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">antiTheft</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Fireproof（接口）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fireproof</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fireproof</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Waterproof（接口）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Waterproof</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">waterproof</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>HeiMaSafetyDoor（类）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeiMaSafetyDoor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AntiTheft</span>,Fireproof,Waterproof &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">antiTheft</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;防盗&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fireproof</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;防火&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waterproof</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;防水&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ItcastSafetyDoor（类）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItcastSafetyDoor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AntiTheft</span>,Fireproof &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">antiTheft</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;防盗&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fireproof</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;防火&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-5-迪米特法则"><a href="#3-5-迪米特法则" class="headerlink" title="3.5 迪米特法则"></a>3.5 迪米特法则</h2><p>迪米特法则又叫最少知识原则。</p><p>只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。</p><p>其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><p>下面看一个例子来理解迪米特法则</p><p>【例】明星与经纪人的关系实例</p><p>明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。</p><p>类图如下：</p><img src="../img/迪米特法则.png" alt="image-20191229173554296" style="zoom:80%;" /><p>代码如下：</p><p><strong>明星类（Star）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Star</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Star</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>粉丝类（Fans）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fans</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Fans</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>媒体公司类（Company）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Company</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Company</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>经纪人类（Agent）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Agent</span> &#123;<br>    <span class="hljs-keyword">private</span> Star star;<br>    <span class="hljs-keyword">private</span> Fans fans;<br>    <span class="hljs-keyword">private</span> Company company;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStar</span><span class="hljs-params">(Star star)</span> &#123;<br>        <span class="hljs-built_in">this</span>.star = star;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFans</span><span class="hljs-params">(Fans fans)</span> &#123;<br>        <span class="hljs-built_in">this</span>.fans = fans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCompany</span><span class="hljs-params">(Company company)</span> &#123;<br>        <span class="hljs-built_in">this</span>.company = company;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meeting</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(fans.getName() + <span class="hljs-string">&quot;与明星&quot;</span> + star.getName() + <span class="hljs-string">&quot;见面了。&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">business</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(company.getName() + <span class="hljs-string">&quot;与明星&quot;</span> + star.getName() + <span class="hljs-string">&quot;洽淡业务。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-6-合成复用原则"><a href="#3-6-合成复用原则" class="headerlink" title="3.6 合成复用原则"></a>3.6 合成复用原则</h2><p>合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p><p>通常类的复用分为继承复用和合成复用两种。</p><p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：</p><ol><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>对象间的耦合度低。可以在类的成员位置声明抽象。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ol><p>下面看一个例子来理解合成复用原则</p><p>【例】汽车分类管理程序</p><p>汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下： </p><img src="../img/合成复用原则.png" alt="image-20191229173554296" style="zoom:80%;" /><p>从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。</p><img src="../img/合成复用原则1.png" alt="image-20191229173554296" style="zoom:80%;" /><h1 id="4，创建者模式"><a href="#4，创建者模式" class="headerlink" title="4，创建者模式"></a>4，创建者模式</h1><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。</p><p>这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。</p><p>创建型模式分为：</p><ul><li>单例模式</li><li>工厂方法模式</li><li>抽象工程模式</li><li>原型模式</li><li>建造者模式</li></ul><h2 id="4-1-单例设计模式"><a href="#4-1-单例设计模式" class="headerlink" title="4.1 单例设计模式"></a>4.1 单例设计模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><h3 id="4-1-1-单例模式的结构"><a href="#4-1-1-单例模式的结构" class="headerlink" title="4.1.1 单例模式的结构"></a>4.1.1 单例模式的结构</h3><p>单例模式的主要有以下角色：</p><ul><li><strong>单例类</strong>。只能创建一个实例的类</li><li><strong>访问类</strong>。使用单例类</li></ul><h3 id="4-1-2-单例模式的实现"><a href="#4-1-2-单例模式的实现" class="headerlink" title="4.1.2 单例模式的实现"></a>4.1.2 单例模式的实现</h3><blockquote><p>单例设计模式分类两种：</p><p>​<strong>饿汉式</strong>：类加载就会导致该单实例对象被创建</p><p>​<strong>懒汉式</strong>：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p></blockquote><ol><li><p>饿汉式-方式1（静态变量方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 饿汉式</span><br><span class="hljs-comment"> *      静态变量创建类的对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。</p></li><li><p>饿汉式-方式2（静态代码块方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 恶汉式</span><br><span class="hljs-comment"> *      在静态代码块中创建该类对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。</p></li><li><p>懒汉式-方式1（线程不安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 懒汉式</span><br><span class="hljs-comment"> *  线程不安全</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。</p></li><li><p>懒汉式-方式2（线程安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 懒汉式</span><br><span class="hljs-comment"> *  线程安全</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。</p></li><li><p>懒汉式-方式3（双重检查锁）</p><p>再来讨论一下懒汉模式中加锁的问题，对于 <code>getInstance()</code> 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：<em><strong>双重检查锁模式</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双重检查方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123; <br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>   <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">//抢到锁之后再次判断是否为null</span><br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。</p><p>要解决双重检查锁模式带来空指针异常的问题，只需要使用 <code>volatile</code> 关键字, <code>volatile</code> 关键字可以保证可见性和有序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双重检查方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>   <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">//抢到锁之后再次判断是否为空</span><br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">小结：</font></p><p>添加 <code>volatile</code> 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。</p></li><li><p>懒汉式-方式4（静态内部类方式）</p><p>静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性&#x2F;方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 静态内部类方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder</p><p>并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。</p><p><font color="red">小结：</font></p><p>​静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p></li><li><p>枚举方式</p><p>枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 枚举方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​枚举方式属于恶汉式方式。</p></li></ol><h3 id="4-1-3-存在的问题"><a href="#4-1-3-存在的问题" class="headerlink" title="4.1.3 存在的问题"></a>4.1.3 存在的问题</h3><h4 id="4-1-3-1-问题演示"><a href="#4-1-3-1-问题演示" class="headerlink" title="4.1.3.1 问题演示"></a>4.1.3.1 问题演示</h4><p>破坏单例模式：</p><p>使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。</p><ul><li><p>序列化反序列化</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Test类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//往文件中写对象</span><br>        <span class="hljs-comment">//writeObject2File();</span><br>        <span class="hljs-comment">//从文件中读取对象</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> readObjectFromFile();<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> readObjectFromFile();<br><br>        <span class="hljs-comment">//判断两个反序列化后的对象是否是同一个对象</span><br>        System.out.println(s1 == s2);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">readObjectFromFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//创建对象输入流对象</span><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));<br>        <span class="hljs-comment">//第一个读取Singleton对象</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> (Singleton) ois.readObject();<br><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeObject2File</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//获取Singleton类的对象</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br>        <span class="hljs-comment">//创建对象输出流</span><br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));<br>        <span class="hljs-comment">//将instance对象写出到文件中</span><br>        oos.writeObject(instance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面代码运行结果是<code>false</code>，表明序列化和反序列化已经破坏了单例设计模式。</p></blockquote></li><li><p>反射</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> instance;<br>            &#125;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Test类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//获取Singleton类的字节码对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Singleton.class;<br>        <span class="hljs-comment">//获取Singleton类的私有无参构造方法对象</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor();<br>        <span class="hljs-comment">//取消访问检查</span><br>        constructor.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">//创建Singleton类的对象s1</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> (Singleton) constructor.newInstance();<br>        <span class="hljs-comment">//创建Singleton类的对象s2</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> (Singleton) constructor.newInstance();<br><br>        <span class="hljs-comment">//判断通过反射创建的两个Singleton对象是否是同一个对象</span><br>        System.out.println(s1 == s2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面代码运行结果是<code>false</code>，表明序列化和反序列化已经破坏了单例设计模式</p></blockquote></li></ul><blockquote><p><font color="red">注意：</font>枚举方式不会出现这两个问题。</p></blockquote><h4 id="4-1-3-2-问题的解决"><a href="#4-1-3-2-问题的解决" class="headerlink" title="4.1.3.2 问题的解决"></a>4.1.3.2 问题的解决</h4><ul><li><p>序列化、反序列方式破坏单例模式的解决方法</p><p>在Singleton类中添加<code>readResolve()</code>方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 下面是为了解决序列化反序列化破解单例模式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>源码解析：</strong></p><p>ObjectInputStream类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">readObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException&#123;<br>    ...<br>    <span class="hljs-comment">// if nested read, passHandle contains handle of enclosing object</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">outerHandle</span> <span class="hljs-operator">=</span> passHandle;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> readObject0(<span class="hljs-literal">false</span>);<span class="hljs-comment">//重点查看readObject0方法</span><br>    .....<br>&#125;<br>    <br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readObject0</span><span class="hljs-params">(<span class="hljs-type">boolean</span> unshared)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>...<br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">switch</span> (tc) &#123;<br>...<br><span class="hljs-keyword">case</span> TC_OBJECT:<br><span class="hljs-keyword">return</span> checkResolve(readOrdinaryObject(unshared));<span class="hljs-comment">//重点查看readOrdinaryObject方法</span><br>...<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        depth--;<br>        bin.setBlockDataMode(oldMode);<br>    &#125;    <br>&#125;<br>    <br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readOrdinaryObject</span><span class="hljs-params">(<span class="hljs-type">boolean</span> unshared)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>...<br><span class="hljs-comment">//isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类，</span><br>    obj = desc.isInstantiable() ? desc.newInstance() : <span class="hljs-literal">null</span>; <br>    ...<br>    <span class="hljs-comment">// 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true</span><br>    <span class="hljs-keyword">if</span> (obj != <span class="hljs-literal">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="hljs-literal">null</span> &amp;&amp; desc.hasReadResolveMethod()) &#123;<br>    <span class="hljs-comment">// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量</span><br>    <span class="hljs-comment">// 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">rep</span> <span class="hljs-operator">=</span> desc.invokeReadResolve(obj);<br>     ...<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>反射方式破解单例的解决方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           反射破解单例模式需要添加的代码</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> instance;<br>            &#125;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">说明:</font></p><p>​这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操作。</p></li></ul><h3 id="4-1-4-JDK源码解析-Runtime类"><a href="#4-1-4-JDK源码解析-Runtime类" class="headerlink" title="4.1.4 JDK源码解析-Runtime类"></a>4.1.4 JDK源码解析-Runtime类</h3><p>Runtime类就是使用的单例设计模式。</p><ol><li><p>通过源代码查看使用的是哪儿种单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Runtime</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Runtime</span> <span class="hljs-variable">currentRuntime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runtime</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the runtime object associated with the current Java application.</span><br><span class="hljs-comment">     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance</span><br><span class="hljs-comment">     * methods and must be invoked with respect to the current runtime object.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</span><br><span class="hljs-comment">     *          Java application.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runtime <span class="hljs-title function_">getRuntime</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> currentRuntime;<br>    &#125;<br><br>    <span class="hljs-comment">/** Don&#x27;t let anyone else instantiate this class */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Runtime</span><span class="hljs-params">()</span> &#123;&#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面源代码中可以看出Runtime类使用的是恶汉式（静态属性）方式来实现单例模式的。</p></li><li><p>使用Runtime类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuntimeDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//获取Runtime类对象</span><br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br><br>        <span class="hljs-comment">//返回 Java 虚拟机中的内存总量。</span><br>        System.out.println(runtime.totalMemory());<br>        <span class="hljs-comment">//返回 Java 虚拟机试图使用的最大内存量。</span><br>        System.out.println(runtime.maxMemory());<br><br>        <span class="hljs-comment">//创建一个新的进程执行指定的字符串命令，返回进程对象</span><br>        <span class="hljs-type">Process</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> runtime.exec(<span class="hljs-string">&quot;ipconfig&quot;</span>);<br>        <span class="hljs-comment">//获取命令执行后的结果，通过输入流获取</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> process.getInputStream();<br>        <span class="hljs-type">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>* <span class="hljs-number">100</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> inputStream.read(arr);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(arr,<span class="hljs-number">0</span>,b,<span class="hljs-string">&quot;gbk&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
