<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CAS</title>
    <link href="/2023/06/12/CAS/"/>
    <url>/2023/06/12/CAS/</url>
    
    <content type="html"><![CDATA[<h2 id="CAS乐观锁"><a href="#CAS乐观锁" class="headerlink" title="CAS乐观锁"></a>CAS乐观锁</h2><p>CAS 全称为 <code>Compare And Swap</code> 翻译过来就是<code>比较并且交换</code></p><ul><li>Synchornized 是悲观锁，线程一旦得到锁，其他的线程就只能挂起了</li><li>CAS 的操作则是乐观锁，他认为自己一定会拿到锁，所以他会一直尝试，直到成功拿到为止；</li></ul><h2 id="CAS-机制"><a href="#CAS-机制" class="headerlink" title="CAS 机制"></a>CAS 机制</h2><p>在看到 Compare 和 Swap 后，我们就应该知道，CAS 里面至少包含了两个动作，分别是比较和交换，在现在的 CPU 中，为这两个动作专门提供了一个指令，就是<code>CAH</code> 指令，<strong>由 CPU 来保证</strong>这两个操作一定是原子的，也就是说比较和交换这两个操作只能是<code>要么全部完成，要么全部没有完成</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2023/05/30/Redis/"/>
    <url>/2023/05/30/Redis/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>单机的Redis存在四大问题：</p><p><img src="/../redis_pic/1.png"></p><p>Redis有两种持久化方案: </p><ul><li>RDB持久化</li><li>AOF持久化</li></ul><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p><h4 id="RDB执行时机"><a href="#RDB执行时机" class="headerlink" title="RDB执行时机"></a>RDB执行时机</h4><p>RDB持久化在四种情况下会执行：</p><ul><li>执行save命令</li><li>执行bgsave命令</li><li>Redis停机时(ctrl+C)</li><li>触发RDB条件时</li></ul><hr><p><strong>1）save命令</strong></p><p><strong>执行下面的命令，可以立即执行一次RDB：</strong></p><p><img src="/../redis_pic/2.png"></p><p>save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p><p><strong>2）bgsave命令</strong></p><p>下面的命令可以异步执行RDB：</p><p><img src="/../redis_pic/3.png"></p><p>这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p><p><strong>3）停机时</strong></p><p>Redis停机时会执行一次save命令，实现RDB持久化</p><p><strong>4）触发RDB条件</strong></p><p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save &quot;&quot; 则表示禁用RDB</span><br><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span>  <br><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span>  <br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><p>RDB的其它配置也可以在redis.conf文件中设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span><br>rdbcompression <span class="hljs-built_in">yes</span><br><br><span class="hljs-comment"># RDB文件名称</span><br>dbfilename dump.rdb  <br><br><span class="hljs-comment"># 文件保存的路径目录</span><br><span class="hljs-built_in">dir</span> ./ <br></code></pre></td></tr></table></figure><h4 id="RDB原理"><a href="#RDB原理" class="headerlink" title="RDB原理"></a>RDB原理</h4><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p><p>fork采用的是copy-on-write技术：</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><p><img src="/../redis_pic/4.png"></p><h4 id="RDB小结"><a href="#RDB小结" class="headerlink" title="RDB小结"></a>RDB小结</h4><p>RDB方式bgsave的基本流程？</p><ul><li>fork主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新的RDB文件</li><li>用新RDB文件替换旧的RDB文件</li></ul><p>RDB会在什么时候执行？save 60 1000代表什么含义？</p><ul><li>默认是服务停止时</li><li>代表60秒内至少执行1000次修改则触发RDB</li></ul><p>RDB的缺点？</p><ul><li><strong>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</strong></li><li>fork子进程、压缩、写出RDB文件都比较耗时</li></ul><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。(有点像MySQL里的redo log保证数据的持久化)。</p><p><img src="/../redis_pic/5.png"></p><h4 id="AOF配置"><a href="#AOF配置" class="headerlink" title="AOF配置"></a>AOF配置</h4><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 是否开启AOF功能，默认是no</span><br><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">yes</span><br><span class="hljs-comment"># AOF文件的名称</span><br>appendfilename <span class="hljs-string">&quot;appendonly.aof&quot;</span><br></code></pre></td></tr></table></figure><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 表示每执行一次写命令，立即记录到AOF文件</span><br><span class="hljs-attribute">appendfsync</span> always <br><span class="hljs-comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span><br>appendfsync everysec <br><span class="hljs-comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span><br>appendfsync <span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><p>三种策略对比：</p><p><img src="/../redis_pic/6.png"></p><h4 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h4><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><p><img src="/../redis_pic/7.png"></p><p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p><p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span><br><span class="hljs-attribute">auto</span>-aof-rewrite-percentage <span class="hljs-number">100</span><br><span class="hljs-comment"># AOF文件体积最小多大以上才触发重写 </span><br><span class="hljs-attribute">auto</span>-aof-rewrite-min-size <span class="hljs-number">64</span>mb <br></code></pre></td></tr></table></figure><h3 id="RDB与AOF对比"><a href="#RDB与AOF对比" class="headerlink" title="RDB与AOF对比"></a>RDB与AOF对比</h3><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p><p><img src="/../redis_pic/8.png"></p><h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>尽管 RDB 比 AOF 的数据恢复速度快，但是快照的频率不好把握：</p><ul><li>如果频率太低，两次快照间一旦服务器发生宕机，就可能会比较多的数据丢失；</li><li>如果频率太高，频繁写入磁盘和创建子进程会带来额外的性能开销。</li></ul><p>那有没有什么方法不仅有 RDB 恢复速度快的优点和，又有 AOF 丢失数据少的优点呢？</p><p>当然有，那就是将 RDB 和 AOF 合体使用，这个方法是在 Redis 4.0 提出的，该方法叫<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化。</p><p>如果想要开启混合持久化功能，可以在 Redis 配置文件将下面这个配置项设置成 yes：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">aof-<span class="hljs-keyword">use</span>-rdb-preamble yes<br></code></pre></td></tr></table></figure><p>混合持久化工作在 <strong>AOF 日志重写过程</strong>。</p><p>当开启了混合持久化时，在 AOF 重写日志时，<code>fork</code> 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p><p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p><p><img src="/../redis_pic/11.png"></p><p>这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。</p><p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p><h3 id="纯缓存模式"><a href="#纯缓存模式" class="headerlink" title="纯缓存模式"></a>纯缓存模式</h3><p>由于开启了持久化，会对redis性能造成一定影响</p><p>同时关闭RDB+AOF</p><p><strong>关闭RDB</strong>：修改触发条件 save “” (禁用RDB持久化模式下，我们仍然可以使用命令save、bgsave生成RDB文件)</p><p><strong>关闭AOF</strong>: 修改配置文件 appendonly no(禁用AOF持久化模式下，我们仍然可以使用bgrewriteaof生成AOF文件)</p><h2 id="分布式锁-redission"><a href="#分布式锁-redission" class="headerlink" title="分布式锁-redission"></a>分布式锁-redission</h2><h3 id="分布式锁-redission功能介绍"><a href="#分布式锁-redission功能介绍" class="headerlink" title="分布式锁-redission功能介绍"></a>分布式锁-redission功能介绍</h3><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><p><img src="/../redis_pic/9.png"></p><p>那么什么是Redission呢</p><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><p>Redission提供了分布式锁的多种多样的功能</p><p><img src="/../redis_pic/10.png"></p><h3 id="分布式锁-Redission快速入门"><a href="#分布式锁-Redission快速入门" class="headerlink" title="分布式锁-Redission快速入门"></a>分布式锁-Redission快速入门</h3><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置Redisson客户端：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino">@Configuration<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonConfig</span> &#123;<br><br>    @<span class="hljs-function">Bean</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title">redissonClient</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 配置</span><br>        Config config = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Config</span>();<br>        config.<span class="hljs-built_in">useSingleServer</span>().<span class="hljs-built_in">setAddress</span>(<span class="hljs-string">&quot;redis://192.168.150.101:6379&quot;</span>)<br>            .<span class="hljs-built_in">setPassword</span>(<span class="hljs-string">&quot;123321&quot;</span>);<br>        <span class="hljs-comment">// 创建RedissonClient对象</span><br>        <span class="hljs-keyword">return</span> Redisson.<span class="hljs-built_in">create</span>(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如何使用Redission的分布式锁</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp">@Resource<br><span class="hljs-keyword">private</span> RedissionClient redissonClient;<br><br>@Test<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testRedisson</span>() throws Exception</span>&#123;<br>    <span class="hljs-comment">//获取锁(可重入)，指定锁的名称</span><br>    RLock <span class="hljs-keyword">lock</span> = redissonClient.getLock(<span class="hljs-string">&quot;anyLock&quot;</span>);<br>    <span class="hljs-comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span><br>    boolean isLock = <span class="hljs-keyword">lock</span>.tryLock(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,TimeUnit.SECONDS);<br>    <span class="hljs-comment">//判断获取锁成功</span><br>    <span class="hljs-keyword">if</span>(isLock)&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;执行业务&quot;</span>);          <br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            <span class="hljs-comment">//释放锁</span><br>            <span class="hljs-keyword">lock</span>.unlock();<br>        &#125;  <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>在 VoucherOrderServiceImpl</p><p>注入RedissonClient</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Resource<br><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br>@Override<br>public Result seckill<span class="hljs-constructor">Voucher(Long <span class="hljs-params">voucherId</span>)</span> &#123;<br>        <span class="hljs-comment">// 1.查询优惠券</span><br>        SeckillVoucher voucher = seckillVoucherService.get<span class="hljs-constructor">ById(<span class="hljs-params">voucherId</span>)</span>;<br>        <span class="hljs-comment">// 2.判断秒杀是否开始</span><br>        <span class="hljs-keyword">if</span> (voucher.get<span class="hljs-constructor">BeginTime()</span>.is<span class="hljs-constructor">After(LocalDateTime.<span class="hljs-params">now</span>()</span>)) &#123;<br>            <span class="hljs-comment">// 尚未开始</span><br>            return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Result</span>.</span></span>fail(<span class="hljs-string">&quot;秒杀尚未开始！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 3.判断秒杀是否已经结束</span><br>        <span class="hljs-keyword">if</span> (voucher.get<span class="hljs-constructor">EndTime()</span>.is<span class="hljs-constructor">Before(LocalDateTime.<span class="hljs-params">now</span>()</span>)) &#123;<br>            <span class="hljs-comment">// 尚未开始</span><br>            return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Result</span>.</span></span>fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 4.判断库存是否充足</span><br>        <span class="hljs-keyword">if</span> (voucher.get<span class="hljs-constructor">Stock()</span> &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 库存不足</span><br>            return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Result</span>.</span></span>fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>        &#125;<br>        Long userId = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserHolder</span>.</span></span>get<span class="hljs-constructor">User()</span>.get<span class="hljs-constructor">Id()</span>;<br>        <span class="hljs-comment">//创建锁对象 这个代码不用了，因为我们现在要使用分布式锁</span><br>        <span class="hljs-comment">//SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span><br>        RLock lock = redissonClient.get<span class="hljs-constructor">Lock(<span class="hljs-string">&quot;lock:order:&quot;</span> + <span class="hljs-params">userId</span>)</span>;<br>        <span class="hljs-comment">//获取锁对象</span><br>        boolean isLock = lock.<span class="hljs-keyword">try</span><span class="hljs-constructor">Lock()</span>;<br>       <br><span class="hljs-comment">//加锁失败</span><br>        <span class="hljs-keyword">if</span> (!isLock) &#123;<br>            return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Result</span>.</span></span>fail(<span class="hljs-string">&quot;不允许重复下单&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取代理对象(事务)</span><br>            IVoucherOrderService proxy = (IVoucherOrderService) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AopContext</span>.</span></span>current<span class="hljs-constructor">Proxy()</span>;<br>            return proxy.create<span class="hljs-constructor">VoucherOrder(<span class="hljs-params">voucherId</span>)</span>;<br>        &#125; finally &#123;<br>            <span class="hljs-comment">//释放锁</span><br>            lock.unlock<span class="hljs-literal">()</span>;<br>        &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="Redission锁可重入原理"><a href="#Redission锁可重入原理" class="headerlink" title="Redission锁可重入原理"></a>Redission锁可重入原理</h3><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state&#x3D;0，假如有人持有这把锁，那么state&#x3D;1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。  </p><p>在redission中，我们的也支持支持可重入锁</p><p><img src="/../redis_pic/12.png"></p><h3 id="分布式锁-redission锁重试和WatchDog机制"><a href="#分布式锁-redission锁重试和WatchDog机制" class="headerlink" title="分布式锁-redission锁重试和WatchDog机制"></a>分布式锁-redission锁重试和WatchDog机制</h3><p><img src="/../redis_pic/13.png"></p><p>抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p><p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p><p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p><p>所以如果返回是null，则代表着当前这哥们已经抢锁完毕，或者可重入完毕，但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，同学们可以自行往下翻一点点，你能发现有个while( true) 再次进行tryAcquire进行抢锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">long threadId = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Id()</span>;<br>Long ttl = <span class="hljs-keyword">try</span><span class="hljs-constructor">Acquire(-1, <span class="hljs-params">leaseTime</span>, <span class="hljs-params">unit</span>, <span class="hljs-params">threadId</span>)</span>;<br><span class="hljs-comment">// lock acquired</span><br><span class="hljs-keyword">if</span> (ttl<span class="hljs-operator"> == </span>null) &#123;<br>    return;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来会有一个条件分支，因为lock方法有重载方法，一个是带参数，一个是不带参数，如果带带参数传入的值是-1，如果传入参数，则leaseTime是他本身，所以如果传入了参数，此时leaseTime !&#x3D; -1 则会进去抢锁，抢锁的逻辑就是之前说的那三个逻辑</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1</span>) &#123;<br>    return <span class="hljs-keyword">try</span><span class="hljs-constructor">LockInnerAsync(<span class="hljs-params">waitTime</span>, <span class="hljs-params">leaseTime</span>, <span class="hljs-params">unit</span>, <span class="hljs-params">threadId</span>, RedisCommands.EVAL_LONG)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是没有传入时间，则此时也会进行抢锁， 而且抢锁时间是默认看门狗时间 commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()</p><p>ttlRemainingFuture.onComplete((ttlRemaining, e) 这句话相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">RFuture&lt;<span class="hljs-built_in">Long</span>&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,<br>                                        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),<br>                                        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);<br>ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// lock acquired</span><br>    <span class="hljs-keyword">if</span> (ttlRemaining == <span class="hljs-literal">null</span>) &#123;<br>        scheduleExpirationRenewal(threadId);<br>    &#125;<br>&#125;);<br><span class="hljs-keyword">return</span> ttlRemainingFuture;<br></code></pre></td></tr></table></figure><p>此逻辑就是续约逻辑，注意看commandExecutor.getConnectionManager().newTimeout（） 此方法</p><p>Method(  <strong>new</strong> TimerTask() {},参数2 ，参数3  )</p><p>指的是：通过参数2，参数3 去描述什么时候去做参数1的事情，现在的情况是：10s之后去做参数一的事情</p><p>因为锁的失效时间是30s，当10s之后，此时这个timeTask 就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p><p>那么大家可以想一想，假设我们的线程出现了宕机他还会续约吗？当然不会，因为没有人再去调用renewExpiration这个方法，所以等到时间之后自然就释放了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">renewExpiration</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ExpirationEntry</span> <span class="hljs-variable">ee</span> <span class="hljs-operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());<br>    <span class="hljs-keyword">if</span> (ee == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">Timeout</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Timeout timeout)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            <span class="hljs-type">ExpirationEntry</span> <span class="hljs-variable">ent</span> <span class="hljs-operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());<br>            <span class="hljs-keyword">if</span> (ent == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ent.getFirstThreadId();<br>            <span class="hljs-keyword">if</span> (threadId == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <br>            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);<br>            future.onComplete((res, e) -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>                    log.error(<span class="hljs-string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="hljs-string">&quot; expiration&quot;</span>, e);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span> (res) &#123;<br>                    <span class="hljs-comment">// reschedule itself</span><br>                    renewExpiration();<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;, internalLockLeaseTime / <span class="hljs-number">3</span>, TimeUnit.MILLISECONDS);<br>    <br>    ee.setTimeout(task);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>可以一次执行多个命令，本质是一组命令的集合，一个事务中的所有命令都会序列化，按顺序地串行化执行而<strong>不会被其他命令插入</strong>，<strong>不许加塞</strong></p><p>能干吗？<strong>在一个队列中</strong>、一次性、顺序性、排他性的执行一系列命令</p><p>redis事务 VS MySQL事务</p><table><thead><tr><th>1.单独的隔离操作</th><th>Redis的事务仅仅是保证事务里的操作会被连续独占的执行，redis命令执行是单线程架构，在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的</th></tr></thead><tbody><tr><td>2.没有隔离级别的概念</td><td>因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这种问题了</td></tr><tr><td>3.不保证原子性</td><td>Redis的事务不保证原子性，也就是不保证所有指令同时成功或同时失败，只有决定是否开始执行全部指令的能力，没有执行到一半进行回滚的能力</td></tr><tr><td>4.排它性</td><td>Redis会保证一个事务内的命令依次执行，而不会被其它命令插入</td></tr></tbody></table><h3 id="事务有关的常用命令"><a href="#事务有关的常用命令" class="headerlink" title="事务有关的常用命令"></a>事务有关的常用命令</h3><p><img src="/../redis_pic/14.png"></p><p>翻译：discard —- 丢弃</p><h3 id="case1-正常执行"><a href="#case1-正常执行" class="headerlink" title="case1-正常执行"></a>case1-正常执行</h3><p><img src="/../redis_pic/15.png"></p><p>multi、exec</p><p>multi开启事务，然后输入了4条指令，注意，这时候并没有执行，看命令下方，<strong>出现了QUEUED</strong>，这就是上面说的<strong>队列</strong>（<strong>在一个队列中</strong>、一次性、顺序性、排他性的执行一系列命令），它先将命令放在一个队列中，然后当调用exec的时候<strong>一次性的、顺序的</strong>执行完队列中的命令，并且不许被插入(排他)</p><h3 id="case2-放弃事务"><a href="#case2-放弃事务" class="headerlink" title="case2-放弃事务"></a>case2-放弃事务</h3><p>multi、discard</p><p><img src="/../redis_pic/16.png"></p><h3 id="case3-全体连坐"><a href="#case3-全体连坐" class="headerlink" title="case3-全体连坐"></a>case3-全体连坐</h3><p><img src="/../redis_pic/17.png"></p><h3 id="case4-冤头债主"><a href="#case4-冤头债主" class="headerlink" title="case4-冤头债主"></a>case4-冤头债主</h3><p><img src="/../redis_pic/18.png"></p><h3 id="case5-watch监控"><a href="#case5-watch监控" class="headerlink" title="case5-watch监控"></a>case5-watch监控</h3><p>Redis使用Watch来提供<strong>乐观锁定</strong>，类似于CAS(Check-and-Set)</p><p>复习：</p><p><strong>悲观锁(Pessimistic Lock)</strong>, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</p><p><strong>乐观锁(Optimistic Lock)</strong>, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。</p><p><strong>乐观锁策略</strong>:提交版本必须  大于  记录当前版本才能执行更新</p><p>watch：初始化k1和balance两个key，先监控再开启multi，保证两key变动在同一个失误内</p><p><strong>正常情况：</strong></p><p><img src="/../redis_pic/19.png"></p><p><strong>有加塞篡改：</strong></p><p><strong>watch命令是一种乐观锁的实现，Redis在修改的时候会检测数据是否被更改，如果更改了，则整个执行失败</strong></p><p><strong>第一个窗口蓝色框第5步执行结果返回为空，也就是相当于是失败，笔记见最下面官网说明</strong></p><p><img src="/../redis_pic/20.png"></p><p><img src="/../redis_pic/21.png"></p><hr><p>总结：</p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230703223637525.png" alt="image-20230703223637525"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>常用数据结构</title>
    <link href="/2023/05/08/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/05/08/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="红黑树-平衡二叉查找树"><a href="#红黑树-平衡二叉查找树" class="headerlink" title="红黑树(平衡二叉查找树)"></a>红黑树(平衡二叉查找树)</h2><p>首先他是一棵<strong>二叉搜索树</strong>(左子节点的值小于自身，右子结点的值大于自身，左子树都小于自身，右子树都大于自身，中序遍历是递增有序的)</p><p><img src="/../struct_pic/3.png"></p><p>极端情况下退化为链表，此时高度为n,操作时间复杂读降低。所以需要平衡树</p><p>红黑树<strong>通过对结点进行黑红标色，旋转及其他操作进行平衡操作</strong></p><p><img src="/../struct_pic/4.png"></p><p>红黑树<strong>不具有严格的平衡属性</strong>(平衡属性：任意结点左右子树高度相差不大于1)，但是平均使用性能非常良好。适用于<strong>频繁插入</strong>和<strong>删除</strong>的的场景。什么时候红黑树进行旋转调整高度呢？<strong>当根到叶子结点的最长路径大于最短路径的两倍时</strong>，红黑树进行调整。</p><h3 id="红黑树与AVL树对比"><a href="#红黑树与AVL树对比" class="headerlink" title="红黑树与AVL树对比"></a>红黑树与AVL树对比</h3><p><img src="/../struct_pic/8.png"></p><h3 id="红黑树规则特点"><a href="#红黑树规则特点" class="headerlink" title="红黑树规则特点"></a>红黑树规则特点</h3><ul><li><p>节点分为红色或者黑色；</p></li><li><p>根节点必为黑色；</p></li><li><p>叶子节点都为黑色，且为null(不存储数据)；</p></li><li><p>连接红色节点的两个子节点都为黑色（红黑树不会出现相邻的红色节点）；</p></li><li><p>从任意节点出发，到其每个叶子节点的路径中包含相同数量的黑色节点；</p></li><li><p>新加入到红黑树的节点为红色节点；</p></li></ul><p>这些规则强制了红黑树的关键性质：<strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</strong>(而AVL平衡二叉搜索树的旋转策略是最大高度差不超过1)，结果是这个树大致上是平衡的。因为操作比如<strong>插入、删除和查找</strong>某个值的最坏情况时间<strong>都要求与树的高度成比例</strong>，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。</p><p><img src="/../struct_pic/1.png"></p><p><img src="/../struct_pic/2.png"></p><p>树的高度趋近于logn，从而树上的各种操作(插入&#x2F;删除&#x2F;查找)的<strong>时间复杂度为logn</strong>。</p><p>一颗有N的结点的红黑树高度最多不超过(&lt;&#x3D;)2long(N+1).</p><h3 id="红黑树的变色与旋转"><a href="#红黑树的变色与旋转" class="headerlink" title="红黑树的变色与旋转"></a>红黑树的变色与旋转</h3><p>回顾红黑色的规则特点，当我们对红黑树进行插入和删除是，可能会破坏这些规则，所以我们需要<strong>变色</strong>和<strong>旋转</strong>维护红黑树的规则特点。</p><p>变色就是红色—-&gt;黑色或者黑色—-&gt;红色</p><p>旋转分为<strong>左旋</strong>和<strong>右旋</strong></p><p><img src="/../struct_pic/5.png"></p><p>加入要对4结点进行左旋操作其中左旋右两个核心操作</p><p><strong>一.4的右节点成为4的父节点</strong></p><p><img src="/../struct_pic/6.png"></p><p><strong>二.4结点的右孩子结点的左子树成为4的右子树</strong></p><p><img src="/../struct_pic/7.png"></p><p>右旋和左旋对称同理</p><h2 id="一、Queue和Deque"><a href="#一、Queue和Deque" class="headerlink" title="一、Queue和Deque"></a>一、Queue和Deque</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Queue以及Deque都是继承于Collection，Deque是Queue的子接口。</p><p>Queue是FIFO的单向队列，Deque是双向队列。</p><p>Queue有一个直接子类PriorityQueue，而Deque中直接子类有两个：LinkedList以及ArrayDeque。</p><p>PriorityQueue的底层数据结构是数组，而无边界的形容，那么指明了PriorityQueue是自带扩容机制的。</p><p>ArrayDeque是无初始容量的双端队列，LinkedList则是双向链表。</p><p>PriorityQueue可以作为堆使用，而且可以根据传入的Comparator实现大小的调整，会是一个很好的选择。<br>ArrayDeque通常作为栈或队列使用，但是栈的效率不如LinkedList高。<br>LinkedList通常作为栈或队列使用，但是队列的效率不如ArrayQueue高。</p><h3 id="api对比"><a href="#api对比" class="headerlink" title="api对比"></a>api对比</h3><table><thead><tr><th></th><th>Queue</th><th>Deque</th></tr></thead><tbody><tr><td>增加</td><td>add</td><td>add、addFirst、addLast</td></tr><tr><td></td><td>offer</td><td>offer、offerFirst、offerLast</td></tr><tr><td>移除</td><td>remove</td><td>remove、removeFirst、removeLast</td></tr><tr><td></td><td>poll</td><td>pop、poll、pollFirst、pollLast</td></tr><tr><td>获取</td><td>element</td><td>element、getFirst、getLast</td></tr><tr><td></td><td>peek</td><td>peek、peekFirst、peekLast</td></tr></tbody></table><p><strong>备注：</strong></p><p>1、add和offer区别</p><ul><li>add() : 添加元素，如果添加成功则返回true，如果队列是满的，则抛出异常</li><li>offer() : 添加元素，如果添加成功则返回true，如果队列是满的，则返回false</li></ul><p>2、remove和poll</p><ul><li>remove() : 移除队列头的元素并且返回，如果队列为空则抛出异常</li><li>poll() : 移除队列头的元素并且返回，如果队列为空则返回null</li><li>Deque新增了一个pop方法，也是移除队列头的元素并且返回，如果队列为空则抛出异常。</li></ul><p>3、element和peek</p><ul><li>element() ：返回队列头元素但不移除，如果队列为空，则抛出异常</li><li>peek() ：返回队列头元素但不移除，如果队列为空，则返回null</li><li>因此，增加推荐使用add，移除推荐使用poll，获取元素推荐使用peek。</li></ul><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><h4 id="1、queue"><a href="#1、queue" class="headerlink" title="1、queue"></a>1、queue</h4><p>队列(queue)是一种常用的数据结构，可以将队列看做是一种特殊的线性表，该结构遵循的先进先出原则。Java中，LinkedList实现了Queue接口,因为LinkedList进行插入、删除操作效率较高。</p><p><strong>初始化：</strong></p><blockquote><p>Queue <Integer> q &#x3D; new LinkedList<Integer>();</p></blockquote><p>**常用方法：<br>**</p><p>**add(E e)?*将指定元素插入此队列尾部，成功返回true。</p><p>**offer(E e)?*将指定元素插入队列尾部，成功返回true。当队列有容量 限制时，此方法由于add，因为后者可能无法插入，而只是抛出IllegalStateException异常。</p><p>**remove()?*获取并移除队列的头部元素，队列为空抛出异常。</p><p><strong>poll()：</strong>获取并移除队列的头部元素，队列为空返回null。</p><p>**element()?*获取但是不移除队列头部元素，队列为空抛出异常。</p><p>**peek()?*获取但是不移除队列头部元素，队列为空返回null。</p><p>**isEmpty()?*判断队列是否为空，为空返回true。</p><p>**size()?*获取队列元素数量.</p><p><strong>实例代码：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Queue&lt;<span class="hljs-type">String</span>&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">// add()和remove()方法在失败的时候会抛出异常(不推荐)</span><br>    queue.<span class="hljs-built_in">offer</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>    queue.<span class="hljs-built_in">offer</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>    queue.<span class="hljs-built_in">offer</span>(<span class="hljs-string">&quot;c&quot;</span>);<br>    queue.<span class="hljs-built_in">offer</span>(<span class="hljs-string">&quot;d&quot;</span>);<br>    queue.<span class="hljs-built_in">offer</span>(<span class="hljs-string">&quot;e&quot;</span>);<br>    queue.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;f&quot;</span>);<br>    <span class="hljs-comment">//在队列元素为空的情况下，remove() 方法会抛出NoSuchElementException异常，poll() 方法只会返回 null 。</span><br>    <span class="hljs-type">String</span> first2 = queue.<span class="hljs-built_in">remove</span>();<span class="hljs-comment">//返回第一个元素，删除</span><br>    System.out.<span class="hljs-built_in">println</span>(first2);<span class="hljs-comment">//a</span><br>    <span class="hljs-type">String</span> first1 = queue.<span class="hljs-built_in">poll</span>();<span class="hljs-comment">//返回第一个元素，删除</span><br>    System.out.<span class="hljs-built_in">println</span>(first1);<span class="hljs-comment">//b</span><br>    <span class="hljs-type">String</span> first = queue.<span class="hljs-built_in">peek</span>();<span class="hljs-comment">//返回第一个元素，但不删除</span><br>    System.out.<span class="hljs-built_in">println</span>(first);<span class="hljs-comment">//c</span><br>    System.out.<span class="hljs-built_in">println</span>(queue);<span class="hljs-comment">//[c, d, e, f]</span><br>    first = queue.<span class="hljs-built_in">element</span>();<span class="hljs-comment">//返回第一个元素</span><br>    System.out.<span class="hljs-built_in">println</span>(first);<span class="hljs-comment">//c</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、deque"><a href="#2、deque" class="headerlink" title="2、deque"></a>2、deque</h4><p>双向队列是指该队列两端的元素既能入队(offer)也能出队(poll),如果将Deque限制为只能从一端入队和出队，则可实现栈的数据结构。对于栈而言，有入栈(push)和出栈(pop)，遵循先进后出原则。</p><p><strong>初始化：</strong></p><blockquote><p>Deque<Integer> d &#x3D; new LinkedList<Integer>();</p></blockquote><p>**常用方法：<br>**</p><p>**addLast(E e)?*在队列尾部插入元素.</p><p>**offerLast(E e)?*在队列尾部插入元素。</p><p>**removeFirst()?*获取头部元素。</p><p>**pollFirst()?*获取头部元素。</p><p>**getFirst()?*获取头部元素。</p><p>**peekFirst()?*获取头部元素。</p><blockquote><p>&#x2F;&#x2F;上述方法均和queue中方法一一对应。<br>&#x2F;&#x2F;且queue中的方法，deque中均可用。</p></blockquote><p>**getLast()?*获取但不移除队列最后一个元素。</p><p>**offerFirst()?*将指定元素插入队列开头。</p><p>**peekLast()?*获取但不移除双端队列最后一个元素。</p><p>**pollLast()?*获取并移除双端队列最后一个元素。</p><p>**pop()?*从双端队列表示的堆栈 中弹出一个元素。</p><p>**push()?*将一个元素推入双端队列表示的堆栈，即队列的头部。成功返回true，如果没有可用空间，抛出IllegalStateException。</p><p>**removeLast()?*获取并移除移除双端队列最后一个元素。</p><p>**size()?*返回双端队列元素数。</p><p>**isEmpty()?*判断队列是否为空，为空返回true。</p><p>**remove(Object o)?*从双端队列中移除第一次出现的指定元素。</p><p><strong>实例代码：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs awk">public static void test02()&#123;<br>    Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();<br>    deque.offer(<span class="hljs-string">&quot;a&quot;</span>);<br>    deque.offer(<span class="hljs-string">&quot;b&quot;</span>);<br>    deque.offerFirst(<span class="hljs-string">&quot;c&quot;</span>);<span class="hljs-regexp">//</span>在队列头部进行插入<br>    System.out.println(deque);<span class="hljs-regexp">//</span>[c, a, b]<br>    deque.offerLast(<span class="hljs-string">&quot;d&quot;</span>);<br>    System.out.println(deque);<span class="hljs-regexp">//</span>[c, a, b, d]<br> <br>    String ret = deque.element();<span class="hljs-regexp">//</span>返回第一个元素<br>    System.out.println(ret);<span class="hljs-regexp">//</span>c<br> <br>    ret = deque.getFirst();<span class="hljs-regexp">//</span>返回第一个元素<br>    System.out.println(ret);<span class="hljs-regexp">//</span>c<br>    ret = deque.getLast();<span class="hljs-regexp">//</span>返回最后一个元素<br>    System.out.println(ret);<span class="hljs-regexp">//</span>d<br> <br>    ret = deque.peek();<span class="hljs-regexp">//</span>返回第一个元素，但不删除<br>    System.out.println(ret);<span class="hljs-regexp">//</span>c<br> <br>    ret = deque.peekFirst();<span class="hljs-regexp">//</span>返回第一个元素，但不删除<br>    System.out.println(ret);<span class="hljs-regexp">//</span>c<br>    ret = deque.peekLast();<span class="hljs-regexp">//</span>返回最后一个元素，但不删除<br>    System.out.println(ret);<span class="hljs-regexp">//</span>d<br> <br>    System.out.println(deque);<br> <br>    ret = deque.poll();<span class="hljs-regexp">//</span>返回第一个元素，删除<br>    System.out.println(ret);<span class="hljs-regexp">//</span>c<br>    System.out.println(deque);<span class="hljs-regexp">//</span>[a, b, d]<br> <br>    ret = deque.pop();<span class="hljs-regexp">//</span>返回第一个元素，删除<br>    System.out.println(ret);<span class="hljs-regexp">//</span>a<br>    System.out.println(deque);<span class="hljs-regexp">//</span>[b, d]<br> <br>    deque.clear();<br>    ret = deque.pop();<span class="hljs-regexp">//</span>抛异常<br>    System.out.println(<span class="hljs-string">&quot;11111&quot;</span>);<br>    ret = deque.poll();<span class="hljs-regexp">//</span>返回null,但不抛异常<br>    System.out.println(<span class="hljs-string">&quot;++&quot;</span>+ret);<br>    System.out.println(<span class="hljs-string">&quot;22222&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java8新特性</title>
    <link href="/2023/04/26/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2023/04/26/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda是一个<strong>匿名函数</strong>，我们可以把Lambda表达式理解为是<strong>一段可以传递的代码</strong>(将代码像数据一样进行传递)。使用它可以写出更简洁，灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p><h3 id="Lambda表达式的格式"><a href="#Lambda表达式的格式" class="headerlink" title="Lambda表达式的格式"></a>Lambda表达式的格式</h3><h4 id="1-标准格式："><a href="#1-标准格式：" class="headerlink" title="1.标准格式："></a>1.标准格式：</h4><p>​        （参数列表） -&gt; {代码}</p><h4 id="2-格式说明："><a href="#2-格式说明：" class="headerlink" title="2.格式说明："></a>2.格式说明：</h4><p>​- 小括内的语法与传统方法参数列表一致，没有参数就留空，有多个参数就用逗号分隔</p><p>​        - 【-&gt;】 是新引入的语法格式，代表指向动作</p><p>​        - 大括号内的语法与传统方法体要求一致</p><h4 id="3-案例说明"><a href="#3-案例说明" class="headerlink" title="3.案例说明"></a>3.案例说明</h4><p>第一个线程案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span> <span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程需要执行的任务代码1&quot;</span>);<br>    &#125;<br>&#125;);<br>thread1.start();<br> <br><span class="hljs-comment">// Lambda表达式</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    System.out.println(<span class="hljs-string">&quot;线程需要执行的任务代码2&quot;</span>);<br>&#125;);<br>t2.start();<br></code></pre></td></tr></table></figure><p>第二个比较器案例</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">List&lt;<span class="hljs-type">Integer</span>&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>Collections.addAll(list,<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>,<span class="hljs-number">55</span>);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;排序之前的集合：&quot; + list);<br><br>// 比较器的正常书写格式<br>Collections.sort(list, <span class="hljs-built_in">new</span> Comparator&lt;<span class="hljs-type">Integer</span>&gt;() &#123;<br>    @Override<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> compare (<span class="hljs-type">Integer</span> o1, <span class="hljs-type">Integer</span> o2) &#123;<br>        <span class="hljs-keyword">return</span> o2-o1;<br>    &#125;<br>&#125;);<br> <br>// Lambda表达式<br>Collections.sort(list,(<span class="hljs-type">Integer</span> o1, <span class="hljs-type">Integer</span> o2)-&gt;&#123;<span class="hljs-keyword">return</span> o2-o1;&#125;);<br>//或者<br>list.sort((o1,o2)-&gt;(o1-o2));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;排序之后的集合：&quot; + list);<br></code></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">sortTest</span> &#123;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        int[][] arr =&#123;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">8</span>,<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-number">15</span>,<span class="hljs-number">18</span>&#125;&#125;;<br>        Arrays.sort<span class="hljs-function"><span class="hljs-params">(arr,(x,y)-&gt;(x[<span class="hljs-number">0</span>]-y[<span class="hljs-number">0</span>]))</span>;</span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(int[] ints : arr)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">for</span> <span class="hljs-params">(int anInt : ints)</span> &#123;</span><br><span class="hljs-function">                <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">print</span><span class="hljs-params">(anInt+<span class="hljs-string">&quot; &quot;</span>)</span>;</span><br><span class="hljs-function">            &#125;</span><br><span class="hljs-function">            <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">输出：</span><br><span class="hljs-function">1 3 </span><br><span class="hljs-function">2 6 </span><br><span class="hljs-function">8 10 </span><br><span class="hljs-function">15 18</span><br><span class="hljs-function">排序成功！</span><br></code></pre></td></tr></table></figure><h3 id="Lambda表达式的使用条件"><a href="#Lambda表达式的使用条件" class="headerlink" title="Lambda表达式的使用条件"></a>Lambda表达式的使用条件</h3><ul><li>Lambda表达式不是万能的，他需要函数式接口的支持；</li><li>什么是函数式接口：<br>函数式接口的定义是: 只包含一个抽象方法的接口，称为函数式接口；<br>其实我们的Lambda表达式就是对函数式接口的一种简写方式，所以只有是函数式接口，我们才能用Lambda表达式；再换句话说，Lambda表达式需要函数式接口的支持，那函数式接口我们可以自己定义，当然JDK1.8也给我们提供了一些现成的函数式接口；<br><img src="/../java8_pic/2.png"></li></ul><p> 首先，都是接口；  其次，接口中有且只有一个接口，才可以使用lambda表达式</p><p>​    1.接口中只有一个抽象方法的接口，叫做函数式接口</p><p>​    2.如果是函数式接口，那么就可以用@FunctionalInterface注解标识</p><p><img src="/../java8_pic/1.png"></p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>先来看一下什么是方法引用：</p><ul><li>方法引用其实是Lambda表达式的另一种写法，当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用；</li></ul><p>注意： 实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致！<br>方法引用：使用操作符<code>::</code>将方法名和对象或类的名字分隔开来，三种主要使用情况为：</p><p>对象::实例方法<br>类::静态方法<br>类::实例方法</p><p><strong>对象::实例方法</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">function</span>.<span class="hljs-property">Consumer</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-title class_">String</span>&gt; consumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-title class_">String</span>&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">accept</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>) &#123;<br>                <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(s);<br>            &#125;<br>        &#125;;<br>        consumer.<span class="hljs-title function_">accept</span>(<span class="hljs-string">&quot;aaaaaaaaaaaaaa&quot;</span>);<br>        <span class="hljs-comment">//aaaaaaaaaaaaaa</span><br><br>        <span class="hljs-comment">//简写1：</span><br>        <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-title class_">String</span>&gt; consumer1 = (<span class="hljs-title class_">String</span> s) -&gt; &#123;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(s);<br>        &#125;;<br>        consumer1.<span class="hljs-title function_">accept</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>        <span class="hljs-comment">//abc</span><br><br>        <span class="hljs-comment">//简写2：</span><br>        <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-title class_">String</span>&gt; consumer2 = (s) -&gt; <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(s);<br>        consumer2.<span class="hljs-title function_">accept</span>(<span class="hljs-string">&quot;bcd&quot;</span>);<br>        <span class="hljs-comment">//bcd</span><br><br>        <span class="hljs-comment">//简写3：</span><br>        <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-title class_">String</span>&gt; consumer3 = <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>::println;<br>        consumer3.<span class="hljs-title function_">accept</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>        <span class="hljs-comment">//abc</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>类::静态方法</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.<span class="hljs-keyword">function</span>.BinaryOperator;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MyTest1 &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        BinaryOperator&lt;<span class="hljs-type">Double</span>&gt; <span class="hljs-keyword">operator</span> = <span class="hljs-built_in">new</span> BinaryOperator&lt;<span class="hljs-type">Double</span>&gt;()&#123;<br>            @Override<br>            <span class="hljs-built_in">public</span> <span class="hljs-type">Double</span> apply(<span class="hljs-type">Double</span> o, <span class="hljs-type">Double</span> o2) &#123;<br>                <span class="hljs-keyword">return</span> Math.max(o,o2);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">operator</span>.apply(<span class="hljs-number">2.13</span>, <span class="hljs-number">3.12</span>));//<span class="hljs-number">3.12</span><br><br>        BinaryOperator&lt;<span class="hljs-type">Double</span>&gt; operator2 = (o, o2) -&gt; Math.max(o,o2);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(operator2.apply(<span class="hljs-number">2.13</span>, <span class="hljs-number">3.12</span>));//<span class="hljs-number">3.12</span><br><br>        BinaryOperator&lt;<span class="hljs-type">Double</span>&gt; operator3 = Math::max;<br><br>        <span class="hljs-type">Double</span> max = operator3.apply(<span class="hljs-number">5.0</span>, <span class="hljs-number">20.0</span>);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(max);//<span class="hljs-number">20.0</span><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>因为Math.max()所需要的参数以及返回值与重写的accpet()一样，因此可以简写为<code>类::静态方法</code>；</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MyTest2 &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        Comparator&lt;<span class="hljs-type">Integer</span>&gt; comparator = <span class="hljs-built_in">new</span> Comparator&lt;<span class="hljs-type">Integer</span>&gt;() &#123;<br>            @Override<br>            <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> compare(<span class="hljs-type">Integer</span> o1, <span class="hljs-type">Integer</span> o2) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-type">Integer</span>.compare(o1,o2);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(comparator.compare(<span class="hljs-number">20</span>, <span class="hljs-number">12</span>));//<span class="hljs-number">1</span><br><br>        Comparator&lt;<span class="hljs-type">Integer</span>&gt; comparator1 = <span class="hljs-type">Integer</span>::compareTo;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(comparator1.compare(<span class="hljs-number">20</span>, <span class="hljs-number">12</span>));//<span class="hljs-number">1</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>类::实例方法</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Comparator</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-title class_">String</span>&gt; comparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-title class_">String</span>&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> int <span class="hljs-title function_">compare</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> o1, <span class="hljs-built_in">String</span> o2</span>) &#123;<br>                <span class="hljs-keyword">return</span> o1.<span class="hljs-title function_">compareTo</span>(o2);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(comparator.<span class="hljs-title function_">compare</span>(<span class="hljs-string">&quot;20&quot;</span>, <span class="hljs-string">&quot;12&quot;</span>));<span class="hljs-comment">//1</span><br><br>        <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-title class_">String</span>&gt; comparator1 = <span class="hljs-title class_">String</span>::compareTo;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(comparator1.<span class="hljs-title function_">compare</span>(<span class="hljs-string">&quot;20&quot;</span>, <span class="hljs-string">&quot;12&quot;</span>));<span class="hljs-comment">//1</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>为什么可以这样写？、<br>传递过来的两个参数，一个作为调用者，一个作为参数，这时候，使用<code>类::实例方法</code>简写</p><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p><strong>现有一个需求：</strong></p><p>将list集合中姓张的元素过滤到一个新的集合中</p><p>然后将过滤出来的姓张的元素中，再过滤出来长度为3的元素，存储到一个新的集合中</p><p><strong>1.用常规方法解决需求</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 已知的知识来解决需求</span><br>List&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list1.add(<span class="hljs-string">&quot;张老三&quot;</span>);<br>list1.add(<span class="hljs-string">&quot;张小三&quot;</span>);<br>list1.add(<span class="hljs-string">&quot;李四&quot;</span>);<br>list1.add(<span class="hljs-string">&quot;赵五&quot;</span>);<br>list1.add(<span class="hljs-string">&quot;张六&quot;</span>);<br>list1.add(<span class="hljs-string">&quot;王八&quot;</span>);<br> <br>ArrayList&lt;String&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">// 1.将list集合中姓张的元素过滤到一个新的集合中</span><br><span class="hljs-keyword">for</span>(String name : list1)&#123;<br>    <span class="hljs-keyword">if</span>(name.startsWith(<span class="hljs-string">&quot;张&quot;</span>))&#123;<br>        list2.add(name);<br>    &#125;<br>&#125;<br><span class="hljs-type">ArrayList</span> <span class="hljs-variable">list3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><span class="hljs-keyword">for</span> (String name : list2) &#123;<br>    <span class="hljs-keyword">if</span> (name.length() == <span class="hljs-number">3</span>)&#123;<br>        list3.add(name);<br>    &#125;<br>&#125;<br>System.out.println(list3);<br> <br>输出结果：<br>    [张老三, 张小三]<br></code></pre></td></tr></table></figure><p> <strong>2.用Stream流操作集合，获取流，过滤操作，打印输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">list1.stream().filter((String name)-&gt;name.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).filter((String name)-&gt;name.length()==<span class="hljs-number">3</span>).forEach((String name)-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;符合条件的姓名：&quot;</span> + name);<br>        &#125;);<br></code></pre></td></tr></table></figure><p>( 看不懂没关系，下面会讲到该方法，这里只是用来引入的）</p><h3 id="Stream流的格式"><a href="#Stream流的格式" class="headerlink" title="Stream流的格式"></a>Stream流的格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;T&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; predicate)</span>;<br>            -----&gt; 参数：<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Predicate</span>&lt;T&gt;  (函数式接口)<br>                    ----&gt; 抽象方法：<span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;<br>            -----&gt; 参数：<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Consumer</span>&lt;T&gt;  (函数式接口)<br>                    ----&gt; 抽象方法：<span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;<br></code></pre></td></tr></table></figure><h3 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h3><p>  Collection接口中有一个stream()方法，可以获取流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">stream</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><p>代码演示</p><p> 1.根据List集合获取流</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><br>// 创建List集合<br>List&lt;String&gt; list <span class="hljs-operator">=</span> new ArrayList&lt;&gt;()<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;张老三&quot;</span>)<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;张小三&quot;</span>)<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;李四&quot;</span>)<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;赵五&quot;</span>)<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;张六&quot;</span>)<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;王八&quot;</span>)<span class="hljs-comment">;</span><br>Stream&lt;String&gt; stream1 <span class="hljs-operator">=</span> list.stream()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>2.根据Set集合获取流</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 创建List集合<br>Set&lt;String&gt; set <span class="hljs-operator">=</span> new HashSet&lt;&gt;()<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;张老三&quot;</span>)<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;张小三&quot;</span>)<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;李四&quot;</span>)<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;赵五&quot;</span>)<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;张六&quot;</span>)<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;王八&quot;</span>)<span class="hljs-comment">;</span><br>Stream&lt;String&gt; stream2 <span class="hljs-operator">=</span> set.stream()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p> 3.根据Map集合获取流</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">// 创建Map集合</span><br><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">Integer</span>,<span class="hljs-built_in">String</span>&gt; <span class="hljs-built_in">map</span> = <span class="hljs-literal">new</span> HashMap&lt;&gt;();<br><span class="hljs-built_in">map</span>.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;张老三&quot;</span>);<br><span class="hljs-built_in">map</span>.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;张小三&quot;</span>);<br><span class="hljs-built_in">map</span>.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;李四&quot;</span>);<br><span class="hljs-built_in">map</span>.put(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;赵五&quot;</span>);<br><span class="hljs-built_in">map</span>.put(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;张六&quot;</span>);<br><span class="hljs-built_in">map</span>.put(<span class="hljs-number">6</span>,<span class="hljs-string">&quot;王八&quot;</span>);<br> <br><span class="hljs-comment">// 3.1根据Map集合的键获取流</span><br><span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">Integer</span>&gt; map1 = <span class="hljs-built_in">map</span>.keySet();<br>Stream&lt;<span class="hljs-built_in">Integer</span>&gt; stream3 = map1.stream();<br><span class="hljs-comment">// 3.2根据Map集合的值获取流</span><br>Collection&lt;<span class="hljs-built_in">String</span>&gt; map2 = <span class="hljs-built_in">map</span>.values();<br>Stream&lt;<span class="hljs-built_in">String</span>&gt; stream4 = map2.stream();<br><span class="hljs-comment">// 3.3根据Map集合的键值对对象获取瑞</span><br><span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">Map</span>.Entry&lt;<span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">String</span>&gt;&gt; map3 = <span class="hljs-built_in">map</span>.entrySet();<br>Stream&lt;<span class="hljs-built_in">Map</span>.Entry&lt;<span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">String</span>&gt;&gt; stream5 = map3.stream();<br></code></pre></td></tr></table></figure><p>​    4.根据数组获取流</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 根据数组获取流</span><br><span class="hljs-type">String</span>[] arr = &#123;<span class="hljs-string">&quot;张颜宇&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;赵五&quot;</span>,<span class="hljs-string">&quot;刘六&quot;</span>,<span class="hljs-string">&quot;王七&quot;</span>&#125;;<br><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-type">String</span>&gt; stream6 = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(arr);<br></code></pre></td></tr></table></figure><h3 id="Stream流的常用方法"><a href="#Stream流的常用方法" class="headerlink" title="Stream流的常用方法"></a>Stream流的常用方法</h3><p><strong>终结方法</strong>：返回值类型不再是Stream接口本身类型的方法，例如：forEach方法和count方法</p><p><strong>非终结方法&#x2F;延迟方法</strong>：返回值类型仍然是Stream接口自身类型的方法，除了终结方法都是延迟方法。例如：filter,limit,skip,map,conat</p><table><thead><tr><th>方法名称</th><th>方法作用</th><th>方法种类</th><th>是否支持链式调用</th></tr></thead><tbody><tr><td>count</td><td>统计个数</td><td>终结方法</td><td>否</td></tr><tr><td>forEach</td><td>逐一处理</td><td>终结方法</td><td>否</td></tr><tr><td>filter</td><td>过滤</td><td>函数拼接</td><td>是</td></tr><tr><td>limit</td><td>取用前几个</td><td>函数拼接</td><td>是</td></tr><tr><td>skip</td><td>跳过前几个</td><td>函数拼接</td><td>是</td></tr><tr><td>map</td><td>映射</td><td>函数拼接</td><td>是</td></tr><tr><td>concat</td><td>组合</td><td>函数拼接</td><td>是</td></tr></tbody></table><h3 id="方法演示"><a href="#方法演示" class="headerlink" title="方法演示"></a>方法演示</h3><p><strong>1.count方法</strong>：long count (); 统计流中的元素，返回long类型数据</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">List&lt;String&gt; list = new ArrayList&lt;&gt;();<br>list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张老三&quot;</span>);<br>list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张小三&quot;</span>);<br>list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;李四&quot;</span>);<br>list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;赵五&quot;</span>);<br>list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张六&quot;</span>);<br>list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;王八&quot;</span>);<br>long count = list.stream().count();<br>System.out.println(<span class="hljs-string">&quot;集合中的元素个数是：&quot;</span> + count);<br>输出结果：<br>集合中的元素个数是：6<br></code></pre></td></tr></table></figure><p><strong>2.filter方法</strong></p><p>Stream<T> filter(Predicate<? super ?> predicate); 过滤出满足条件的元素</p><p>参数Predicate：函数式接口，抽象方法：boolean test （T  t)</p><p> Predicate接口：是一个判断接口</p><pre><code class="hljs">    // 获取stream流    Stream&lt;String&gt; stream = Stream.of(&quot;张老三&quot;, &quot;张小三&quot;, &quot;李四&quot;, &quot;赵五&quot;, &quot;刘六&quot;, &quot;王七&quot;);    // 需求：过去出姓张的元素    stream.filter((String name)-&gt;&#123;        return name.startsWith(&quot;张&quot;);    &#125;).forEach((String name)-&gt;&#123;        System.out.println(&quot;流中的元素&quot; + name);    &#125;);          </code></pre><p> (上面引入Stream流时，就用到了这个方法）</p><p><strong>3.forEach方法</strong></p><p>  void forEach(Consumer&lt;? super T&gt; action)：逐一处理流中的元素<br>            参数 Consumer&lt;? super T&gt; action：函数式接口，只有一个抽象方法：void accept（T t)；</p><p>注意：<br>1.此方法并不保证元素的逐一消费动作在流中是有序进行的（元素可能丢失）<br>2.Consumer是一个消费接口（可以获取流中的元素进行遍历操作，输出出去），可以使用Lambda表达式</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">List&lt;String&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>list.<span class="hljs-keyword">add</span>(&quot;张老三&quot;);<br>list.<span class="hljs-keyword">add</span>(&quot;张小三&quot;);<br>list.<span class="hljs-keyword">add</span>(&quot;李四&quot;);<br>list.<span class="hljs-keyword">add</span>(&quot;赵五&quot;);<br>list.<span class="hljs-keyword">add</span>(&quot;张六&quot;);<br>list.<span class="hljs-keyword">add</span>(&quot;王八&quot;);<br> <br>// 函数模型：获取流 <span class="hljs-comment">--&gt; 注意消费流中的元素</span><br>list.stream().<span class="hljs-keyword">forEach</span>((String <span class="hljs-type">name</span>)-&gt;&#123;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">name</span>);<br>&#125;);<br> <br>输出结果：<br>    张老三<br>    张小三<br>    李四<br>    赵五<br>    张六<br>    <br></code></pre></td></tr></table></figure><p><strong>4.limit方法</strong></p><p> Stream<T> limit(long maxSize);  取用前几个元素</p><p> 注意：参数是一个long 类型，如果流的长度大于参数，则进行截取；否则不进行操作</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 获取流的长度</span><br><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-type">String</span>&gt; stream1 = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张老三&quot;</span>, <span class="hljs-string">&quot;张小三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;赵五&quot;</span>, <span class="hljs-string">&quot;刘六&quot;</span>, <span class="hljs-string">&quot;王七&quot;</span>);<br><span class="hljs-comment">// 需求：保留前三个元素</span><br>stream1.<span class="hljs-built_in">limit</span>(<span class="hljs-number">3</span>).forEach((<span class="hljs-type">String</span> name)-&gt;&#123;<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;流中的前三个元素是：&quot;</span> + name);<br>&#125;);D<br>输出结果：<br>    流中的前三个元素是：张老三<br>    流中的前三个元素是：张小三<br>流中的前三个元素是：李四<br></code></pre></td></tr></table></figure><p><strong>5.map方法</strong></p><p><r> Stream <R> map(Function&lt;? super T,? exception R&gt; mapper;<br>                            参数Function&lt;T,R&gt;：函数式接口，抽象方法：R apply(T t);<br>                                Function&lt;T,R&gt;：其实就是一个类型转换接口（T和R的类型可以一致，也可以不一致）</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> 获取Stream流<br>Stream&lt;<span class="hljs-built_in">String</span>&gt; stream1 = Stream.<span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;11&quot;</span>,<span class="hljs-string">&quot;22&quot;</span>,<span class="hljs-string">&quot;33&quot;</span>,<span class="hljs-string">&quot;44&quot;</span>,<span class="hljs-string">&quot;55&quot;</span>);<br><span class="hljs-regexp">//</span> 需求：把stream1流中的元素转换为int类型<br>stream1.map(<span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">String</span> s)</span>-&gt;</span>&#123;<br>   <span class="hljs-keyword">return</span> Integer.<span class="hljs-built_in">parseInt</span>(s); <span class="hljs-regexp">//</span> 将<span class="hljs-built_in">String</span>类型的s进行转换为Integer类型的元素，并返回<br>&#125;).forEach(<span class="hljs-function"><span class="hljs-params">(Integer i)</span>-&gt;</span>&#123;<br>    System.out.println(i);  <span class="hljs-regexp">//</span> 将转换后的int类型的元素逐一输出<br>&#125;);<br>输出结果：<br>    <span class="hljs-number">11</span><br>    <span class="hljs-number">22</span><br>    <span class="hljs-number">33</span><br>    <span class="hljs-number">44</span><br>    <span class="hljs-number">55</span><br></code></pre></td></tr></table></figure><p><strong>6.skip方法</strong></p><p>Stream<T> skip(long n);   跳过前几个元素<br>          注意： 如果流的当前长度大于n，则跳过前n个，否则将会得到一个长度为0的空流</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 获取stream流</span><br><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-type">String</span>&gt; stream = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张老三&quot;</span>, <span class="hljs-string">&quot;张小三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;赵五&quot;</span>, <span class="hljs-string">&quot;刘六&quot;</span>, <span class="hljs-string">&quot;王七&quot;</span>);<br> <br>stream.<span class="hljs-built_in">skip</span>(<span class="hljs-number">3</span>).forEach((<span class="hljs-type">String</span> name)-&gt;&#123;<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;跳过前三个，打印剩下的&quot;</span> + name);<br>&#125;);<br> <br>输出结果：<br>    跳过前三个，打印剩下的赵五<br>    跳过前三个，打印剩下的刘六<br>   跳过前三个，打印剩下的王七<br></code></pre></td></tr></table></figure><p><strong>7.concat方法</strong></p><p> public static <T> Stream<T> concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)<br>      –&gt; 合并两个流</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-type">String</span>&gt; stream1 = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;11&quot;</span>,<span class="hljs-string">&quot;22&quot;</span>,<span class="hljs-string">&quot;33&quot;</span>,<span class="hljs-string">&quot;44&quot;</span>,<span class="hljs-string">&quot;55&quot;</span>);<br><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-type">String</span>&gt; stream2 = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张颜宇&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;赵五&quot;</span>, <span class="hljs-string">&quot;刘六&quot;</span>, <span class="hljs-string">&quot;王七&quot;</span>);<br> <br><span class="hljs-comment">// 需求：合并两个流</span><br><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-type">String</span>&gt; stream = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">concat</span>(stream1,stream2);<br>stream.forEach((<span class="hljs-type">String</span> name)-&gt;&#123;<br>    System.out.<span class="hljs-built_in">print</span>(name);<br>输出结果：<span class="hljs-number">1122334455</span>张颜宇张三李四赵五刘六王七<br></code></pre></td></tr></table></figure><p><strong>收集Stream流</strong></p><p>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);     把流中的数据收集到单列集合中<br>                    返回值类型是R。R指定为什么类型，就是手机到什么类型的集合<br>                    参数Collector&lt;? super T, A, R&gt;中的R类型，决定把流中的元素收集到哪个集合中<br>                    参数Collector如何得到 ？，可以使用 java.util.stream.Collectors工具类中的静态方法：</p><pre><code class="hljs">                    - public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()：转换为List集合                                            - public static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet() ：转换为Set集合</code></pre><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>List&lt;String&gt; list2 = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>list2.<span class="hljs-keyword">add</span>(&quot;张老三&quot;);<br>list2.<span class="hljs-keyword">add</span>(&quot;张小三&quot;);<br>list2.<span class="hljs-keyword">add</span>(&quot;李四&quot;);<br>list2.<span class="hljs-keyword">add</span>(&quot;赵五&quot;);<br>list2.<span class="hljs-keyword">add</span>(&quot;张六&quot;);<br>list2.<span class="hljs-keyword">add</span>(&quot;王八&quot;);<br>// 需求：过滤出姓张的并且长度为<span class="hljs-number">3</span>的元素<br><br>Stream&lt;String&gt; stream = list2.stream().<span class="hljs-keyword">filter</span>((String <span class="hljs-type">name</span>) -&gt; &#123;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-type">name</span>.startsWith(&quot;张&quot;);<br>&#125;).<span class="hljs-keyword">filter</span>((String <span class="hljs-type">name</span>) -&gt; &#123;   <br>    <span class="hljs-keyword">return</span> <span class="hljs-type">name</span>.length() == <span class="hljs-number">3</span>;<br>&#125;);<br> <br>// stream 收集到单列集合中<br>List&lt;String&gt; list = stream.collect(Collectors.toList());<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(list);<br><br>// stream 手机到单列集合中<br><span class="hljs-keyword">Set</span>&lt;String&gt; <span class="hljs-keyword">set</span> = stream.collect(Collectors.toSet());<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">set</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/2023/04/22/SpringBoot/"/>
    <url>/2023/04/22/SpringBoot/</url>
    
    <content type="html"><![CDATA[<h2 id="静态资源映射"><a href="#静态资源映射" class="headerlink" title="静态资源映射"></a>静态资源映射</h2><p>一般情况下，SpringBoot只能访问static或者是templates下的静态资源文件，如果想改变静态资源文件的位置需要开启静态资源文件映射(通过配置类的方式)</p><p><strong>classpath:&#x2F;</strong>  对应的就是resources这个目录。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>protected void add<span class="hljs-constructor">ResourceHandlers(ResourceHandlerRegistry <span class="hljs-params">registry</span>)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;开启静态资源映射&quot;</span>);<br>   registry.add<span class="hljs-constructor">ResourceHandler(<span class="hljs-string">&quot;/backend/**&quot;</span>)</span>.add<span class="hljs-constructor">ResourceLocations(<span class="hljs-string">&quot;classpath:/backend/&quot;</span>)</span>;<br>registry.add<span class="hljs-constructor">ResourceHandler(<span class="hljs-string">&quot;/front/**&quot;</span>)</span>.add<span class="hljs-constructor">ResourceLocations(<span class="hljs-string">&quot;classpath:/front/&quot;</span>)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>**是通配符，指一切资源</p><p>如果访问localhost:8080&#x2F;backend&#x2F;index.html,则会映射到resources&#x2F;backend&#x2F;index.html</p><h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p>在日常开发中，我们系统的每个业务方法可能包括多个原子性的数据库操作，比如下面的 <code>savePerson()</code>方法中就有两个原子性的数据库操作。这些原子性的数据库操作是由依赖的，它们要么都执行，要么都不执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">savePerson</span><span class="hljs-params">()</span> &#123;<br>personDao.save(person);<br>personDetailDao.save(personDetail);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><p>事务能否生效数据库是否支持事务是关键。比如常用的MySQL默认的是使用支持事务的innodb引擎。但是如果把数据库变为myisam，那么程序不支持事务了。</p><p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：</p><blockquote><ol><li>将小明的余额减少 1000 元。</li><li>将小红的余额增加 1000 元。</li></ol></blockquote><h3 id="事务的特性-ACID-了解吗？"><a href="#事务的特性-ACID-了解吗？" class="headerlink" title="事务的特性(ACID)了解吗？"></a>事务的特性(ACID)了解吗？</h3><ul><li><p><strong>原子性（Atomicity）</strong>:原子性是指事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。</p><p>可采用“A向B转账”这个例子来说明解释</p><p>在DBMS中，默认情况下一条SQL就是一个单独事务，事务是自动提交的。只有显式的使用start transaction开启一个事务，才能将一个代码块放在事务中执行。</p></li><li><p><strong>一致性（Consistency）：</strong> 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等</p></li><li><p><strong>隔离性（Isolation）</strong>： 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p></li><li><p><strong>持久性（Durability）:</strong> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li></ul><h2 id="Starter"><a href="#Starter" class="headerlink" title="Starter"></a>Starter</h2><ul><li>SpringBoot中常见项目名称，定义了当前项目使用的所有依赖坐标，以打到<strong>减少依赖配置</strong>的目的。</li></ul><h2 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h2><ul><li>所有的SpringBoot项目要继承的项目，定义了若干个坐标版本号(依赖管理，而非依赖)，以达到<strong>减少依赖冲突</strong>的目的。</li><li>spring-boot-starter-parent各版本间存在着诸多坐标版本不同。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2023/04/13/MySQL/"/>
    <url>/2023/04/13/MySQL/</url>
    
    <content type="html"><![CDATA[<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>如果设计到多表查询查询，那么首先应该确定设计哪几张表，然后分析他们之间的连接条件，最后确定查询字段。</strong></p><p>多表查询就是指从多张表中查询数据。</p><p>原来查询单表数据，执行的SQL形式为：select * from emp;</p><p>那么我们要执行多表查询，就只需要使用逗号分隔多张表即可，如： select * from emp(17条记录) , dept(6条记录) ;</p><p>此时,我们看到查询结果中包含了大量的结果集，总共102条记录，而这其实就是员工表emp所有的记录 (17) 与 部门表dept所有记录(6) 的所有组合情况，这种现象称之为笛卡尔积。接下来，就来简单 介绍下笛卡尔积。</p><p>笛卡尔积: 笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况。</p><p><img src="/../mysql_pic/98.png"></p><p>而在多表查询中，我们是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。</p><p><img src="/../mysql_pic/99.png"></p><p>在SQL语句中，如何来去除无效的笛卡尔积呢？ 我们可以给多表查询加上连接查询的条件即可</p><p>select * from emp , dept where emp.dept_id &#x3D; dept.id;</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>连接查询</p><ul><li><p>内连接：相当于查询A、B交集部分数据</p><ul><li><p>隐式内连接</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">SELECT</span> 字段列表 FROM 表<span class="hljs-number">1</span> , 表<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-params">...</span> ;<br><br></code></pre></td></tr></table></figure></li><li><p>显式内连接</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [ <span class="hljs-keyword">INNER</span> ] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 连接条件 ... ;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>外连接：</p></li><li><p>左外连接：查询左表所有数据，以及两张表交集部分数据</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">LEFT</span> [ <span class="hljs-keyword">OUTER</span> ] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 条件 ... ;<br></code></pre></td></tr></table></figure><p>eg: 查询emp表的所有数据, 和对应的部门信息</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.*, d.name <span class="hljs-keyword">from</span> emp <span class="hljs-built_in">e</span> <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> <span class="hljs-built_in">e</span>.dept_id = d.id;<br></code></pre></td></tr></table></figure></li><li><p>右外连接：查询右表所有数据，以及两张表交集部分数据</p></li><li><p>自连接：当前表与自身的连接查询，自连接必须使用表别名</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">SELECT 字段列表 <span class="hljs-selector-tag">FROM</span> 表<span class="hljs-selector-tag">A</span> 别名<span class="hljs-selector-tag">A</span> JOIN 表<span class="hljs-selector-tag">A</span> 别名<span class="hljs-selector-tag">B</span> ON 条件 ... ;<br></code></pre></td></tr></table></figure><p>eg:查询员工 及其 所属领导的名字</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> a.name , b.name <span class="hljs-keyword">from</span> emp a , emp b <span class="hljs-keyword">where</span> a.managerid = b.id;(内连接)<br></code></pre></td></tr></table></figure><p>eg:查询所有员工 emp 及其领导的名字 emp , <strong>如果员工没有领导, 也需要查询出来</strong> -&gt; 外连接 表结构: emp a , emp b</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> a.name <span class="hljs-string">&#x27;员工&#x27;</span>, b.name <span class="hljs-string">&#x27;领导&#x27;</span> <span class="hljs-keyword">from</span> emp a <span class="hljs-keyword">left join</span> emp b <span class="hljs-keyword">on</span> a.managerid = b.id;<br></code></pre></td></tr></table></figure></li><li><p>子查询：SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> column1 = ( <span class="hljs-keyword">SELECT</span> column1 <span class="hljs-keyword">FROM</span> t2 ) <br></code></pre></td></tr></table></figure><ul><li>标量子查询（子查询结果为单个值）eg:查询 “销售部” 的所有员工信息</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id = (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;销售部&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>列子查询(子查询结果为一列) eg: 查询 “销售部” 和 “市场部” 的所有员工信息</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;销售部&#x27;</span> <span class="hljs-keyword">or</span><br><span class="hljs-type">name</span> = <span class="hljs-string">&#x27;市场部&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>行子查询(子查询结果为一行) eg:查询与 “张无忌” 的薪资及直属领导相同的员工信息 ;</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> (salary,managerid) = (<span class="hljs-keyword">select</span> salary, managerid <span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;张无忌&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>表子查询(子查询结果为多行多列) eg: 查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.*, d.* <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> entrydate &gt; <span class="hljs-string">&#x27;2006-01-01&#x27;</span>) <span class="hljs-built_in">e</span> <span class="hljs-keyword">left</span><br><span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> <span class="hljs-built_in">e</span>.dept_id = d.id ;<br></code></pre></td></tr></table></figure></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h3><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><p>上述就是事务的四大特性，简称ACID。</p><h3 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h3><ul><li>赃读：一个事务读到另外一个事务还没有提交的数据。</li></ul><p><img src="/../mysql_pic/37.png"></p><ul><li>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</li></ul><p><img src="/../mysql_pic/38.png"></p><p>事务A两次读取同一条记录，但是读取到的数据却是不一样的.</p><ul><li>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 “幻影”</li></ul><p><img src="/../mysql_pic/39.png"></p><p>为什么会出现幻读？因为已经解决了上面的不可重复度，所以两次查询的结果是一样的，误以为没有数据，其实事务B已经插入了。</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：</p><p><img src="/../mysql_pic/40.png"></p><ul><li>查看事务隔离级别</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">SELECT</span> @<span class="hljs-symbol">@TRANSACTION_ISOLATION</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>设置事务隔离级别</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SET</span> [ <span class="hljs-keyword">SESSION</span> | <span class="hljs-keyword">GLOBAL</span> ] <span class="hljs-keyword">TRANSACTION</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> &#123; <span class="hljs-keyword">READ</span> <span class="hljs-keyword">UNCOMMITTED</span> |<br><span class="hljs-keyword">READ</span> <span class="hljs-keyword">COMMITTED</span> | <span class="hljs-keyword">REPEATABLE</span> <span class="hljs-keyword">READ</span> | <span class="hljs-keyword">SERIALIZABLE</span> &#125;<br></code></pre></td></tr></table></figure><p>事务隔离级别越高，数据越安全，但是性能越低</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是帮助MySQL高效获取数据的数据结构(有序)。</p><p><img src="/../mysql_pic/1.png"></p><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p><strong>聚簇索引（Clustered Index）即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引</strong></p><p>聚簇索引（Clustered Index）一般指的是主键索引（如果存在主键索引的话），聚簇索引也被称之为聚集索引。</p><p>聚簇索引在 InnoDB 中是使用 B+ 树实现的，比如我们创建一张 student 表，它的构建 SQL 如下：</p><p><img src="/../mysql_pic/2.png"></p><p>以上 student 表中有一个聚簇索引（也就是主键索引）id，和一个非聚簇索引 class_id。</p><p>聚簇索引 id 对应的 B+ 树如下图所示：</p><p><img src="/../mysql_pic/3.png"></p><p>在聚簇索引的叶子节点的data区直接存储用户信息的内存地址，我们使用内存地址可以直接找到相应的行数据。</p><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>非聚簇索引在 InnoDB 引擎中，也叫二级索引，以上面 student 表为例，在 student 中非聚簇索引 class_id 对应 B+ 树如下图所示：</p><p><img src="/../mysql_pic/4.png"></p><p>从上图我们可以看出，<strong>在非聚簇索引的叶子节点上的data存储的并不是真正的行数据，而是主键 ID，所以当我们使用非聚簇索引进行查询时，首先会得到一个主键 ID，然后再使用主键 ID 去聚簇索引上找到真正的行数据，我们把这个过程称之为回表查询。</strong></p><p><strong>总结：</strong></p><p>在 MySQL 的 InnoDB 引擎中，每个索引都会对应一颗 B+ 树，而聚簇索引和非聚簇索引最大的区别在于叶子节点存储的数据不同，聚簇索引叶子节点存储的是行数据，因此通过聚簇索引可以直接找到真正的行数据；而非聚簇索引叶子节点存储的是主键信息，所以使用非聚簇索引还需要回表查询，因此我们可以得出聚簇索引和非聚簇索引的区别主要有以下几个：</p><ul><li>聚簇索引叶子节点data存储的是行数据；而非聚簇索引叶子节点data存储的是聚簇索引（通常是主键 ID）。</li><li>聚簇索引查询效率更高，而非聚簇索引需要进行回表查询，因此性能不如聚簇索引。</li><li>聚簇索引一般为主键索引，而主键一个表中只能有一个，因此聚簇索引一个表中也只能有一个，而非聚簇索引则没有数量上的限制。</li></ul><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><h4 id="对索引使用左或者左右模糊匹配"><a href="#对索引使用左或者左右模糊匹配" class="headerlink" title="对索引使用左或者左右模糊匹配"></a>对索引使用左或者左右模糊匹配</h4><p>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效。</p><p>比如下面的 like 语句，查询 name 后缀为「林」的用户，执行计划中的 type&#x3D;ALL 就代表了全表扫描，而没有走索引。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-type">name</span> 字段为二级索引<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%林&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/85.png"></p><p>如果是查询 name 前缀为林的用户，那么就会走索引扫描，执行计划中的 type&#x3D;range 表示走索引扫描，key&#x3D;index_name 看到实际走了 index_name 索引：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-type">name</span> 字段为二级索引<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;林%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/86.png"></p><p><strong>为什么 like 关键字左或者左右模糊匹配无法走索引呢？</strong></p><p><strong>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</strong></p><p>举个例子，下面这张二级索引图是以 name 字段有序排列存储的。</p><p><img src="/../mysql_pic/87.png"></p><p>假设我们要查询 name 字段前缀为「林」的数据，也就是 <code>name like &#39;林%&#39;</code>，扫描索引的过程：</p><ul><li>首节点查询比较：林这个字的拼音大小比首节点的第一个索引值中的陈字大，但是比首节点的第二个索引值中的周字小，所以选择去节点2继续查询；</li><li>节点 2 查询比较：节点2的第一个索引值中的陈字的拼音大小比林字小，所以继续看下一个索引值，发现节点2有与林字前缀匹配的索引值，于是就往叶子节点查询，即叶子节点4；</li><li>节点 4 查询比较：节点4的第一个索引值的前缀符合林字，于是就读取该行数据，接着继续往右匹配，直到匹配不到前缀为林的索引值。</li></ul><p>如果使用 <code>name like &#39;%林&#39;</code> 方式来查询，因为查询的结果可能是「陈林、张林、周林」等之类的，所以不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。</p><h4 id="对索引使用函数"><a href="#对索引使用函数" class="headerlink" title="对索引使用函数"></a>对索引使用函数</h4><p>有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。</p><p>比如下面这条语句查询条件中对 name 字段使用了 LENGTH 函数，执行计划中的 type&#x3D;ALL，代表了全表扫描：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-type">name</span> 为二级索引<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> length(<span class="hljs-type">name</span>)=<span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/88.png"></p><p><code>为什么对索引使用函数，就无法走索引了呢？</code></p><p><strong>因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</strong></p><p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p><p>举个例子，我通过下面这条语句，对 length(name) 的计算结果建立一个名为 idx_name_length 的索引。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t_user <span class="hljs-keyword">add</span> key idx_name_length ((length(<span class="hljs-type">name</span>)));<br></code></pre></td></tr></table></figure><p>然后我再用下面这条查询语句，这时候就会走索引了。</p><p><img src="/../mysql_pic/89.png"></p><h4 id="对索引进行表达式计算"><a href="#对索引进行表达式计算" class="headerlink" title="对索引进行表达式计算"></a>对索引进行表达式计算</h4><p>在查询条件中对索引进行表达式计算，也是无法走索引的。</p><p>比如，下面这条查询语句，执行计划中 type &#x3D; ALL，说明是通过全表扫描的方式查询数据的：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id + <span class="hljs-number">1</span> = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>但是，如果把查询语句的条件改成 where id &#x3D; 10 - 1，这样就不是在索引字段进行表达式计算了，于是就可以走索引查询了。</p><p><code>为什么对索引进行表达式计算，就无法走索引了呢？</code></p><p>原因跟对索引使用函数差不多。</p><p>因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。</p><h4 id="对索引隐式类型转换"><a href="#对索引隐式类型转换" class="headerlink" title="对索引隐式类型转换"></a>对索引隐式类型转换</h4><p>如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。</p><p>我在原本的 t_user 表增加了 phone 字段，是二级索引且类型是 varchar。</p><p><img src="/../mysql_pic/90.png"></p><p>然后我在条件查询中，用整型作为输入参数，此时执行计划中 type &#x3D; ALL，所以是通过全表扫描来查询数据的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">select * from t_user where phone = 1300000001;<br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/91.png"></p><p><strong>但是如果索引字段是整型类型，查询条件中的输入参数即使字符串，是不会导致索引失效，还是可以走索引扫描。</strong></p><p>我们再看第二个例子，id 是整型，但是下面这条语句还是走了索引扫描的。</p><p><img src="/../mysql_pic/92.png"></p><p><code>为什么第一个例子会导致索引失效，而第二例子不会呢？</code></p><p>要明白这个原因，首先我们要知道 MySQL 的数据类型转换规则是什么？就是看 MySQL 是会将字符串转成数字处理，还是将数字转换成字符串处理。</p><p>我在看《mysql45讲的时候》看到一个简单的测试方式，就是通过 select “10” &gt; 9 的结果来知道MySQL 的数据类型转换规则是什么：</p><ul><li>如果规则是 MySQL 会将自动「字符串」转换成「数字」，就相当于 select 10 &gt; 9，这个就是数字比较，所以结果应该是 1；</li><li>如果规则是 MySQL 会将自动「数字」转换成「字符串」，就相当于 select “10” &gt; “9”，这个是字符串比较，字符串比较大小是逐位从高位到低位逐个比较（按ascii码） ，那么”10”字符串相当于 “1”和“0”字符的组合，所以先是拿 “1” 字符和 “9” 字符比较，因为 “1” 字符比 “9” 字符小，所以结果应该是 0。</li></ul><p>在 MySQL 中，执行的结果如下图：</p><p><img src="/../mysql_pic/93.png"></p><p>上面的结果为 1，说明 <strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong>。</p><p>前面的例子一中的查询语句，我也跟大家说了是会走全表扫描：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//例子一的查询语句</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> phone = <span class="hljs-number">1300000001</span>;<br></code></pre></td></tr></table></figure><p>这是因为 phone 字段为字符串，所以 MySQL 要会自动把字符串转为数字，所以这条语句相当于：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> CAST(phone <span class="hljs-keyword">AS</span> signed <span class="hljs-type">int</span>) = <span class="hljs-number">1300000001</span>;<br></code></pre></td></tr></table></figure><p>可以看到，<strong>CAST 函数是作用在了 phone 字段，而 phone 字段是索引，也就是对索引使用了函数！而前面我们也说了，对索引使用函数是会导致索引失效的</strong>。</p><p>例子二中的查询语句，我跟大家说了是会走索引扫描：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//例子二的查询语句</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id = <span class="hljs-string">&quot;1&quot;</span>;<br></code></pre></td></tr></table></figure><p>这时因为字符串部分是输入参数，也就需要将字符串转为数字，所以这条语句相当于：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id = CAST(&quot;1&quot; <span class="hljs-keyword">AS</span> signed <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><p>可以看到，索引字段并没有用任何函数，CAST 函数是用在了输入参数，因此是可以走索引扫描的</p><h4 id="联合索引非最左匹配"><a href="#联合索引非最左匹配" class="headerlink" title="联合索引非最左匹配"></a>联合索引非最左匹配</h4><p>对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。</p><p>那么<strong>多个普通字段组合在一起创建的索引就叫做联合索引</strong>，也叫组合索引。</p><p>创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。</p><p>联合索引要能正确使用需要遵循<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。</p><p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p><ul><li>where a&#x3D;1；</li><li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li><li>where a&#x3D;1 and b&#x3D;2；</li></ul><p><strong>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</strong></p><p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p><ul><li>where b&#x3D;2；</li><li>where c&#x3D;3；</li><li>where b&#x3D;2 and c&#x3D;3；</li></ul><p>有一个比较特殊的查询条件：where a &#x3D; 1 and c &#x3D; 3 ，符合最左匹配吗？</p><p>MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。</p><p>从 MySQL 5.6 之后，有一个<strong>索引下推功能</strong>，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。</p><p>索引下推的大概原理是：截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 <code>(a, b, c)</code> 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。</p><p>比如下面这条 where a &#x3D; 1 and c &#x3D; 0 语句，我们可以从执行计划中的 Extra&#x3D;Using index condition 使用了索引下推功能。</p><p><img src="/../mysql_pic/94.png"></p><p><code>为什么联合索引不遵循最左匹配原则就会失效？</code></p><p>原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</p><p>也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。</p><h4 id="WHERE-子句中的-OR"><a href="#WHERE-子句中的-OR" class="headerlink" title="WHERE 子句中的 OR"></a>WHERE 子句中的 OR</h4><p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p><p>举个例子，比如下面的查询语句，id 是主键，age 是普通列，从执行计划的结果看，是走了全表扫描。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">select * from t_user where id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> or age <span class="hljs-operator">=</span> <span class="hljs-number">18</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/95.png"></p><p>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</p><p>要解决办法很简单，将 age 字段设置为索引即可。</p><p><img src="/../mysql_pic/96.png"></p><p>可以看到 type&#x3D;index merge， index merge 的意思就是对 id 和 age 分别进行了扫描，然后将这两个结果集进行了合并，这样做的好处就是避免了全表扫描</p><p><strong>总结</strong></p><p>今天给大家介绍了 6 种会发生索引失效的情况：</p><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li><li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;tom&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;cat&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;jerry&#x27;</span>);<br>.....<br></code></pre></td></tr></table></figure><ul><li>优化方案一</li></ul><p><strong>批量插入数据</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">Insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>优化方案二</li></ul><p><strong>手动控制事务</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">begine;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">7</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><ul><li>优化方案三</li></ul><p>主键顺序插入，性能要高于乱序插入。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">主键乱序插入 :<span class="hljs-number"> 8 </span>1<span class="hljs-number"> 9 </span>21<span class="hljs-number"> 88 </span>2<span class="hljs-number"> 4 </span>15<span class="hljs-number"> 89 </span>5<span class="hljs-number"> 7 </span>3<br>主键顺序插入 :<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 5 </span>7<span class="hljs-number"> 8 </span>9<span class="hljs-number"> 15 </span>21<span class="hljs-number"> 88 </span>89<br></code></pre></td></tr></table></figure><h4 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h4><p>如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使 用MySQL数据库提供的load指令进行插入。操作如下：</p><p><img src="/../mysql_pic/61.png"></p><p>可以执行如下指令，将数据脚本文件中的数据加载到表结构中：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 客户端连接服务端时，加上参数 -–local-infile</span><br>mysql –-<span class="hljs-keyword">local</span>-infile -u root -p<br><br><span class="hljs-comment">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> local_infile = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">-- 执行load指令将准备好的数据，加载到表结构中</span><br><span class="hljs-keyword">load</span> data <span class="hljs-keyword">local</span> infile <span class="hljs-string">&#x27;/root/sql1.log&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> tb_user fields<br>terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;,&#x27;</span> lines terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\n&#x27;</span> ;<br></code></pre></td></tr></table></figure><p><code>主键顺序插入性能高于乱序插入</code></p><p>演示：</p><ul><li>创建表结构</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`tb_user`</span> (<br><span class="hljs-symbol">`id`</span> INT(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,<br><span class="hljs-symbol">`username`</span> VARCHAR(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br><span class="hljs-symbol">`password`</span> VARCHAR(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br><span class="hljs-symbol">`name`</span> VARCHAR(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br><span class="hljs-symbol">`birthday`</span> DATE DEFAULT <span class="hljs-literal">NULL</span>,<br><span class="hljs-symbol">`sex`</span> CHAR(<span class="hljs-number">1</span>) DEFAULT <span class="hljs-literal">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>),<br><span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`unique_user_username`</span> (<span class="hljs-symbol">`username`</span>)<br>) ENGINE=INNODB DEFAULT CHARSET=utf8 ;<br></code></pre></td></tr></table></figure><ul><li>设置参数</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">-- 客户端连接服务端时，加上参数 -–<span class="hljs-keyword">local</span>-<span class="hljs-keyword">infile</span><br>mysql –-<span class="hljs-keyword">local</span>-<span class="hljs-keyword">infile</span> -<span class="hljs-keyword">u</span> root -p<br><br>-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> local_infile = 1;<br></code></pre></td></tr></table></figure><ul><li>load加载数据</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">load</span> data <span class="hljs-keyword">local</span> infile <span class="hljs-string">&#x27;/root/load_user_100w_sort.sql&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> tb_user<br>fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;,&#x27;</span> lines terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\n&#x27;</span> ;<br></code></pre></td></tr></table></figure><p>我们看到，插入100w的记录，17s就完成了，性能很好。</p><p><code>在load时，主键顺序插入性能高于乱序插入</code></p><h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p>在上一小节，我们提到，主键顺序插入的性能是要高于乱序插入的。 这一小节，就来介绍一下具体的 原因，然后再分析一下主键又该如何设计。</p><ul><li>数据组织方式</li></ul><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表 (index organized table IOT)。</p><p><img src="/../mysql_pic/62.png"></p><p>行数据，都是存储在聚集索引的叶子节点上的。而我们之前也讲解过InnoDB的逻辑结构图：</p><p><img src="/../mysql_pic/63.png"></p><p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。 那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储 到下一个页中，页与页之间会通过指针连接。</p><h4 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h4><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行 溢出)，根据主键排列。</p><p> 主键顺序插入效果：</p><ul><li>从磁盘中申请页， 主键顺序插入</li></ul><p><img src="/../mysql_pic/64.png"></p><ul><li>第一个页没有满，继续往第一页插入</li></ul><p><img src="/../mysql_pic/65.png"></p><ul><li>当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</li></ul><p><img src="/../mysql_pic/66.png"></p><ul><li>当第二页写满了，再往第三页写入</li></ul><p><img src="/../mysql_pic/67.png"></p><p>主键乱序插入效果：</p><ul><li>加入1#,2#页都已经写满了，存放了如图所示的数据</li></ul><p><img src="/../mysql_pic/68.png"></p><ul><li>此时再插入id为50的记录，我们来看看会发生什么现象</li></ul><p>会再次开启一个页，写入新的页中吗？</p><p><img src="/../mysql_pic/69.png"></p><p>不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在47之后。</p><p><img src="/../mysql_pic/70.png"></p><p>但是47所在的1#页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 3#。</p><p><img src="/../mysql_pic/71.png"></p><p>上述的这种现象，称之为 “页分裂”，是比较耗费性能的操作。</p><h4 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h4><p>目前表中已有数据的索引结构(叶子节点)如下：</p><p><img src="/../mysql_pic/72.png"></p><p>当我们对已有数据进行删除时，具体的效果如下:</p><p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间 变得允许被其他记录声明使用。</p><p><img src="/../mysql_pic/73.png"></p><p>当我们继续删除2#的数据记录</p><p><img src="/../mysql_pic/74.png"></p><p>这个里面所发生的合并页的这个现象，就称之为 “页合并”。</p><p><code>知识小贴士： MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</code></p><h4 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h4><ul><li>满足业务需求的情况下，尽量降低主键的长度</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li><li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li><li>业务操作时，避免对主键的修改。</li></ul><h3 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h3><p>MySQL的排序，有两种方式(explain分析时看extra字段)：</p><ul><li>Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</li><li>Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要 额外排序，操作效率高。</li></ul><p>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序 操作时，尽量要优化为 Using index。</p><p>接下来，我们来做一个测试：</p><ul><li>数据准备</li></ul><p>把之前测试时，为tb_user表所建立的部分索引直接删除掉</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_user_phone <span class="hljs-keyword">on</span> tb_user;<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_user_phone_name <span class="hljs-keyword">on</span> tb_user;<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_user_name <span class="hljs-keyword">on</span> tb_user;<br></code></pre></td></tr></table></figure><ul><li>执行排序SQL</li></ul><p>explain select id,age,phone from tb_user order by age ;</p><p><img src="/../mysql_pic/75.png"></p><p>explain select id,age,phone from tb_user order by age, phone ;</p><p><img src="/../mysql_pic/76.png"></p><p>由于 age, phone 都没有索引，所以此时再排序时，出现Using filesort， 排序性能较低。</p><ul><li>创建索引</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 创建索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_user_age_phone_aa <span class="hljs-keyword">on</span> tb_user(age,phone);<br></code></pre></td></tr></table></figure><ul><li>创建索引后，根据age, phone进行升序排序</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age;<br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/77.png"></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age , phone;<br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/77.png"></p><p>建立索引之后，再次进行排序查询，就由原来的Using filesort， 变为了 Using index，性能 就是比较高的了。</p><p>E. 创建索引后，根据age, phone进行降序排序</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">desc</span> , phone <span class="hljs-keyword">desc</span> ;<br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/78.png"></p><p>也出现 Using index， 但是此时Extra中出现了 Backward index scan，这个代表反向扫描索 引，因为在MySQL中我们创建的索引，默认索引的叶子节点是从小到大排序的，而此时我们查询排序 时，是从大到小，所以，在扫描时，就是反向扫描，就会出现 Backward index scan。 在 MySQL8版本中，支持降序索引，我们也可以创建降序索引。</p><ul><li>根据phone，age进行升序排序，phone在前，age在后。</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> phone , age;<br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/79.png"></p><p>排序时,也需要满足最左前缀法则,否则也会出现 filesort。因为在创建索引的时候， age是第一个 字段，phone是第二个字段，所以排序时，也就该按照这个顺序来，否则就会出现 Using filesort。</p><ul><li>创建联合索引(age 升序排序，phone 倒序排序)</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_user_age_phone_ad <span class="hljs-keyword">on</span> tb_user(age <span class="hljs-keyword">asc</span> ,phone <span class="hljs-keyword">desc</span>);<br></code></pre></td></tr></table></figure><p>升序&#x2F;降序联合索引结构图示:</p><p><img src="/../mysql_pic/80.png"></p><p><img src="/../mysql_pic/81.png"></p><p>由上述的测试,我们得出order by优化原则:</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li><li>尽量使用覆盖索引。</li><li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）。</li><li>果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)。</li></ul><h3 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h3><p>分组操作，我们主要来看看索引对于分组操作的影响。</p><p>首先我们先将 tb_user 表的索引全部删除掉.</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_user_pro_age_sta <span class="hljs-keyword">on</span> tb_user;<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_email_5 <span class="hljs-keyword">on</span> tb_user;<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_user_age_phone_aa <span class="hljs-keyword">on</span> tb_user;<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_user_age_phone_ad <span class="hljs-keyword">on</span> tb_user;<br></code></pre></td></tr></table></figure><p>接下来，在没有索引的情况下，执行如下SQL，查询执行计划：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> profession , <span class="hljs-built_in">count</span>(*) <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> profession<br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/82.png"></p><p>使用临时表，性能较低</p><p>然后，我们在针对于 profession ， age， status 创建一个联合索引。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">create index idx_user_pro_age_sta on tb<span class="hljs-constructor">_user(<span class="hljs-params">profession</span> , <span class="hljs-params">age</span> , <span class="hljs-params">status</span>)</span>;<br></code></pre></td></tr></table></figure><p>紧接着，再执行前面相同的SQL查看执行计划。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> profession , <span class="hljs-built_in">count</span>(*) <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> profession <br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/83.png"></p><p>我们发现，如果仅仅根据age分组，就会出现 Using temporary ；而如果是 根据 profession,age两个字段同时分组，则不会出现 Using temporary。原因是因为对于分组操作， 在联合索引中，也是符合最左前缀法则的。</p><p>所以，在分组操作中，我们需要通过以下两点进行优化，以提升性能：</p><ul><li>在分组操作时，可以通过索引来提高效率。</li><li>分组操作时，索引的使用也是满足最左前缀法则的。</li></ul><h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h3><p><code>select count(*) from tb_user</code></p><p>在之前的测试中，我们发现，如果数据量很大，在执行count操作时，是非常耗时的。</p><ul><li><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个 数，效率很高； 但是如果是带条件的count，MyISAM也慢。</p></li><li><p>InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出 来，然后累积计数。</p></li></ul><p>如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数 据库进行,但是如果是带条件的count又比较麻烦了)。</p><p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加，最后返回累计值。 用法：count（*）、count（主键）、count（字段）、count（数字）</p><p><img src="/../mysql_pic/84.png"></p><h3 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h3><p>我们主要需要注意一下update语句执行时的注意事项。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span> course <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;javaEE&#x27;</span> <span class="hljs-keyword">where</span> id = <span class="hljs-number">1</span> ;<br></code></pre></td></tr></table></figure><p>当我们在执行删除的SQL语句时，会锁定id为1这一行的数据，然后事务提交之后，行锁释放。</p><p>但是当我们在执行如下SQL时。</p> <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span> course <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;SpringBoot&#x27;</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;PHP&#x27;</span> ;<br></code></pre></td></tr></table></figure><p>当我们开启多个事务，在执行上述的SQL时，我们发现行锁升级为了表锁。 导致该update语句的性能 大大降低</p><p><code>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁 升级为表锁 。</code></p><p><strong>所以我们应该给条件创建索引，不然行锁会升级为表锁，并发性能降低</strong></p><h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p><p>越往后，分页查询效率越低，这就是分页查询的问题所在。</p><p>因为，当在进行分页查询时，如果执行 limit 2000000,10 ，此时需要MySQL排序前2000010 记 录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p><p>优化思路: <strong>一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查 询形式进行优化</strong>。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_sku t , (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_sku <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id<br><span class="hljs-keyword">limit</span> <span class="hljs-number">2000000</span>,<span class="hljs-number">10</span>) a <span class="hljs-keyword">where</span> t.id = a.id;<br></code></pre></td></tr></table></figure><h3 id="平时写SQL时该注意什么？有什么经验可谈？"><a href="#平时写SQL时该注意什么？有什么经验可谈？" class="headerlink" title="平时写SQL时该注意什么？有什么经验可谈？"></a>平时写SQL时该注意什么？有什么经验可谈？</h3><ul><li><p>统计时尽量使用count(*)</p></li><li><p>如果明确查找一条语句，请使用<code>limit 1</code>,因为找到一条符合条件的记录就不会继续查找了</p></li><li><p>避免使用select * ，用到什么字段就具体写什么字段，原因除了select * 查询所有字段会多出网络开销之外，还有更重要的一点就是select * 无法使用覆盖索引。</p></li><li><p>对于使用索引方面</p><ul><li><p>对索引字段做函数操作或者做运算操作，都不能使用上索引。<br>所以针对这一点，除了我们索引的字段不要加函数之外。</p></li><li><p>还要注意一些隐式转换，比如，交易日志表（tradelog），tradeid 的字段类型是 varchar(32)，字段有索引，但是当你执行 <code>select * from tradelog where tradeid=110717;</code>语句，你发现走的还是全索引扫描。这是因为它其实做了类型转换，相当于这么执行<code>mysql&gt; select * from tradelog where  CAST(tradid AS signed int) = 110717;</code>。</p></li><li><p>隐式字符编码转换</p><p>如果两张表使用的编码集不一致，比如一个是utf8mb4，一个是utf8，那么这两个字段连接后，相当于做了一次<code>CONVERT(traideid USING utf8mb4)</code>,这样也用不了索引。其实字符集不同只是条件之一，连接过程中要求在被驱动表的索引字段上加函数操作，是直接导致对被驱动表做全表扫描的原因。</p></li></ul></li><li><p>如果设计到多表查询查询，那么首先应该确定设计哪几张表，然后分析他们之间的连接条件，最后确定查询字段。</p></li></ul><h3 id="MySQL执行计划分析-EXPLAIN"><a href="#MySQL执行计划分析-EXPLAIN" class="headerlink" title="MySQL执行计划分析(EXPLAIN)"></a>MySQL执行计划分析(EXPLAIN)</h3><p>优化 SQL 的第一步应该是读懂 SQL 的执行计划。本篇文章，我们一起来学习下 MySQL <code>EXPLAIN</code> 执行计划相关知识。</p><h4 id="什么是执行计划？"><a href="#什么是执行计划？" class="headerlink" title="什么是执行计划？"></a>什么是执行计划？</h4><p><strong>执行计划</strong> 是指一条 SQL 语句在经过 <strong>MySQL 查询优化器</strong> 的优化会后，具体的执行方式。</p><p>执行计划通常用于 SQL 性能分析、优化等场景。通过 <code>EXPLAIN</code> 的结果，可以了解到如数据表的查询顺序、数据查询操作的操作类型、哪些索引可以被命中、哪些索引实际会命中、每个数据表有多少行记录被查询等信息。</p><h4 id="如何获取执行计划？"><a href="#如何获取执行计划？" class="headerlink" title="如何获取执行计划？"></a>如何获取执行计划？</h4><p>MySQL 为我们提供了 <code>EXPLAIN</code> 命令，来获取执行计划的相关信息。</p><p>需要注意的是，<code>EXPLAIN</code> 语句并不会真的去执行相关的语句，而是通过查询优化器对语句进行分析，找出最优的查询方案，并显示对应的信息。</p><p><code>EXPLAIN</code> 执行计划支持 <code>SELECT</code>、<code>DELETE</code>、<code>INSERT</code>、<code>REPLACE</code> 以及 <code>UPDATE</code> 语句。我们一般多用于分析 <code>SELECT</code> 查询语句，使用起来非常简单，语法如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">EXPLAIN</span> + <span class="hljs-keyword">SELECT</span> 查询语句；<br></code></pre></td></tr></table></figure><p>我们简单来看下一条查询语句的执行计划：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; explain SELECT <span class="hljs-symbol">*</span> FROM dept_emp WHERE emp_no IN (SELECT emp_no FROM dept_emp GROUP BY emp_no HAVING COUNT(emp_no)&gt;1);<br>+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+<br>|<span class="hljs-string"> id </span>|<span class="hljs-string"> select_type </span>|<span class="hljs-string"> table    </span>|<span class="hljs-string"> partitions </span>|<span class="hljs-string"> type  </span>|<span class="hljs-string"> possible_keys   </span>|<span class="hljs-string"> key     </span>|<span class="hljs-string"> key_len </span>|<span class="hljs-string"> ref  </span>|<span class="hljs-string"> rows   </span>|<span class="hljs-string"> filtered </span>|<span class="hljs-string"> Extra       </span>|<br>+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+<br>|<span class="hljs-string">  1 </span>|<span class="hljs-string"> PRIMARY     </span>|<span class="hljs-string"> dept_emp </span>|<span class="hljs-string"> NULL       </span>|<span class="hljs-string"> ALL   </span>|<span class="hljs-string"> NULL            </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string"> NULL </span>|<span class="hljs-string"> 331143 </span>|<span class="hljs-string">   100.00 </span>|<span class="hljs-string"> Using where </span>|<br>|<span class="hljs-string">  2 </span>|<span class="hljs-string"> SUBQUERY    </span>|<span class="hljs-string"> dept_emp </span>|<span class="hljs-string"> NULL       </span>|<span class="hljs-string"> index </span>|<span class="hljs-string"> PRIMARY,dept_no </span>|<span class="hljs-string"> PRIMARY </span>|<span class="hljs-string"> 16      </span>|<span class="hljs-string"> NULL </span>|<span class="hljs-string"> 331143 </span>|<span class="hljs-string">   100.00 </span>|<span class="hljs-string"> Using index </span>|<br>+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+<br><br></code></pre></td></tr></table></figure><p>可以看到，执行计划结果中共有 12 列，各列代表的含义总结如下表：</p><p><img src="/../mysql_pic/97.png"></p><h4 id="如何分析-EXPLAIN-结果？"><a href="#如何分析-EXPLAIN-结果？" class="headerlink" title="如何分析 EXPLAIN 结果？"></a>如何分析 EXPLAIN 结果？</h4><p>为了分析 <code>EXPLAIN</code> 语句的执行结果，我们需要搞懂执行计划中的重要字段。</p><h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>SELECT 标识符，是查询中 SELECT 的序号，用来标识整个查询中 SELELCT 语句的顺序。</p><p>id 如果相同，从上往下依次执行。id 不同，id 值越大，执行优先级越高，如果行引用其他行的并集结果，则该值可以为 NULL.</p><h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h5><p>查询的类型，主要用于区分<strong>普通查询</strong>、<strong>联合查询</strong>、<strong>子查询</strong>等复杂的查询，常见的值有：</p><ul><li><strong>SIMPLE</strong>：简单查询，不包含 UNION 或者子查询。</li><li><strong>PRIMARY</strong>：查询中如果包含子查询或其他部分，外层的 SELECT 将被标记为 PRIMARY。</li><li><strong>SUBQUERY</strong>：子查询中的第一个 SELECT。</li><li><strong>UNION</strong>：在 UNION 语句中，UNION 之后出现的 SELECT。</li><li><strong>DERIVED</strong>：在 FROM 中出现的子查询将被标记为 DERIVED。</li><li><strong>UNION RESULT</strong>：UNION 查询的结果。</li></ul><h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><p>查询用到的表名，每行都有对应的表名，表名除了正常的表之外，也可能是以下列出的值：</p><ul><li><strong><code>&lt;unionM,N&gt;</code></strong> : 本行引用了 id 为 M 和 N 的行的 UNION 结果</li><li><strong><code>&lt;derivedN&gt;</code></strong> : 本行引用了 id 为 N 的表所产生的的派生表结果。派生表有可能产生自 FROM 语句中的子查询。 </li><li><strong><code>&lt;subqueryN&gt;</code></strong> : 本行引用了 id 为 N 的表所产生的的物化子查询结果。</li></ul><h5 id="type（重要）"><a href="#type（重要）" class="headerlink" title="type（重要）"></a>type（重要）</h5><p><strong>查询执行的类型</strong>，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p>常见的几种类型具体含义如下：</p><ul><li><p><strong>system</strong>：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。</p></li><li><p><strong>const</strong>：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。</p></li><li><p><strong>eq_ref</strong>：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。</p></li><li><p><strong>ref</strong>：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</p></li><li><p><strong>index_merge</strong>：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。</p></li><li><p><strong>range</strong>：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。</p></li><li><p><strong>index</strong>：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</p></li><li><p><strong>ALL</strong>：全表扫描。</p></li></ul><h4 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h4><p>possible_keys 列表示 MySQL 执行查询时可能用到的索引。如果这一列为 NULL ，则表示没有可能用到的索引；这种情况下，需要检查 WHERE 语句中所使用的的列，看是否可以通过给这些列中某个或多个添加索引的方法来提高查询性能.</p><h4 id="key（重要）"><a href="#key（重要）" class="headerlink" title="key（重要）"></a>key（重要）</h4><p>key 列表示 MySQL 实际使用到的索引。如果为 NULL，则表示未用到索引。</p><h4 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h4><p>key_len 列表示 MySQL 实际使用的索引的最大长度；当使用到联合索引时，有可能是多个列的长度和。在满足需求的前提下越短越好。如果 key 列显示 NULL ，则 key_len 列也显示 NULL 。</p><h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h4><p>rows 列表示根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。</p><h4 id="Extra（重要）"><a href="#Extra（重要）" class="headerlink" title="Extra（重要）"></a>Extra（重要）</h4><p>这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：</p><ul><li><p><strong>Using filesort</strong>：在排序时使用了外部的索引排序，没有用到表内索引进行排序。</p></li><li><p><strong>Using temporary</strong>：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY</p></li><li><p><strong>Using index</strong>：表明查询使用了覆盖索引，不用回表，查询效率非常高。</p></li><li><p><strong>Using index condition</strong>：表示查询优化器选择使用了索引条件下推这个特性。</p></li><li><p><strong>Using where</strong>：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。</p></li><li><p>**Using join buffer (Block Nested Loop)**：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。</p></li></ul><p>这里提醒下，当 Extra 列包含 Using filesort 或 Using temporary 时，MySQL 的性能可能会存在问题，需要尽可能避免。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、 RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有 效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个 角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ul><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据。</li></ul><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语 句，已经更新操作的事务提交语句都将被阻塞。</p><p>其典型的使用场景是做**全库的逻辑备份(把表转为SQL文件)**，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p><p>为什么全库逻辑备份，就需要加全就锁呢？</p><p>下个单总不能表A库存没扣减，表B多了一条订单记录吧。</p><p><strong>加全局锁语法</strong></p><ul><li>加全局锁</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">flush <span class="hljs-keyword">tables</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">lock</span>;<br></code></pre></td></tr></table></figure><ul><li>数据备份</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">mysqldump -uroot –p1234 <span class="hljs-built_in">itcast</span>(数据库名) &gt; itcast<span class="hljs-selector-class">.sql</span><br></code></pre></td></tr></table></figure><p>也可以利用可视化软件直接备份</p><ul><li>释放锁</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">unlock tables<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>特点</strong></p><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ul><li><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</p></li><li><p>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</p></li></ul><p>在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致 性数据备份。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mysqldump <span class="hljs-comment">--single-transaction -uroot –p123456 itcast &gt; itcast.sql</span><br></code></pre></td></tr></table></figure><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、 InnoDB、BDB等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><ul><li>表锁</li><li>元数据锁（meta data lock，MDL）</li><li>意向锁</li></ul><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><ul><li>表共享读锁（read lock）</li><li>表独占写锁（write lock）</li></ul><p><strong>表锁语法</strong></p><ul><li>加锁：lock tables 表名… read&#x2F;write。</li><li>释放锁：unlock tables &#x2F; 客户端断开连接 。</li></ul><hr><p><strong>特点</strong></p><ul><li>读锁(表共享读锁)</li></ul><p><img src="/../mysql_pic/17.png"></p><p><strong>对指定表加了读锁，不会影响自己和其他客户端的读，但是自己进行DML&#x2F;DDL操作会报错，而其他客户端会阻塞</strong></p><ul><li>写锁(表独占写锁)</li></ul><p><img src="/../mysql_pic/18.png"></p><p><strong>对指定表加了写锁，不会影响自己的读写操作，但是会阻塞其他客户端的读写操作。</strong></p><h4 id="元数据锁-MDL-meta-data-lock"><a href="#元数据锁-MDL-meta-data-lock" class="headerlink" title="元数据锁(MDL,meta data lock)"></a>元数据锁(MDL,meta data lock)</h4><p>meta data lock , 元数据锁，简写MDL。</p><p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维 护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML(增删改)与 DDL  (Data Definition Language，即数据定义语言，例如建数据库、建表等，都属于数据定义语言)  冲突，保证读写的正确性。</strong></p><p>这里的元数据，大家可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务 时，是不能够修改这张表的表结构的。</p><p>在MySQL5.5中引入了MDL，<strong>当对一张表进行增删改查的时候，加MDL读锁(共享)<strong>；</strong>当对表结构进行变 更操作的时候，加MDL写锁(排他)。</strong></p><p><strong>常见的SQL操作时，所添加的元数据锁：</strong></p><p><img src="/../mysql_pic/19.png"></p><p><img src="/../mysql_pic/20.png"></p><p>可以看到2个客户端交叉执行DML操作是没问题的，因为DML加的是共享锁。</p><p><img src="/../mysql_pic/21.png"></p><p>当左侧执行一个DML语句，右侧执行一个DDL语句时，右侧操作被阻塞，因为DDL加的是DML写锁(与DML读锁互斥)，直到左侧提交事务，右侧才能执行。</p><p>我们可以通过下面的SQL，来查看数据库中的元数据锁的情况：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">select <span class="hljs-keyword">object</span><span class="hljs-number">_</span>type,<span class="hljs-keyword">object</span><span class="hljs-number">_</span>schema,<span class="hljs-keyword">object</span><span class="hljs-number">_n</span>ame,lock<span class="hljs-number">_</span>type,lock<span class="hljs-number">_</span>duration from<br>performance<span class="hljs-number">_</span>schema.metadata<span class="hljs-number">_</span>locks ;<br></code></pre></td></tr></table></figure><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一 下：</p><p><img src="/../mysql_pic/22.png"></p><p>首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。</p><p>当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，它的判断方式是每一行都检查一遍看是否有行锁，效率较低。(加了行锁之后是不能加表锁的)。</p><p><img src="/../mysql_pic/23.png"></p><p>有了意向锁之后 ：</p><p>客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁</p><p><img src="/../mysql_pic/24.png"></p><p>而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而 不用逐行判断行锁情况了。</p><p><img src="/../mysql_pic/25.png"></p><p><strong>介绍</strong></p><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行 数据是否加锁，使用意向锁来减少表锁的检查。</p><p><strong>分类</strong></p><ul><li>意向共享锁(IS): 由语句select … lock in share mode添加 。 与 表锁-共享锁 (read)(读锁)兼容，与表锁-排他锁(write)(写锁)互斥。</li><li>意向排他锁(IX): 由insert、update、delete、select…for update添加 。与表锁共 享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</li></ul><p><code>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</code></p><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><p><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;</code></p><p><img src="/../mysql_pic/26.png"></p><p>当客户端1对某条记录加上行锁并且给全表加上意向共享锁时，客户端2可以对表加上表读锁，但是当客户端2给表加上表写锁时，会阻塞。很好理解，线程1要读某条数据，客户端2也可以读，反正没影响，但是客户端2不能修改这条数据吧，客户端2修改了那我客户端1不是读了错的数据吗？</p><hr><p><img src="/../mysql_pic/27.png"></p><p>当客户端1使用DML语句时，给某条记录加上了行锁并且给全表加上了意向排他锁，此时客户端2无论是加表读锁还是表写锁都会阻塞，这也很好理解，我客户端1要修改某条数据，客户端1还未提交事务，数据还不确定，客户端2读取肯定是错的，那没必要读啊，那客户端2写就更不用说了，我客户端1都还没改完，你客户端2更别想改了(加表写锁)。</p><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p><strong>介绍</strong></p><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的 锁。对于行级锁，主要分为以下三类：</p><ul><li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在 RC、RR隔离级别下都支持。</li></ul><p><img src="/../mysql_pic/28.png"></p><ul><li>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事 务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</li></ul><p><img src="/../mysql_pic/29.png"></p><ul><li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。 在RR隔离级别下支持。</li></ul><p><img src="/../mysql_pic/30.png"></p><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>InnoDB实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li></ul><p>（共享锁与共享锁不冲突，共享锁与排他锁冲突，排他锁与排他锁冲突).</p><ul><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li></ul><p>两种行锁的兼容情况如下:</p><p><img src="/../mysql_pic/31.png"></p><p>常见的SQL语句，在执行时，所加的行锁如下：</p><p><img src="/../mysql_pic/32.png"></p><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁(临键锁)进行搜 索和索引扫描，以防止幻读。</p><ul><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li><li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记 录加锁，此时 就会<strong>升级为表锁</strong>。</li></ul><p><img src="/../mysql_pic/33.png"></p><p>因为行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记 录加锁，此时 就会升级为表锁，name没有索引，所以使用update会加上表锁，客户端2就无法使用更新操作了，会阻塞。</p><p>那么我们给name字段创建一个索引就不会升级为表锁了。create index xxx(名字) on table(name);</p><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="hljs-keyword">from</span><br>performance_schema.data_locks;<br></code></pre></td></tr></table></figure><h4 id="间隙锁-amp-临键锁"><a href="#间隙锁-amp-临键锁" class="headerlink" title="间隙锁&amp;临键锁"></a>间隙锁&amp;临键锁</h4><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜 索和索引扫描，以防止幻读。</p><ul><li>索引上的等值查询(唯一索引)，给<strong>不存在</strong>的记录加锁时, 优化为间隙锁 。</li></ul><p><img src="/../mysql_pic/34.png"></p><p>当给id为5的数据进行修改操作时，表中没有id为5的数据，那么会给id为3与8之间的间隙加间隙锁，当右侧客户端插入一条id为7的数据时，操作被阻塞。</p><ul><li>索引上的等值查询(<strong>非唯一普通索引</strong>)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁(间隙锁唯一的目的是防止其他事务插入间隙，<strong>间隙锁可以共存</strong>，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁)。</li></ul><p><img src="/../mysql_pic/35.png"></p><p>我们知道InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引查询值 为18的数据，并加上共享锁，我们是只锁定18这一行就可以了吗？ 并不是，因为是非唯一索引，这个 结构中可能有多个18的存在(<strong>非唯一普通索引</strong>)，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也 就是29）。此时会对18加临键锁，并对29之前的间隙加锁。</p><ul><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li></ul><p><img src="/../mysql_pic/36.png"></p><p>查询的条件为id&gt;&#x3D;19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部 分：</p><ul><li>[19]</li><li>(19,25]</li><li>(25,+∞]</li></ul><p>所以数据库数据在加锁时，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临 键锁(正无穷及之前的间隙)。</p><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h3><p><img src="/../mysql_pic/5.png"></p><ul><li>表空间</li></ul><p>表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在 8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空 间，用于存储记录、索引等数据。</p><ul><li>段</li></ul><p>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段 （Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的 非叶子节点。段用来管理多个Extent（区）。</p><ul><li>区</li></ul><p>区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一 个区中一共有64个连续的页。</p><ul><li>页</li></ul><p>页，是InnoDB 存储引擎磁盘管理的最小单元，每次查寻是读取一个页的数据到内存中，每个页的大小默认为 16KB。为了保证页的连续性， InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p><ul><li>行</li></ul><p>行，InnoDB 存储引擎数据是按行进行存放的。</p><p>在行中，默认有两个隐藏字段： </p><p>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。 Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个 隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发 中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p><p><img src="/../mysql_pic/6.png"></p><h3 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h3><p>先看左边的内存架构</p><p><img src="/../mysql_pic/7.png"></p><p>在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。 接下来介绍一下这四个部分。</p><ul><li>Buffer pool</li></ul><p>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能 弥补这两者之间的I&#x2F;O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁 盘I&#x2F;O。</p><p>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及 InnoDB的锁信息等等。</p><p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增 删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频 率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p><ul><li><p>free page：空闲page，未被使用。</p></li><li><p>clean page：被使用page，数据没有被修改过。</p></li><li><p>dirty page：脏页，被使用page，数据被修改过，页中数据与磁盘的数据产生了不一致。</p></li><li><p>Change Buffer</p></li></ul><p>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML(增删改)语句时，如果这些数据Page 没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer 中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p><p><img src="/../mysql_pic/9.png"></p><p><img src="/../mysql_pic/10.png"></p><p>先来看一幅图，这个是二级索引的结构图：</p><p><img src="/../mysql_pic/8.png"></p><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新 可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了 Change Buffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p><p>写缓冲区为什么仅适用于非唯一普通索引页？</p><p>如上图所示，如果是唯一索引时，是直接去磁盘加载的数据，并不涉及到change Buffer，理由如下。</p><p>这是因为如果对索引设置唯一性，在进行修改操作时，InnoDB必须要做唯一性校验，因此必须得查询磁盘，做一次IO操作。这样就会直接将记录查询到Buffer Pool中，然后在缓冲池修改，就不会在change Buffer中操作了。</p><ul><li>Adaptive Hash Index</li></ul><p>自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持 hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在 进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需 要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。 InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度， 则建立hash索引，称之为自适应hash索引。 自适应哈希索引，无需人工干预，是系统根据情况自动完成。 参数： adaptive_hash_index</p><ul><li>Log Buffer</li></ul><p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log）， 默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事 务，增加日志缓冲区的大小可以节省磁盘 I&#x2F;O。</p><p>参数: </p><p>innodb_log_buffer_size：缓冲区大小</p><p>innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：</p><p> 1: 日志在每次事务提交时写入并刷新到磁盘，默认值。</p><p> 0: 每秒将日志写入并刷新到磁盘一次。 </p><p>  2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。</p><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><p>再看右边的磁盘结构：</p><p><img src="/../mysql_pic/11.png"></p><ul><li>System TableSpace</li></ul><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建 的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)</p><ul><li>File-Per-Table Tablespaces</li></ul><p>如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索 引 ，并存储在文件系统上的单个数据文件中(xxx.idb)。</p><p>开关参数：innodb_file_per_table ，该参数默认开启。</p><p>那也就是说，我们每创建一个表，都会产生一个表空间文件</p><ul><li>General Tablespaces(了解)</li></ul><p>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空 间。</p><ul><li>Undo Tablespaces</li></ul><p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储 undo log日志。</p><ul><li>Temporary Tablespaces</li></ul><p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p><ul><li>Doublewrite Buffer Files</li></ul><p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件 中，便于系统异常时恢复数据。</p><p><img src="/../mysql_pic/12.png"></p><ul><li>Redo Log</li></ul><p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所 有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。 以循环方式写入Redo Log日志文件，涉及两个文件：</p><p><img src="/../mysql_pic/13.png"></p><h3 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h3><ul><li>事务</li></ul><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><ul><li>特性<ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。(不仅数据要保持一致状态，约束也要保持一致状态)</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环 境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul></li></ul><p>而对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由InnoDB中的 两份日志来保证的，一份是redo log日志，一份是undo log日志。 而持久性是通过数据库的锁， 加上MVCC来保证的。</p><p><img src="/../mysql_pic/14.png"></p><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>redo log是如何保证事务的持久性的呢？</p><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p><p>redo log 是物理日志，记录了某个数据页做了什么修改，比如<strong>对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新</strong>，每当执行一个事务就会产生这样的一条或者多条物理日志。</p><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用 于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><p>脏页：当客户端对buffer pool进行DML时，没有找到相关数据页，buffer pool从磁盘读取相关数据页到buffer pool，再对数据进行修改，此时buffer pool里的数据页和磁盘的数据不一致，这就是脏页。</p><p>如果没有redo log，可能会存在什么问题的？ 我们一起来分析一下。</p><p>我们知道，在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数 据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果 缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中 的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘 中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后 将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却 没有持久化下来，这就出现问题了，没有保证事务的持久性。</p><p><img src="/../mysql_pic/15.png"></p><p>那么，如何解决上述的问题呢？ 在InnoDB中提供了一份日志 redo log，接下来我们再来分析一 下，通过redo log如何解决这个问题。</p><p><img src="/../mysql_pic/16.png"></p><p>有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。在事务提交时，会将redolog buffer中的数据刷新到redo log磁盘文件中。 过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据 恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此 时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的.</p><p>那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新 到磁盘呢 ?</p><p> 因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在 往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这 种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</p><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和 MVCC(多版本并发控制) 。</p><p>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的 update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p><p>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些 日志可能还用于MVCC。</p><p>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个undo log segment。</p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>当前读</li></ul><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加 锁。对于我们日常的操作，如：<strong>select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读</strong>。</p><p><img src="/../mysql_pic/41.png"></p><p>事务1首先查询了一次数据，事务2对表进行了一次修改，事务1再查询，但是数据还是和第一次一样，因为当前的隔离级别是默认的可重复读，第一次和第二次的结果是一样的。</p><p><img src="/../mysql_pic/42.png"></p><p>但是在查询语句后面加上lock in share mode的话就是当前读，数据是最新版本。</p><ul><li>快照读</li></ul><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据， 不加锁，是非阻塞读。</p><ul><li><ul><li>Read Committed：每次select，都生成一个快照读。</li><li>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li><li>Serializable：快照读会退化为当前读。</li></ul></li></ul><h4 id="MVCC基本概念"><a href="#MVCC基本概念" class="headerlink" title="MVCC基本概念"></a>MVCC基本概念</h4><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本， 使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需 要依赖于数据库记录中的<strong>三个隐式字段(也有可能是两个)<strong>、</strong>undo log日志</strong>、<strong>readView</strong>。</p><h5 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h5><p><img src="/../mysql_pic/43.png"></p><p>当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。 实际上除了 这三个字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：</p><p><img src="/../mysql_pic/44.png"></p><p>而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键， 如果有主键，则不会添加该隐藏字段。</p><p>进入服务器中的 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;itcast&#x2F; , 查看stu的表结构信息, 通过如下指令：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ibd2sdi</span> stu.ibd<br></code></pre></td></tr></table></figure><h5 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h5><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p><p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p><p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即 被删除。</p><h5 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h5><p>有一张原始数据为:</p><p><img src="/../mysql_pic/45.png"></p><p><code>DB_TRX_ID : 代表最近修改事务的ID，记录插入这条记录或最后一次修改该记录的事务ID，是 自增的。</code> </p><p><code>DB_ROLL_PTR ：回滚指针，由于这条数据是才插入的，没有被更新过，所以该字段值为null。</code></p><p>然后，有四个并发事务同时在访问这张表。</p><p><strong>第一步</strong></p><p><img src="/../mysql_pic/46.png"></p><p>当事务2执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/../mysql_pic/47.png"></p><p><strong>第二步</strong></p><p><img src="/../mysql_pic/48.png"></p><p>当事务3执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记 录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/../mysql_pic/49.png"></p><p><strong>第三步</strong></p><p><img src="/../mysql_pic/50.png"></p><p>当事务4执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记 录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/../mysql_pic/51.png"></p><p><code>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条 记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</code></p><h5 id="readview"><a href="#readview" class="headerlink" title="readview"></a>readview</h5><p>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务 （未提交的）id。</p><p>ReadView中包含了四个核心字段：</p><ul><li>m_ids  : 当前活跃的事务ID集合</li><li>min_trx_id : 最小活跃事务ID</li><li>max_trx_id : 预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</li><li>creator_trx_id : ReadView创建者的事务ID</li></ul><p>而在readview中就规定了版本链数据的访问规则：</p><p><strong>trx_id 代表当前undolog版本链对应事务ID。</strong></p><p><img src="/../mysql_pic/45.png"></p><p><img src="/../mysql_pic/52.png"></p><p><img src="/../mysql_pic/53.png"></p><p>不同的隔离级别，生成ReadView的时机不同：</p><ul><li>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</li><li>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</li></ul><h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><h6 id="RC隔离级别-读已提交"><a href="#RC隔离级别-读已提交" class="headerlink" title="RC隔离级别(读已提交)"></a>RC隔离级别(读已提交)</h6><p><strong>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</strong></p><p>我们就来分析事务5中，两次快照读读取数据，是如何获取数据的?</p><p>在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读 都会生成一个ReadView，那么两次生成的ReadView如下。</p><p><img src="/../mysql_pic/54.png"></p><p>那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则， 到undolog版本链中匹配数据，最终决定此次快照读返回的数据。</p><ul><li>先来看第一次快照读具体的读取过程：</li></ul><p><img src="/../mysql_pic/55.png"></p><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><ul><li>先匹配最上面这条记录，这条记录对应的 trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ， 都不满足，则继续匹配undo log版本链的下一条。</li><li>再匹配第二条 ，这条 记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②不满足 ③不满足 ④也 不满足 ，都不满足，则继续匹配undo log版本链的下一条。</li><li>再匹配第三条 ，这条记 录对应的trx_id为2，也就是将2带入右侧的匹配规则中。①不满足 ②满足 终止匹配，此次快照 读，返回的数据就是版本链中记录的这条数据。</li></ul><p><strong>本质就是当前事务操作的最早已经提交的事务的数据。</strong></p><hr><p> 再来看第二次快照读具体的读取过程:</p><p>先不看答案，按照上面说的本质，答案应该是事务3修改后的数据。</p><p><img src="/../mysql_pic/56.png"></p><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><ul><li>先匹配最上面 这条记录，这条记录对应的 trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ， 都不满足，则继续匹配undo log版本链的下一条。</li><li>再匹配第二条 ，这条 记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②满足 。终止匹配，此次 快照读，返回的数据就是版本链中记录的这条数据。</li></ul><h6 id="RR隔离级别-可重复读"><a href="#RR隔离级别-可重复读" class="headerlink" title="RR隔离级别(可重复读)"></a>RR隔离级别(可重复读)</h6><p><strong>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可 重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</strong></p><p>那MySQL是如何做到可重复读的呢? 我们简单分析一下就知道了</p><p><img src="/../mysql_pic/57.png"></p><p>我们看到，在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该 ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返 回的结果也是一样的。</p><p>所以呢，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。 而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</p><p><img src="/../mysql_pic/58.png"></p><h2 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h2><p> 主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这 些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。</p><p>MySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状 复制。</p><p><img src="/../mysql_pic/59.png"></p><p>MySQL 复制的优点主要包含以下三个方面：</p><ul><li>主库出现问题，可以快速切换到从库提供服务。</li><li>实现读写分离，降低主库的访问压力。(主库DML,从库DQL)</li><li>可以在从库中执行备份，以避免备份期间影响主库服务。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>MySQL主从复制的核心就是 二进制日志，具体的过程如下：</p><p><img src="/../mysql_pic/60.png"></p><p>从上图来看，复制分成三步：</p><ul><li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li><li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</li><li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2023/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="键入网址到网页显示，期间发生了什么？"><a href="#键入网址到网页显示，期间发生了什么？" class="headerlink" title="键入网址到网页显示，期间发生了什么？"></a>键入网址到网页显示，期间发生了什么？</h1><h2 id="一-浏览器的第一步工作是解析URL"><a href="#一-浏览器的第一步工作是解析URL" class="headerlink" title="一.浏览器的第一步工作是解析URL"></a>一.浏览器的第一步工作是解析URL</h2><p>首先浏览器做的第一步工作就是要对URL进行解析，从而生成发送给Web服务器的请求信息。</p><p><img src="/../Intnet_pic/1.png"></p><p>所以图中的长长的 URL 实际上是请求服务器里的文件资源。</p><p><strong>要是上图中的蓝色部分 URL 元素都省略了，那应该是请求哪个文件呢？</strong></p><p>当没有路径名是，就代表访问目录下事先设置的默认文件，也就是&#x2F;index.html或者&#x2F;default.html这些文件，这样就不会发送混乱了。</p><h2 id="二-生产HTTP请求信息"><a href="#二-生产HTTP请求信息" class="headerlink" title="二.生产HTTP请求信息"></a>二.生产HTTP请求信息</h2><p>对URL进行解析之后，浏览器确定了Web服务器和文件名，接下来就是根据这些信息生成HTTP请求消息了。</p><p><img src="/../Intnet_pic/2.png"></p><p><strong>一个孤单 HTTP 数据包表示：“我这么一个小小的数据包，没亲没友，直接发到浩瀚的网络，谁会知道我呢？谁能载我一程呢？谁能保护我呢？我的目的地在哪呢？”。充满各种疑问的它，没有停滞不前，依然踏上了征途！</strong></p><h2 id="三-真实地址查询——–DNS"><a href="#三-真实地址查询——–DNS" class="headerlink" title="三.真实地址查询——–DNS"></a>三.真实地址查询——–DNS</h2><p>通过浏览器解析URL并生成HTTP消息后，需要委托操作系统将消息发送给Web服务器。</p><p>但在发送之前还有一项工作需要完成，那就是查询服务器域名对应的IP地址，因为委托操作系统发送消息时，必须提供通信对象的IP地址。</p><p>所以有一种服务器专门保存了Web服务器域名与IP的对应关系，他就是<strong>DNS服务器</strong></p><h3 id="域名的层级关系"><a href="#域名的层级关系" class="headerlink" title="域名的层级关系"></a>域名的层级关系</h3><p>DNS中的域名都是用句号来分隔的，比如<a href="http://www.server.com/">www.server.com</a> ,这里的句点代表了不同层次之间的界限。</p><p><strong>在域名中，越靠右的位置表示其层级越高</strong></p><p>实际上域名最后还有一个点，比如<a href="http://www.server.com/">www.server.com</a>.       这最后个点代表根域名</p><p>也就是，<code>.</code> 根域是在最顶层，它的下一层就是 <code>.com</code> 顶级域，再下面是 <code>server.com</code>。</p><p>所以域名的层级关系类似一个树状结构：</p><ul><li>根 DNS 服务器（.）</li><li>顶级域 DNS 服务器（.com）</li><li>权威 DNS 服务器（server.com）</li></ul><p><img src="/../Intnet_pic/3.png"></p><p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。</p><p>这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。</p><p>因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p><h3 id="域名解析的工作流程"><a href="#域名解析的工作流程" class="headerlink" title="域名解析的工作流程"></a>域名解析的工作流程</h3><ol><li>客户端首先会发出一个 DNS 请求，问 <a href="http://www.server.com/">www.server.com</a> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP&#x2F;IP 设置中填写的 DNS 服务器地址）。</li><li>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a href="http://www.server.com,则它直接返回/">www.server.com，则它直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li><li>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“<a href="http://www.server.com/">www.server.com</a> 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</li><li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？”</li><li>顶级域名服务器说：“我给你负责 <a href="http://www.server.com/">www.server.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</li><li>本地 DNS 于是转向问权威 DNS 服务器：“老三，<a href="http://www.server.com对应的IP是啥呀？”">www.server.com对应的IP是啥呀？”</a> server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li></ol><p>至此，我们完成了 DNS 的解析过程。现在总结一下，整个过程我画成了一个图。</p><p><img src="/../Intnet_pic/4.png"></p><h3 id="那是不是每次解析域名都要经过那么多的步骤呢？"><a href="#那是不是每次解析域名都要经过那么多的步骤呢？" class="headerlink" title="那是不是每次解析域名都要经过那么多的步骤呢？"></a>那是不是每次解析域名都要经过那么多的步骤呢？</h3><p>当然不是了，还有缓存这个东西的嘛。</p><p>浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。</p><h3 id="数据包表示：“DNS-老大哥厉害呀，找到了目的地了！我还是很迷茫呀，我要发出去，接下来我需要谁的帮助呢-”"><a href="#数据包表示：“DNS-老大哥厉害呀，找到了目的地了！我还是很迷茫呀，我要发出去，接下来我需要谁的帮助呢-”" class="headerlink" title="数据包表示：“DNS 老大哥厉害呀，找到了目的地了！我还是很迷茫呀，我要发出去，接下来我需要谁的帮助呢?”"></a>数据包表示：“DNS 老大哥厉害呀，找到了目的地了！我还是很迷茫呀，我要发出去，接下来我需要谁的帮助呢?”</h3><h2 id="指南好帮手——协议栈"><a href="#指南好帮手——协议栈" class="headerlink" title="指南好帮手——协议栈"></a>指南好帮手——协议栈</h2><p>通过DNS获取到IP后，就可以把HTTP请求的传输工作交给操作系统中的<strong>协议栈</strong>。</p><p>协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则，上面的部分会向下的部分委托工作，下面的部分收到委托的工作并执行。</p><p><img src="/../Intnet_pic/5.png"></p><p>应用程序(浏览器)通过调用Socket库，来委托协议栈工作。协议栈的上半部分有两块，分别是<strong>TCP</strong>和<strong>UDP</strong>协议，这两个传输协议会接受应用层的委托执行收发数据的操作。</p><p>协议栈的下面一半是用<strong>IP</strong>协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包， 而将网络包发送给对方的操作就是由IP负责的。</p><p>此外IP中还包括<strong>ICMP协议</strong>和<strong>ARP协议</strong>。</p><ul><li><strong>ICMP</strong>用于告知网络包传送过程中产生的错误以及各种控制信息。</li><li><strong>ARP</strong>用于根据IP地址查询相应的以太网MAC地址</li></ul><p>IP下面的网卡驱动程序负责控制网卡硬件，而最下面的物理硬件网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p><h3 id="数据包看了这份指南表示：“原来我需要那么多大佬的协助啊，那我先去找TCP大佬！”"><a href="#数据包看了这份指南表示：“原来我需要那么多大佬的协助啊，那我先去找TCP大佬！”" class="headerlink" title="数据包看了这份指南表示：“原来我需要那么多大佬的协助啊，那我先去找TCP大佬！”"></a>数据包看了这份指南表示：“原来我需要那么多大佬的协助啊，那我先去找TCP大佬！”</h3><h2 id="可靠传输——-TCP"><a href="#可靠传输——-TCP" class="headerlink" title="可靠传输——-TCP"></a>可靠传输——-TCP</h2><p>HTTP是基于TCP协议传输的，所以在这我们先了解TCP协议。</p><h3 id="TCP包头格式"><a href="#TCP包头格式" class="headerlink" title="TCP包头格式"></a>TCP包头格式</h3><p>先看看TCP报文头部格式</p><p><img src="/../Intnet_pic/6.png"></p><p><strong>源端口号</strong>和<strong>目的端口号</strong>是必不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</p><p>接下来的<strong>序号</strong>，这个是为了解决乱码问题。</p><p>还有应该有的是<strong>确认序列</strong>，目的是确认发送出去对方是否有收到。如果没有收到就应该重新发送，直到送到，<strong>确认序列是为了解决丢包问题</strong>。</p><p>接下来还有一些<strong>状态位(第四行蓝色部分)<strong>。例如</strong>SYN</strong>是发起一个连接，<strong>ACK</strong>是回复，<strong>RST</strong>是重新连接，<strong>FIN</strong>是结束连接等。TCP是面向连接的，因而双方要维护连接的状态，这些状态位的包的发送，会引起双方的状态变化。</p><p>还有一个重要的是<strong>窗口大小</strong>。TCP要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送太快也别发送太慢。</p><p>除了做流量控制以外，TCP还会做<strong>拥塞控制</strong>，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。</p><h3 id="TCP传输数据之前，要先三次握手建立连接"><a href="#TCP传输数据之前，要先三次握手建立连接" class="headerlink" title="TCP传输数据之前，要先三次握手建立连接"></a>TCP传输数据之前，要先三次握手建立连接</h3><p>在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为<strong>三次握手</strong>。</p><p>这个所谓的「连接」，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。</p><p><img src="/../Intnet_pic/7.png"></p><ul><li>一开始，客户端和服务端都处于<strong>closed</strong>状态。先是服务端主动监听某个端口，处于<strong>listen</strong>状态。’</li><li>然后客户端主动发起连接<strong>SYN</strong>，之后处于<strong>SYN-SENT</strong>状态。</li><li>服务端收到发起的连接，返回<strong>SYN</strong>，并且<strong>ACK</strong>客户端的<strong>SYN</strong>，之后处于<strong>SYN-REVD</strong>状态，</li><li>客户端收到服务端发送的<strong>SYN</strong>和<strong>ACK</strong>之后，发送对<strong>SYN</strong>确认的<strong>ACK</strong>，之后客户端处于<strong>ESTABLISHED</strong>状态，因为它一发一收成功了。</li><li>服务端收到自己<strong>ACK</strong>的<strong>ACK</strong>之后，处于<strong>ESTABLISHED</strong>状态，因为它也一发一收成功了。</li></ul><p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p><h3 id="如何查看TCP的连接状态？"><a href="#如何查看TCP的连接状态？" class="headerlink" title="如何查看TCP的连接状态？"></a>如何查看TCP的连接状态？</h3><p>TCP的连接状态可以在Linux通过<strong>netstat -napt</strong>命令查看</p><p><img src="/../Intnet_pic/8.png"></p><h3 id="TCP分割数据"><a href="#TCP分割数据" class="headerlink" title="TCP分割数据"></a>TCP分割数据</h3><p>如果HTTP请求消息比较长，超过了<strong>MSS</strong>的长度，这时TCP就需要把HTTP的数据拆解成一块块的数据发送，而不是一次性发送所有数据。</p><p><img src="/../Intnet_pic/9.png"></p><ul><li>MTU：一个网络包的最大长度，以太网中一般位1500字节。</li><li>MSS：除去IP和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度。</li></ul><p>数据会被以<strong>MSS</strong>的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据上加上TCP头信息，然后交给IP模块来发送数据。</p><p><img src="/../Intnet_pic/10.png"></p><h3 id="TCP报文生成"><a href="#TCP报文生成" class="headerlink" title="TCP报文生成"></a>TCP报文生成</h3><p>TCP协议里面会有两个端口，一个是浏览器监听的端口(通常是随机生成)，一个是Web服务器监听的端口(HTTP默认端口号是80，HTTPS默认端口号是443).</p><p>双方建立连接之后，TCP报文中的数据部分就是存放HTTP头部+数据，组装好TCP报文之后，就需要交给下面的网络层处理。</p><p>至此，网络包的报文如下图。</p><p><img src="/../Intnet_pic/11.png"></p><p><strong>此时，遇上了 TCP 的 数据包激动表示：“太好了，碰到了可靠传输的 TCP 传输，它给我加上 TCP 头部，我不再孤单了，安全感十足啊！有大佬可以保护我的可靠送达！但我应该往哪走呢？”</strong></p><h2 id="远程定位—-IP"><a href="#远程定位—-IP" class="headerlink" title="远程定位—-IP"></a>远程定位—-IP</h2><p>TCP模块在执行连接，收发，断开等各阶段操作时，都需要委托IP模块将数据封装成<strong>网络包</strong>发送给通信对象</p><h3 id="IP包格式"><a href="#IP包格式" class="headerlink" title="IP包格式"></a>IP包格式</h3><p><img src="/../Intnet_pic/12.png"></p><p>在IP协议里面需要有<strong>源地址IP</strong>和<strong>目的地址IP</strong>：</p><ul><li>源地址IP，即是客户端输出的IP地址；</li><li>目标地址，即通过DNS域名解析得到的Web服务器IP。</li></ul><p>因为HTTP是经过TCP传输的，所以在IP包头的协议号要填写为06（十六进制），表示为TCP协议。</p><h3 id="假设客户端有多个网卡，就会有多个IP地址，那IP头部的源地址应该选择哪个呢？"><a href="#假设客户端有多个网卡，就会有多个IP地址，那IP头部的源地址应该选择哪个呢？" class="headerlink" title="假设客户端有多个网卡，就会有多个IP地址，那IP头部的源地址应该选择哪个呢？"></a>假设客户端有多个网卡，就会有多个IP地址，那IP头部的源地址应该选择哪个呢？</h3><p>当存在多个网卡，在填写源地址IP时，就需要判断应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪一个网卡来发送包。</p><p>这个时候就需要根据<strong>路由表</strong>规则，来判断哪一个网卡作为源地址IP。</p><p>在Linux操作系统中，我们可以使用<strong>route -n</strong>查看当前系统的路由表。</p><p><img src="/../Intnet_pic/13.png"></p><p>举个例子，根据上面的路由表，我们假设 Web 服务器的目标地址是 <code>192.168.10.200</code>。</p><p><img src="/../Intnet_pic/14.png"></p><ol><li>首先先和第一条目的子网掩码（<code>Genmask</code>）进行 <strong>与运算</strong>，得到结果为 <code>192.168.10.0</code>，但是第一个条目的 <code>Destination</code> 是 <code>192.168.3.0</code>，两者不一致所以匹配失败。</li><li>再与第二条目的子网掩码进行 <strong>与运算</strong>，得到的结果为 <code>192.168.10.0</code>，与第二条目的 <code>Destination 192.168.10.0</code> 匹配成功，所以将使用 <code>eth1</code> 网卡的 IP 地址作为 IP 包头的源地址。</li></ol><p>那么假设 Web 服务器的目标地址是 <code>10.100.20.100</code>，那么依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。</p><p>第三条目比较特殊，它目标地址和子网掩码都是 <code>0.0.0.0</code>，这表示<strong>默认网关</strong>，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，<code>Gateway</code> 即是路由器的 IP 地址。</p><h3 id="IP报文生成"><a href="#IP报文生成" class="headerlink" title="IP报文生成"></a>IP报文生成</h3><p>至此，网络包的报文如下图。</p><p><img src="/../Intnet_pic/15.png"></p><p><strong>此时，加上了 IP 头部的数据包表示 ：“有 IP 大佬给我指路了，感谢 IP 层给我加上了 IP 包头，让我有了远程定位的能力！不会害怕在浩瀚的互联网迷茫了！可是目的地好远啊，我下一站应该去哪呢？”</strong></p><h3 id="两点传输——-MAC"><a href="#两点传输——-MAC" class="headerlink" title="两点传输——-MAC"></a>两点传输——-MAC</h3><p>生成了IP头部之后，接下来网络包还需要在IP头部的前面加上<strong>MAC头部</strong></p><h3 id="MAC包头信息"><a href="#MAC包头信息" class="headerlink" title="MAC包头信息"></a>MAC包头信息</h3><p>MAC头部是以太网使用的头部，它包含了接收方和发送方的MAC地址等信息。</p><p><img src="/../Intnet_pic/16.png"></p><p>在 MAC 包头里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>。</p><p>一般在 TCP&#x2F;IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p><ul><li><code>0800</code> ： IP 协议</li><li><code>0806</code> ： ARP 协议</li></ul><p>ARP：地址解析协议，即ARP（Address Resolution Protocol），是根据<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80?fromModule=lemma_inlink">IP地址</a>获取<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/2129?fromModule=lemma_inlink">物理地址</a>的一个<a href="https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE?fromModule=lemma_inlink">TCP&#x2F;IP协议</a>。</p><h3 id="MAC-发送方和接收方如何确认"><a href="#MAC-发送方和接收方如何确认" class="headerlink" title="MAC 发送方和接收方如何确认?"></a>MAC 发送方和接收方如何确认?</h3><p><strong>发送方</strong>的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。</p><p><strong>接收方</strong>的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。</p><h2 id="TCP超时重传"><a href="#TCP超时重传" class="headerlink" title="TCP超时重传"></a>TCP超时重传</h2><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230619161935569.png" alt="image-20230619161935569"></p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230619161956519.png" alt="image-20230619161956519"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2023/03/20/RabbitMQ/"/>
    <url>/2023/03/20/RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h2 id="1-1-MQ概述"><a href="#1-1-MQ概述" class="headerlink" title="1.1 MQ概述"></a>1.1 MQ概述</h2><p>MQ全称 Message Queue(消息队列)，是在消息传输的过程中保存消息的容器。多用于分布式系统之间进行通信</p><p><img src="/../mq_pic/1.png"></p><ul><li>MQ,消息队列，储存消息的中间件</li><li>分布式系统通信有两种方式：<strong>直接远程调用</strong>和<strong>借助第三方完成间接通信</strong>(MQ)</li><li>发送方称为生产者，接收方称为消费者</li></ul><p>参照：<a href="https://developer.aliyun.com/article/769883">超详细的RabbitMQ入门，看这篇就够了！-阿里云开发者社区 (aliyun.com)</a></p><h2 id="1-2-MQ的优势"><a href="#1-2-MQ的优势" class="headerlink" title="1.2 MQ的优势"></a>1.2 MQ的优势</h2><p><strong>优势：</strong></p><ul><li><strong>应用解耦</strong></li><li><strong>异步提速</strong></li><li><strong>削峰填谷</strong></li></ul><p><strong>劣势</strong>：</p><ul><li><strong>系统可用性降低</strong></li><li><strong>系统复杂性提高</strong></li><li><strong>一致性问题</strong></li></ul><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p>不使用MQ：</p><p><img src="/../mq_pic/2.png"></p><p><strong>系统的耦合性越高，容错性越低，可维护性就越低</strong></p><p>一个模块的服务失败，那么整个服务流程都将失败，容错性低。</p><p>如果还要增加X模块,Y模块的话，还需修改订单系统的代码，耦合性太高，不方便维护。</p><p>使用MQ：</p><p><img src="/../mq_pic/3.png"></p><p>订单系统发出消息给MQ，返回下单成功，那么用户体验会很好，不再管理后续服务是否成功。</p><p>如果一个服务模块失败了，那么这个模块一定时间后恢复正常会重新取得消息，完成服务，容错性提高了。</p><p>如果还要增加服务模块的话，无需修改订单系统的代码，直接增加模块获取MQ信息，可维护性提高。</p><h3 id="异步提速"><a href="#异步提速" class="headerlink" title="异步提速"></a>异步提速</h3><p>不使用MQ：</p><p><img src="/../mq_pic/4.png"></p><p>订单系统与各服务模块间的调用是同步的，总耗费时间是300+300+300+20&#x3D;920ms</p><p>用户点击完成下单按钮后，需要等待920ms才能得到下单响应，太慢，用户体验差。</p><p>使用MQ：</p><p><img src="/../mq_pic/5.png"></p><p>用户点击完成下单按钮后，只需得到25ms(20+5)就能得到下单响应。</p><p>提升用户体验和系统吞吐量(单位时间内处理请求的数目)。</p><h3 id="削谷填峰"><a href="#削谷填峰" class="headerlink" title="削谷填峰"></a>削谷填峰</h3><p>不使用rabbitmq:</p><p><img src="/../mq_pic/6.png"></p><p>无法承受那么高的访问量，宕机。</p><p>使用rabbitmq:</p><p><img src="/../mq_pic/7.png"></p><p><img src="/../mq_pic/8.png"></p><h2 id="1-4MQ的劣势"><a href="#1-4MQ的劣势" class="headerlink" title="1.4MQ的劣势"></a>1.4MQ的劣势</h2><p><img src="/../mq_pic/9.png"></p><h3 id="MQ的几个常见问题"><a href="#MQ的几个常见问题" class="headerlink" title="MQ的几个常见问题"></a>MQ的几个常见问题</h3><ul><li><p><strong>系统的可用性降低</strong></p><p>系统引入的外部依赖越多，系统稳定性越差。一旦MQ宕机，就会对业务造成影响。如何保证MQ的高可用？</p></li><li><p><strong>系统复杂度提高</strong></p><p>MQ的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过MQ进行异步调用。如何保证消息没有被重复消费？怎么处理消息丢失情况？怎么保证消息传递的顺序性？</p></li><li><p>一致性问题</p><p>A系统处理完业务，通过MQ给B，C, D三个系统发消息数据，如果B系统，C系统处理成功，D系统失败。如何保证消息数据处理的一致性？</p></li></ul><h3 id="MQ的使用场景"><a href="#MQ的使用场景" class="headerlink" title="MQ的使用场景"></a>MQ的使用场景</h3><ul><li>生产者不需要从消费者处获取反馈。引入消息队列之前的直接调用，其接口的返回值应该为空，这才让明明下层的动作还没做完，上层却当成功做完了继续往后走，即所谓异步成为了可能。</li><li>容许短暂不一致性</li><li>解耦，提速，削峰这方面的收益超过了加入MQ，管理MQ这些成本。</li></ul><h2 id="1-5-常见的MQ产品"><a href="#1-5-常见的MQ产品" class="headerlink" title="1.5 常见的MQ产品"></a>1.5 常见的MQ产品</h2><p>RabbitMQ,ActiveMQ,RocketMQ,Kafka.</p><p><img src="/../mq_pic/10.png"></p><h2 id="1-6-AMQP"><a href="#1-6-AMQP" class="headerlink" title="1.6 AMQP"></a>1.6 AMQP</h2><p>AMQP，即Advanced Message Queuing Protocol(高级消息队列协议),一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件同产品，不同的开发语言等条件的限制。类比HTTP。</p><p><img src="/../mq_pic/11.png"></p><h3 id="RabbitMQ基础架构"><a href="#RabbitMQ基础架构" class="headerlink" title="RabbitMQ基础架构"></a>RabbitMQ基础架构</h3><p><img src="/../mq_pic/12.png"></p><h3 id="RabbitMQ的核心概念"><a href="#RabbitMQ的核心概念" class="headerlink" title="RabbitMQ的核心概念"></a>RabbitMQ的核心概念</h3><p><strong>Connection（连接）、Channel（信道）、Exchange（交换机）、Queue（队列）、Virtual host（虚拟主机）</strong></p><p>其中，中间的Broker表示RabbitMQ服务，每个Broker里面至少有一个Virtual host虚拟主机，每个虚拟主机中有自己的Exchange交换机、Queue队列以及Exchange交换机与Queue队列之间的绑定关系Binding。producer（生产者）和consumer（消费者）通过与Broker建立Connection来保持连接，然后在Connection的基础上建立若干Channel信道，用来发送与接收消息。</p><p><strong>Connection（连接）</strong><br>每个producer（生产者）或者consumer（消费者）要通过RabbitMQ发送与消费消息，首先就要与RabbitMQ建立连接，这个连接就是Connection。Connection是一个TCP长连接。</p><p><strong>Channel（信道）</strong><br>Channel是在Connection的基础上建立的虚拟连接，RabbitMQ中大部分的操作都是使用Channel完成的，比如：声明Queue、声明Exchange、发布消息、消费消息等。</p><p>看到此处，你是否有这样一个疑问：既然已经有了Connection，我们完全可以使用Connection完成Channel的工作，为什么还要引入Channel这样一个虚拟连接的概念呢？因为现在的程序都是支持多线程的，如果没有Channel，那么每个线程在访问RabbitMQ时都要建立一个Connection这样的TCP连接，对于操作系统来说，建立和销毁TCP连接是非常大的开销，在系统访问流量高峰时，会严重影响系统性能。</p><p>Channel就是为了解决这种问题，通常情况下，每个线程创建单独的Channel进行通讯，每个Channel都有自己的channel id帮助Broker和客户端识别Channel，所以Channel之间是完全隔离的。</p><p>Connection与Channel之间的关系可以比作光纤电缆，如果把Connection比作一条光纤电缆，那么Channel就相当于是电缆中的一束光纤。</p><p><strong>Virtual host（虚拟主机）</strong></p><p>Virtual host是一个虚拟主机的概念，一个Broker中可以有多个Virtual host，每个Virtual host都有一套自己的Exchange和Queue，同一个Virtual host中的Exchange和Queue不能重名，不同的Virtual host中的Exchange和Queue名字可以一样。这样，不同的用户在访问同一个RabbitMQ Broker时，可以创建自己单独的Virtual host，然后在自己的Virtual host中创建Exchange和Queue，很好地做到了不同用户之间相互隔离的效果。</p><p><strong>Queue（队列）</strong><br>Queue是一个用来存放消息的队列，生产者发送的消息会被放到Queue中，消费者消费消息时也是从Queue中取走消息。</p><p><strong>Exchange（交换机）</strong><br>Exchange是一个比较重要的概念，它是消息到达RabbitMQ的第一站，主要负责根据不同的分发规则将消息分发到不同的Queue，供订阅了相关Queue的消费者消费到指定的消息。那Exchange有哪些分发消息的规则呢？这就要说到Exchange的5种类型了：简单模式，work queues, publish&#x2F;Subscribe发布与订阅模式， Routing路由模式， Topics主题模式 ，RPC远程调用模式(不太算)</p><p><strong>Binding</strong>(绑定)</p><p>exchange和queue之间的虚拟连接，binging中可以包含routing key。Binding信息被保存到exchange中的查询表中，用于message的分发依据。</p><p><strong>Broker</strong></p><p>接收和分发消息的应用，RabbitMQ Server就是Message Broker</p><h2 id="1-7-JMS"><a href="#1-7-JMS" class="headerlink" title="1.7 JMS"></a>1.7 JMS</h2><ul><li>JMS即Java消息服务(JavaMessage Service)应用程序接口，是一个Java平台中关于面向中间件的API。</li><li>JMS是Java EE规范中的一种，类比JDBC。</li><li>很多消息中间件都实现了JMS规范，例如ActiveMQ。RabbitMQ官方没有提供JMS的实现包，但是开源社区有。</li></ul><h2 id="1-8-在linux上安装下载RabbitMQ"><a href="#1-8-在linux上安装下载RabbitMQ" class="headerlink" title="1.8 在linux上安装下载RabbitMQ"></a>1.8 在linux上安装下载RabbitMQ</h2><p>我们在Centos7虚拟机中使用Docker来安装。</p><p>在线拉取镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull rabbitmq:<span class="hljs-number">3</span>-management<br></code></pre></td></tr></table></figure><p>执行下面的命令来运行MQ容器：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker run <span class="hljs-string">\</span><br> -e RABBITMQ_DEFAULT_USER=pjf <span class="hljs-string">\</span><br> -e RABBITMQ_DEFAULT_PASS=<span class="hljs-number">123456</span> <span class="hljs-string">\</span><br> --name mq <span class="hljs-string">\</span><br> --hostname mq1 <span class="hljs-string">\</span><br> -p <span class="hljs-number">15672</span>:<span class="hljs-number">15672</span> <span class="hljs-string">\</span><br> -p <span class="hljs-number">5672</span>:<span class="hljs-number">5672</span> <span class="hljs-string">\</span><br> -d <span class="hljs-string">\</span><br> rabbitmq:<span class="hljs-number">3</span>-management<br></code></pre></td></tr></table></figure><h2 id="1-9-RabbitMQ工作模式"><a href="#1-9-RabbitMQ工作模式" class="headerlink" title="1.9 RabbitMQ工作模式"></a>1.9 RabbitMQ工作模式</h2><h3 id="基本消息队列（BasicQueue）"><a href="#基本消息队列（BasicQueue）" class="headerlink" title="基本消息队列（BasicQueue）"></a>基本消息队列（BasicQueue）</h3><p><img src="/../mq_pic/13.png"></p><ul><li>P：生产者,也就是发送消息的程序</li><li>C：消费者，消息的接收者，会一直等待消息的到来</li><li>queue:消息队列，图中红色的部分，类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中获取消息</li></ul><h3 id="工作消息队列（WorkQueue）"><a href="#工作消息队列（WorkQueue）" class="headerlink" title="工作消息队列（WorkQueue）"></a>工作消息队列（WorkQueue）</h3><p><img src="/../mq_pic/14.png"></p><p>两个或者多个消费者是竞争关系，只有一个可以得到消息</p><p>应用场景:对于任务过重或者任务较多的情况使用工作队列可以提高任务处理的速度</p><p>通过在yml中设置prefetch来控制消费者预取的消息数量（先把消息拿过来，不一定马上处理）</p><h3 id="发布订阅（Publish-Subscribe）"><a href="#发布订阅（Publish-Subscribe）" class="headerlink" title="发布订阅（Publish Subscribe）"></a>发布订阅（Publish Subscribe）</h3><p>发布订阅模式与之前案例的区别就是允许将同一消息发给多个消费者。实现方式是加入了交换机Exchange。</p><p>交换机负责消息路由，而不是存储，路由失败则消息丢失。</p><p><strong>SpringAMQP提供了声明交换机，队列，绑定关系的API</strong></p><p><img src="/../mq_pic/22.png"></p><p>根据交换机类型不同分为三种</p><ul><li>Fanout Exchange:广播</li><li>Direct Exchange:路由</li><li>Topic Exchange:主题</li></ul><p><img src="/../mq_pic/15.png"></p><p>实现思路：</p><p>1.在consumer服务中，利用代码声明队列，交换机，并将两者绑定</p><p>2.在consumer服务中，编写两个消费者方法，分别监听fanout.queue1和fanout.queue2</p><p>3.在publisher中编写测试方法，向it.fanout(交换机)中发送消息</p><p>编写一个配置类，把交换机，队列，绑定关系声明为Bean</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAMQPconfig</span> &#123;<br>    <span class="hljs-comment">//声明交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">FanoutExchange</span> <span class="hljs-title function_">fanoutExchange</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FanoutExchange</span>(<span class="hljs-string">&quot;fanout.exchange&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Queue</span> <span class="hljs-title function_">fanoutQueue1</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;fanout.queue1&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Binding</span> <span class="hljs-title function_">binding1</span>(<span class="hljs-params">FanoutExchange fanoutExchange,Queue fanoutQueue1</span>)&#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-title class_">BindingBuilder</span>.<span class="hljs-title function_">bind</span>(fanoutQueue1).<span class="hljs-title function_">to</span>(fanoutExchange);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Queue</span> <span class="hljs-title function_">fanoutQueue2</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;fanout.queue2&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Binding</span> <span class="hljs-title function_">binding2</span>(<span class="hljs-params">FanoutExchange fanoutExchange,Queue fanoutQueue2</span>)&#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-title class_">BindingBuilder</span>.<span class="hljs-title function_">bind</span>(fanoutQueue2).<span class="hljs-title function_">to</span>(fanoutExchange);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript">监听<br><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">&quot;fanout.queue1&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">fanoutlistener1</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> msg</span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;fanout.queue1收到消息队列得消息:&quot;</span>+msg);<br>    &#125;<br>    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">&quot;fanout.queue2&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">fanoutlistener2</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> msg</span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;fanout.queue2收到消息队列得消息:&quot;</span>+msg);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript">发送消息<br><span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">fanoutsend</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-title class_">String</span> fanoutName =<span class="hljs-string">&quot;fanout.exchange&quot;</span>;<br>       <span class="hljs-title class_">String</span> msg =<span class="hljs-string">&quot;hello,fanout!!&quot;</span>;<br>       rabbitTemplate.<span class="hljs-title function_">convertAndSend</span>(fanoutName,<span class="hljs-string">&quot;&quot;</span>,msg);<br>   &#125;<br></code></pre></td></tr></table></figure><p><img src="/../mq_pic/16.png"></p><p><img src="/../mq_pic/17.png"></p><p>发现用Bean声明队列，交换机和绑定太麻烦</p><p>可以使用@RabbitListener注解声明队列，交换机和绑定</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RabbitListener</span>(bindings = <span class="hljs-variable">@QueueBinding</span>(<br>            value = <span class="hljs-variable">@Queue</span>(name = <span class="hljs-string">&quot;direct.queue1&quot;</span>),<br>            exchange = <span class="hljs-variable">@Exchange</span>(name = <span class="hljs-string">&quot;it.direct&quot;</span>,type = ExchangeTypes.DIRECT),<br>            key = &#123;<span class="hljs-string">&quot;red&quot;</span>,<span class="hljs-string">&quot;blue&quot;</span>&#125;<br>    ))<br>public void <span class="hljs-built_in">directlistener1</span>(String msg)&#123;<br>       <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;direct.queue1收到消息队列得消息:&quot;</span>+msg);<br>    &#125;<br><br>@<span class="hljs-selector-tag">RabbitListener</span>(bindings = <span class="hljs-variable">@QueueBinding</span>(<br>            value = <span class="hljs-variable">@Queue</span>(name = <span class="hljs-string">&quot;direct.queue2&quot;</span>),<br>            exchange = <span class="hljs-variable">@Exchange</span>(name = <span class="hljs-string">&quot;it.direct&quot;</span>,type = ExchangeTypes.DIRECT),<br>            key = &#123;<span class="hljs-string">&quot;red&quot;</span>,<span class="hljs-string">&quot;yellow&quot;</span>&#125;<br>    ))<br><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">directlistener2</span>(String msg)&#123;<br>        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;direct.queue2收到消息队列得消息:&quot;</span>+msg);<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到it.direct已经被创建，并且绑定了2个队列，各有2个Routinkey</p><p><img src="/../mq_pic/23.png"></p><p><img src="/../mq_pic/24.png"></p><p><img src="/../mq_pic/18.png"></p><p><img src="/../mq_pic/19.png"></p><p>TopicExchange与DirectExchange类似，区别在于routingkey必须是多个单词的列表，并且以 “.”分割、eg:china.news     china.weather</p><p><strong>TopicExchange指定BingdingKey时可以指定通配符</strong></p><ul><li>‘**’符号：有且只匹配一个词。比如 a.*可以匹配到”a.b”、”a.c”，但是匹配不了”a.b.c”。</li><li>#符号：匹配一个或多个词。比如”rabbit.#”既可以匹配到”rabbit.a.b”、”rabbit.a”，也可以匹配到”rabbit.a.b.c”。</li></ul><p>TopicExchange与DirectExchange代码几乎一样，只有routingkey是包含通配符的，交换机类型是Topic的。</p><h2 id="生产者与消费者流程"><a href="#生产者与消费者流程" class="headerlink" title="生产者与消费者流程"></a>生产者与消费者流程</h2><p><strong>生产者：</strong></p><p>1.建立Connection</p><p>2.创建channel</p><p>3.利用channel声明队列</p><p>4.利用channel向队列发送消息</p><p><strong>消费者：</strong></p><p>1.建立Connection</p><p>2.创建channel</p><p>3.利用channel声明队列</p><p>4.定义consumer的消费行为handleDelivery()</p><p>5.利用channel将消费者与队列绑定</p><h2 id="2-0-SpringAMQP"><a href="#2-0-SpringAMQP" class="headerlink" title="2.0 SpringAMQP"></a>2.0 SpringAMQP</h2><p><img src="/../mq_pic/20.png"></p><p><img src="/../mq_pic/21.png"></p><p>传统的利用AMQP代码复杂，所以用SpringAMQP简化开发</p><h2 id="利用SpringAMQP完成简单通信"><a href="#利用SpringAMQP完成简单通信" class="headerlink" title="利用SpringAMQP完成简单通信"></a>利用SpringAMQP完成简单通信</h2><h3 id="1-引入AMQP依赖"><a href="#1-引入AMQP依赖" class="headerlink" title="1.引入AMQP依赖"></a>1.引入AMQP依赖</h3><p>因为publisher和consumer服务都需要amqp依赖，因此这里把依赖直接放到父工程中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-在publisher中编写测试方法，向消息队列中发送信息"><a href="#2-在publisher中编写测试方法，向消息队列中发送信息" class="headerlink" title="2.在publisher中编写测试方法，向消息队列中发送信息"></a>2.在publisher中编写测试方法，向消息队列中发送信息</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.234</span><span class="hljs-number">.132</span> <span class="hljs-comment"># rabbitMQ的ip地址</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">pjf</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br></code></pre></td></tr></table></figure><h3 id="3-编写生产者测试代码"><a href="#3-编写生产者测试代码" class="headerlink" title="3.编写生产者测试代码"></a>3.编写生产者测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAMQPTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">springamqpsend</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queuename</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;hello amqp&quot;</span>;<br>        rabbitTemplate.convertAndSend(queuename,msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><p>要先有这个队列才行，没有这个队列的记得创建队列哦</p><p>空队列没有消息的，记得自己创建队列，因为这个不会主动创建队列</p><p><strong>所以得自己去管理界面先创建simple.queue</strong></p><h3 id="4-编写消费者测试代码"><a href="#4-编写消费者测试代码" class="headerlink" title="4. 编写消费者测试代码"></a>4. 编写消费者测试代码</h3><p>同样需要引入依赖，编写配置信息</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAMQPListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">&quot;simple.queue&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">listener</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> msg</span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;收到消息队列得消息&quot;</span>+msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动启动文件后收到消息</p><p>实在太优雅了！！！</p><h2 id="2-1消息转换器"><a href="#2-1消息转换器" class="headerlink" title="2.1消息转换器"></a>2.1消息转换器</h2><p>AMQP原生API发送消息是字节形式，但是SpringAMQP的rabbitTemplate.convertAndSend中的参数是Object类型，</p><p>Spring的对消息对象的处理是由org.springframework.amqp.support.converter.MessageConveter来处理的，默认实现是SimpleMessageConverter,基于JDK的ObjectOutPutStream完成序列化，效率和安全性低。</p><p>解决方法：</p><p>我们在publisher服务中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在生产者服务声明MessageConverter:覆盖原有转换器</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Bean</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title class_">MessageConverter</span> <span class="hljs-title function_">messageConversionException</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>   &#125;<br></code></pre></td></tr></table></figure><p>注意，在生产者和消费者都需要做以上步骤，引依赖和写转换器。</p><h2 id="3-0-消息的可靠性投递"><a href="#3-0-消息的可靠性投递" class="headerlink" title="3.0 消息的可靠性投递"></a>3.0 消息的可靠性投递</h2><p>在使用 RabbitMQ 的时候，作为消息发送方希望杜绝任何消息丢失或者投递失败场景。RabbitMQ 为我们提 供了两种方式用来控制消息的投递可靠性模式。</p><ul><li><p>confirm 确认模式 </p></li><li><p>return 退回模式</p></li></ul><p><img src="/../mq_pic/25.png"></p><p>大致的流程就是这样，所以要确保消息发送的可靠性，主要从两方面去确认：</p><ul><li><p>消息成功到达 Exchange (依靠confirm 确认模式)</p></li><li><p>消息成功到达 Queue (依靠return 退回模式)</p></li></ul><p>如果能确认这两步，那么我们就可以认为消息发送成功了。</p><ol><li>确认消息到达 Exchange。</li><li>确认消息到达 Queue。</li></ol><p><strong>如何打开confirm 确认模式和return 退回模式呢？</strong></p><p>在 application.properties 中配置开启消息发送方确认机制，如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">spring.rabbitmq.publisher-confirm-type</span>=correlated<br><span class="hljs-attr">spring.rabbitmq.publisher-returns</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="Confirm确认模式"><a href="#Confirm确认模式" class="headerlink" title="Confirm确认模式"></a>Confirm确认模式</h3><p><strong>Confirm确认模式：不管publisher发给exchange是否成功都会调用回调函数confirm</strong></p><p>publisher-confirm-type有三个属性：</p><ol><li>none：表示禁用发布确认模式，默认即此。</li><li>correlated：表示成功发布消息到交换器后会触发的回调方法。</li><li>simple：类似 correlated，并且支持 <code>waitForConfirms()</code> 和 <code>waitForConfirmsOrDie()</code> 方法的调用。</li></ol><p>开启后，我们需要自定义<strong>confirm 确认模式</strong>的回调方法 <strong>confirm</strong>,不管是否成功都会调用</p><p>消费者：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RabbitListener</span>(bindings = <span class="hljs-variable">@QueueBinding</span>(<br>            value = <span class="hljs-variable">@Queue</span>(name = <span class="hljs-string">&quot;simple.queue&quot;</span>),<br>            exchange = <span class="hljs-variable">@Exchange</span>(name = <span class="hljs-string">&quot;comfirm.exchange&quot;</span>,type = ExchangeTypes.DIRECT),<br>            key = &#123;<span class="hljs-string">&quot;confirm&quot;</span>&#125;<br>    ))<br>    public void <span class="hljs-built_in">confirm</span>(String msg)&#123;<br>        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;comfirm.exchange收到消息队列得消息:&quot;</span>+msg);<br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simple</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        rabbitTemplate.setConfirmCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RabbitTemplate</span>.ConfirmCallback() &#123;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 确认</span><br><span class="hljs-comment">             *</span><br><span class="hljs-comment">             * <span class="hljs-doctag">@param</span> correlationData 相关配置数据</span><br><span class="hljs-comment">             * <span class="hljs-doctag">@param</span> b               ack，是否成功</span><br><span class="hljs-comment">             * <span class="hljs-doctag">@param</span> s               失败原因</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-type">boolean</span> b, String s)</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;回调方法confirm被执行了&quot;</span>);<br>                <span class="hljs-keyword">if</span>(b)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;交换机接受消息成功&quot;</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;交换机接受消息失败:&quot;</span>+s);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你好confirm&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">exchange</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;comfirm.exchange&quot;</span>;<br>        rabbitTemplate.convertAndSend(exchange,<span class="hljs-string">&quot;confirm&quot;</span>,msg);<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">回调方法<span class="hljs-keyword">confirm</span>被执行了<br>交换机接受消息成功<br></code></pre></td></tr></table></figure><p>故意改错交换机名字</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">回调方法confirm被执行了<br>交换机接受消息失败:channel error<span class="hljs-punctuation">;</span> protocol <span class="hljs-keyword">method</span>: #<span class="hljs-keyword">method</span>&lt;<span class="hljs-title function_">channel</span>.<span class="hljs-title function_">close</span>&gt;<span class="hljs-params">(reply-code=404, reply-text=NOT_FOUND - no exchange <span class="hljs-string">&#x27;comfirm.exchange1&#x27;</span> <span class="hljs-keyword">in</span> vhost <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">class</span>-id=60, <span class="hljs-keyword">method</span>-id=40)</span><br></code></pre></td></tr></table></figure><p>这里我们发现最后加一个Thread.sleep(100)才会显示调用信息？</p><p>原因分析：<br>个人猜测：回调函数虽然被调用了但是，主线程已经结束，来不及输出日志？</p><p>这里我们在主程序和回调函数里分别加一段代码获取当前线程id</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Id()</span>);<br></code></pre></td></tr></table></figure><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">1<br>20<br>回调方法<span class="hljs-keyword">confirm</span>被执行了<br>交换机接受消息成功<br></code></pre></td></tr></table></figure><p>发现回调函数会另外开启一个线程.所以以上猜测应该是正确的。</p><h3 id="Return-回退模式"><a href="#Return-回退模式" class="headerlink" title="Return 回退模式"></a>Return 回退模式</h3><p>return 退回模式：消息发给Exchange后，Exchange路由到Queue失败时才会触发ReturnCallBack</p><p>步骤：</p><p>1.开启回退模式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">publisher<span class="hljs-operator">-</span><span class="hljs-keyword">returns</span>: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>2.设置ReturnCallBack</p><p>3.设置Exchange处理消息的模式</p><p>​      3.1 如果消息没有路由到Queue，则丢弃消息(默认)(默认丢弃也不会触发回调函数)</p><p>​  3.2 如果消息没有路由到Queue,则返回给消息发送方ReturnCallBack</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//设置消息处理失败消息的模式</span><br>        rabbitTemplate.set<span class="hljs-constructor">Mandatory(<span class="hljs-params">true</span>)</span>;<br>        rabbitTemplate.set<span class="hljs-constructor">ReturnCallback(<span class="hljs-params">new</span> RabbitTemplate.ReturnCallback()</span> &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 返回消息</span><br><span class="hljs-comment">             *</span><br><span class="hljs-comment">             * @param message 消息</span><br><span class="hljs-comment">             * @param i       错误码</span><br><span class="hljs-comment">             * @param s       错误信息</span><br><span class="hljs-comment">             * @param s1      交换机</span><br><span class="hljs-comment">             * @param s2      路由键</span><br><span class="hljs-comment">             */</span><br>            @Override<br>            public void returned<span class="hljs-constructor">Message(Message <span class="hljs-params">message</span>, <span class="hljs-params">int</span> <span class="hljs-params">i</span>, String <span class="hljs-params">s</span>, String <span class="hljs-params">s1</span>, String <span class="hljs-params">s2</span>)</span> &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;return回调方法执行了&quot;</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(message);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(i);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(s);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(s1);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(s2);<br>            &#125;<br>        &#125;);<br>        String msg = <span class="hljs-string">&quot;你好return&quot;</span>;<br>        String exchange =<span class="hljs-string">&quot;comfirm.exchange&quot;</span>;<br>        rabbitTemplate.convert<span class="hljs-constructor">AndSend(<span class="hljs-params">exchange</span>,<span class="hljs-string">&quot;confirm&quot;</span>,<span class="hljs-params">msg</span>)</span>;<br>    &#125;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>默认方法是丢弃发送失败的消息，不会触发Return模式，我们需要</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">rabbitTemplate.set<span class="hljs-constructor">Mandatory(<span class="hljs-params">true</span>)</span>;<br></code></pre></td></tr></table></figure><p>将模式设置为返回给发送方，这样才会调用ReturnCallBack</p><p>我们故意将路由键改成错误的，输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">return回调方法执行了<br>(Body:<span class="hljs-string">&#x27;&quot;你好return&quot;&#x27;</span> MessageProperties [headers=&#123;<span class="hljs-attribute">__TypeId__</span>=java.lang.String&#125;, <span class="hljs-attribute">contentType</span>=application/json, <span class="hljs-attribute">contentEncoding</span>=UTF-8, <span class="hljs-attribute">contentLength</span>=0, <span class="hljs-attribute">receivedDeliveryMode</span>=PERSISTENT, <span class="hljs-attribute">priority</span>=0, <span class="hljs-attribute">deliveryTag</span>=0])<br>312<br>NO_ROUTE<br>comfirm.exchange<br>confirm1<br></code></pre></td></tr></table></figure><h3 id="Consumer-ACK"><a href="#Consumer-ACK" class="headerlink" title="Consumer ACK"></a>Consumer ACK</h3><p>ack指Acknowledge,确认。表示消费端收到消息后的确认方式。</p><p>有三种确认方式：</p><ul><li><p>自动确认：acknowledge &#x3D; “none”</p></li><li><p>手动确认：acknowledge &#x3D; “manual”</p></li><li><p>根据异常情况确认：acknowledge &#x3D;“auto” (这种方式使用麻烦，不做讲解)</p></li></ul><p>其中自动确认是指，当消息一旦被Consumer接收到，则自动确认收到，并将相应 message 从 RabbitMQ 的 消息缓存中移除。但是在实际业务处理中，很可能消息接收到，业务处理出现异常，那么该消息就会丢失。如 果设置了手动确认方式，则需要在业务处理成功后，调用channel.basicAck()，手动签收，如果出现异常，则 调用channel.basicNack()方法，让MQ自动重新发送消息。</p><p>basicAck()的参数：deliveryTag：该消息的index；multiple：是否批量处理.true:将一次性ack所有小于deliveryTag的消息</p><p>开启手动签收模式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">xxxxxxxx</span> <span class="hljs-comment"># rabbitMQ的ip地址</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">direct:</span><br>        <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">manual</span><br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RabbitListener</span>(bindings = <span class="hljs-meta">@QueueBinding</span>(<br>            value = <span class="hljs-meta">@Queue</span>(name = <span class="hljs-string">&quot;simple.queue&quot;</span>),<br>            exchange = <span class="hljs-meta">@Exchange</span>(name = <span class="hljs-string">&quot;comfirm.exchange&quot;</span>,type = ExchangeTypes.DIRECT),<br>            key = &#123;<span class="hljs-string">&quot;confirm&quot;</span>&#125;<br><br>    ))<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">confirm</span><span class="hljs-params">( Channel channel, Message message)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//获取收获标签</span><br>        <span class="hljs-keyword">long</span> deliveryTag = message.getMessageProperties().getDeliveryTag();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//模拟处理业务逻辑</span><br>            System.out.println(<span class="hljs-string">&quot;处理业务&quot;</span>);<br>            <span class="hljs-comment">//接收转换消息</span><br>            System.out.println(<span class="hljs-string">&quot;comfirm.exchange收到消息队列得消息:&quot;</span>+<span class="hljs-keyword">new</span> String(message.getBody()));<br>            <span class="hljs-comment">//伪造一个错误</span><br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span> / <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//手动签收</span><br>            channel.basicAck(deliveryTag,<span class="hljs-keyword">true</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">//如果出现异常，可以拒接签收，让消息重回队列</span><br>            channel.basicNack(deliveryTag,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到不断重试</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">处理业务<br>处理业务<br>处理业务<br>处理业务<br></code></pre></td></tr></table></figure><h2 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h2><h3 id="MQ有一个非常重要的作用：削峰添谷"><a href="#MQ有一个非常重要的作用：削峰添谷" class="headerlink" title="MQ有一个非常重要的作用：削峰添谷"></a>MQ有一个非常重要的作用：削峰添谷</h3><p><img src="/../mq_pic/6.png"></p><p>如果请求并发量特别大会让系统宕机,这时我们把并发量全部存到MQ中,然后再每秒从MQ中拉取一些请求进行处理,保证了系统的安全性,从MQ中拉的请求数就是所谓的限流处理,在消费消息的时候做了限流操作</p><p>还有一种业务场景,如果系统有一天要维护,由于生产者一直在发消息,但是系统在维护,那么等系统维护好了之后,所有生产者生产的消息会一直堆积在MQ中,那么等系统维护好了之后,之前生产的消息一次性打到系统,系统也会宕机,所以为了保证系统稳定性,做限流是非常有必要性的！</p><p>在SpringBoot整合RabbitMQ后，限流的关键代码为(但是这个方法貌似不起作用)，所以目前只在yml文件中配置</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">channel.<span class="hljs-keyword">basic</span>Q<span class="hljs-keyword">os</span>();<br></code></pre></td></tr></table></figure><p>该方法的作用是：进行消费端的限流</p><p>param1：prefetchSize，消息本身的大小 如果设置为0 那么表示对消息本身的大小不限制<br>param2：prefetchCount，告诉rabbitmq不要一次性给消费者推送大于N个消息<br>param3：global，是否将上面的设置应用于整个通道<br>false：表示只应用于当前消费者<br>true：表示当前通道的所有消费者都应用这个限流策略<br><strong>注意</strong>：<strong>限流情况 ack 不能设置自动签收，一定要手动签收</strong></p><p>1.在yml文件中设置</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol">  rabbitmq:</span><br><span class="hljs-symbol">     listener:</span><br><span class="hljs-symbol">      simple:</span><br><span class="hljs-symbol">        prefetch:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>2.在监听器中设置手动签收</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">channel.basic<span class="hljs-constructor">Ack(<span class="hljs-params">deliveryTag</span>,<span class="hljs-params">true</span>)</span>;<br></code></pre></td></tr></table></figure><p>只有手动签收了才会消费所有的消息，如果没有手动签收会认为还没有消费完，不会继续消费了，因此只消费了一条消息。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2023/03/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/03/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h2><p><img src="/../os_pic/1.png"></p><p><strong>操作系统(OS)</strong> 是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件</p><p><img src="/../os_pic/2.png"></p><p>补充：进程是一个程序的执行过程。执行前需要将该程序放到内存中，才能被CPU处理。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="/../os_pic/4.png"></p><h2 id="系统资源管理"><a href="#系统资源管理" class="headerlink" title="系统资源管理"></a>系统资源管理</h2><p><img src="/../os_pic/3.png"></p><ul><li><p>Step1—&gt;文件管理</p></li><li><p>Step2—&gt;存储器管理(内存管理)</p></li><li><p>Step3—&gt;处理机管理</p></li><li><p>Step4—&gt;设备管理</p></li></ul><h2 id="作为用户和计算机硬件之间的接口"><a href="#作为用户和计算机硬件之间的接口" class="headerlink" title="作为用户和计算机硬件之间的接口"></a>作为用户和计算机硬件之间的接口</h2><p><img src="/../os_pic/5.png"></p><p><img src="/../os_pic/6.png"></p><h3 id="联机命令接口"><a href="#联机命令接口" class="headerlink" title="联机命令接口"></a>联机命令接口</h3><p><img src="/../os_pic/7.png"></p><p>联机命令接口&#x3D;交互式命令接口</p><h3 id="脱机命令接口"><a href="#脱机命令接口" class="headerlink" title="脱机命令接口"></a>脱机命令接口</h3><p><img src="/../os_pic/8.png"></p><h3 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h3><p>程序接口(允许用户通过程序<strong>间接</strong>使用)：由一组<strong>系统调用组成</strong>(程序接口&#x3D;系统调用)</p><h2 id="接口总结"><a href="#接口总结" class="headerlink" title="接口总结"></a>接口总结</h2><p><img src="/../os_pic/9.png"></p><p><img src="/../os_pic/10.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/../os_pic/11.png"></p><h2 id="操作系统的四大特征"><a href="#操作系统的四大特征" class="headerlink" title="操作系统的四大特征"></a>操作系统的四大特征</h2><p><img src="/../os_pic/12.png"></p><p>四大特征：并发,共享，虚拟，异步</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="并发的概念及与并行的区别"><a href="#并发的概念及与并行的区别" class="headerlink" title="并发的概念及与并行的区别"></a>并发的概念及与并行的区别</h3><p><img src="/../os_pic/13.png"></p><p><img src="/../os_pic/14.png"></p><h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p><img src="/../os_pic/15.png"></p><p>但是同时共享访问也有“同时”访问的，不是微观上的交替，比如扬声器一边播放游戏声音一边播放音乐声音</p><h2 id="并发与共享的关系"><a href="#并发与共享的关系" class="headerlink" title="并发与共享的关系"></a>并发与共享的关系</h2><p><img src="/../os_pic/16.png"></p><h2 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h2><h3 id="虚拟-空分复用技术"><a href="#虚拟-空分复用技术" class="headerlink" title="虚拟-空分复用技术"></a>虚拟-空分复用技术</h3><p><img src="/../os_pic/17.png"></p><h3 id="虚拟-时分复用"><a href="#虚拟-时分复用" class="headerlink" title="虚拟-时分复用"></a>虚拟-时分复用</h3><p><img src="/../os_pic/18.png"></p><p>显然，如果失去了并发性，则一个时间段内系统中只需要运行一道程序，那么就失去了实习虚拟性的意义了。因此，没有并发性，就谈不上虚拟性。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p><img src="/../os_pic/19.png"></p><p>这点在Java高并发中体现明显，需要用到锁🔒解决</p><h2 id="操作系统四大特征总结"><a href="#操作系统四大特征总结" class="headerlink" title="操作系统四大特征总结"></a>操作系统四大特征总结</h2><p><img src="/../os_pic/20.png"></p><h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h2><p><img src="/../os_pic/21.png"></p><h3 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h3><p><img src="/../os_pic/22.png"></p><p>CPU计算快，但纸带输入太慢，造成CPU浪费</p><h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h3><p><img src="/../os_pic/23.png"></p><p>提前把程序输入到磁带中，提高输入输出速度</p><h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><p><img src="/../os_pic/24.png"></p><h3 id="单道批处理与多道批处理对比"><a href="#单道批处理与多道批处理对比" class="headerlink" title="单道批处理与多道批处理对比"></a>单道批处理与多道批处理对比</h3><p><img src="/../os_pic/25.png"></p><p><img src="/../os_pic/26.png"></p><h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3><p><img src="/../os_pic/27.png"></p><h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><p><img src="/../os_pic/28.png"></p><h3 id="其他几种操作系统-了解即可"><a href="#其他几种操作系统-了解即可" class="headerlink" title="其他几种操作系统(了解即可)"></a>其他几种操作系统(了解即可)</h3><p><img src="/../os_pic/29.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C/C++的五个区</title>
    <link href="/2023/02/28/CC++%E7%9A%84%E4%BA%94%E4%B8%AA%E5%8C%BA/"/>
    <url>/2023/02/28/CC++%E7%9A%84%E4%BA%94%E4%B8%AA%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="c语言中的5大内存分区"><a href="#c语言中的5大内存分区" class="headerlink" title="c语言中的5大内存分区"></a><a href="https://www.cnblogs.com/souhaite/p/10941824.html">c语言中的5大内存分区</a></h1><p>在C&#x2F;C++中，内存分成5个区，他们分别是<strong>堆、栈、自由存储区、全局&#x2F;静态存储区和常量存储区</strong>。</p><p>1.<strong>栈</strong>，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量存储区。里面的变量通常是局部变量、函数参数等。</p><p>2.<strong>堆</strong>，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p><p>3.<strong>自由存储区</strong>，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。</p><p>4.<strong>全局&#x2F;静态存储区</strong>，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。</p><p>5.<strong>常量存储区</strong>，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多）</p><p>明确区分堆与栈<br>在bbs上，堆与栈的区分问题，似乎是一个永恒的话题，由此可见，初学者对此往往是混淆不清的，所以我决定拿他第一个开刀。</p><p>首先，我们举一个例子：<br>void f() { int* p&#x3D;new int[5]; }<br>这条短短的一句话就包含了堆与栈，看到new，我们首先就应该想到，我们分配了一块堆内存，那么指针p呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针p。在程序会先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块内存的首地址，放入栈中，他在VC6下的汇编代码如下：</p><p>00401028 push 14h<br>0040102A call operator new (00401060)<br>0040102F add esp,4<br>00401032 mov dword ptr [ebp-8],eax<br>00401035 mov eax,dword ptr [ebp-8]<br>00401038 mov dword ptr [ebp-4],eax</p><p>这里，我们为了简单并没有释放内存，那么该怎么去释放呢？是delete p么？澳，错了，应该是delete []p，这是为了告诉编译器：我删除的是一个数组，VC6就会根据相应的Cookie信息去进行释放内存的工作。<br>好了，我们回到我们的主题：堆和栈究竟有什么区别？<br>主要的区别由以下几点：<br>1、管理方式不同；<br>2、空间大小不同；<br>3、能否产生碎片不同；<br>4、生长方向不同；<br>5、分配方式不同；<br>6、分配效率不同；</p><p>管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。<br>空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：<br>打开工程，依次操作菜单如下：Project-&gt;Setting-&gt;Link，在Category 中选中Output，然后在Reserve中设定堆栈的最大值和commit。<br>注意：reserve最小值为4Byte；commit是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。</p><p>碎片问题：对于堆来讲，频繁的new&#x2F;delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。</p><p>生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。</p><p>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p><p>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C&#x2F;C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构&#x2F;操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p><p>从这里我们可以看到，堆和栈相比，由于大量new&#x2F;delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。</p><p>虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。<br>无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果,就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候debug可是相当困难的：）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper</title>
    <link href="/2023/02/26/Zookeeper/"/>
    <url>/2023/02/26/Zookeeper/</url>
    
    <content type="html"><![CDATA[<h2 id="Zookeeper概念"><a href="#Zookeeper概念" class="headerlink" title="Zookeeper概念"></a>Zookeeper概念</h2><p><img src="/../zk_pic/zk1.png"></p><h2 id="Zookeeper数据模型"><a href="#Zookeeper数据模型" class="headerlink" title="Zookeeper数据模型"></a>Zookeeper数据模型</h2><p><img src="/../zk_pic/zk2.png"></p><h2 id="Linux下的服务端命令"><a href="#Linux下的服务端命令" class="headerlink" title="Linux下的服务端命令"></a>Linux下的服务端命令</h2><p>比较简单：</p><p><img src="/../zk_pic/zk3.png"></p><h2 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h2><p><img src="/../zk_pic/zk4.png"></p><p><img src="/../zk_pic/zk5.png"></p><h2 id="Zookeeper客户端curator常用操作API"><a href="#Zookeeper客户端curator常用操作API" class="headerlink" title="Zookeeper客户端curator常用操作API"></a>Zookeeper客户端curator常用操作API</h2><p><img src="/../zk_pic/zk06.png"></p><h2 id="常用分布式锁"><a href="#常用分布式锁" class="headerlink" title="常用分布式锁"></a>常用分布式锁</h2><p><img src="/../zk_pic/zk7.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯</title>
    <link href="/2023/02/26/%E5%9B%9E%E6%BA%AF/"/>
    <url>/2023/02/26/%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="回朔法的思想："><a href="#回朔法的思想：" class="headerlink" title="回朔法的思想："></a>回朔法的思想：</h3><p>回朔法的重要思想在于： 通过枚举法，对所有可能性进行遍历。 但是枚举的顺序是 一条路走到黑，发现黑之后，退一步，再向前尝试没走过的路。直到所有路都试过。因此回朔法可以简单的理解为： 走不通就退一步的方枚举法就叫回朔法。而这里回退点也叫做回朔点。</p><h3 id="回朔关键点"><a href="#回朔关键点" class="headerlink" title="回朔关键点"></a>回朔关键点</h3><p>通过分析发现，回朔法实现的三大技术关键点分别是：</p><ol><li>一条路走到黑</li><li>回退一步</li><li>另寻他路</li></ol><h3 id="关键点的实现"><a href="#关键点的实现" class="headerlink" title="关键点的实现"></a>关键点的实现</h3><p>那么如何才能用代码实现上述三个关键点呢？</p><ol><li>for 循环</li><li>递归</li></ol><h4 id="解释如下"><a href="#解释如下" class="headerlink" title="解释如下"></a>解释如下</h4><ul><li>for循环的作用在于另寻他路： 你可以用for循环可以实现一个路径选择器的功能，该路径选择器可以逐个选择当前节点下的所有可能往下走下去的分支路径。 例如： 现在你走到了节点a，a就像个十字路口，你从上面来到达了a，可以继续向下走。若此时向下走的路有i条，那么你肯定要逐个的把这i条都试一遍才行。而for的作用就是可以让你逐个把所有向下的i个路径既不重复，也不缺失的都试一遍</li><li>递归可以实现一条路走到黑和回退一步： 一条路走到黑： 递归意味着继续向着for给出的路径向下走一步。 如果我们把递归放在for循环内部，那么for每一次的循环，都在给出一个路径之后，进入递归，也就继续向下走了。直到递归出口（走无可走）为止。 那么这就是一条路走到黑的实现方法。 递归从递归出口出来之后，就会实现回退一步。</li></ul><p>因此for循环和递归配合可以实现回朔： 当递归从递归出口出来之后。上一层的for循环就会继续执行了。而for循环的继续执行就会给出当前节点下的下一条可行路径。而后递归调用，就顺着这条从未走过的路径又向下走一步。这就是回朔</p><p>说了这么多，回朔法的通常模板是什么呢？ 递归和for又是如何配合的呢？</p><h4 id="回朔代码模板"><a href="#回朔代码模板" class="headerlink" title="回朔代码模板"></a>回朔代码模板</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>():<br>    <br>    <span class="hljs-keyword">if</span> (回朔点）：<span class="hljs-comment"># 这条路走到底的条件。也是递归出口</span><br>        保存该结果<br>        <span class="hljs-keyword">return</span>   <br>    <br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> route <span class="hljs-keyword">in</span> all_route_set :  逐步选择当前节点下的所有可能route<br>            <br>            <span class="hljs-keyword">if</span> 剪枝条件：<br>                剪枝前的操作<br>                <span class="hljs-keyword">return</span>   <span class="hljs-comment">#不继续往下走了，退回上层，换个路再走</span><br>            <br>            <span class="hljs-keyword">else</span>：<span class="hljs-comment">#当前路径可能是条可行路径</span><br>            <br>                保存当前数据  <span class="hljs-comment">#向下走之前要记住已经走过这个节点了。例如push当前节点</span><br>        <br>                self.backward() <span class="hljs-comment">#递归发生，继续向下走一步了。</span><br>                <br>                回朔清理     <span class="hljs-comment"># 该节点下的所有路径都走完了，清理堆栈，准备下一个递归。例如弹出当前节点</span><br></code></pre></td></tr></table></figure><p>这里剪枝操作指的是： 对于有些问题，你走着走着，若某种情况发生了，你就已经直到不能继续往下走了，再走也没有用了。而这个情况就被称之为剪枝条件。</p><p>而DFS就是一个最典型的回朔法的应用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum</span>(<span class="hljs-params">self, candidates: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(candidates) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        candidates.sort()<br>        path = []<br>        res = []<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        ！！！重点！！！</span><br><span class="hljs-string">        在python中，如果传参是mutable var, 那么传参相当于引用，因此调用后，如果调用函数的内部对该传入变量进行修改，就会导致直接改变原始对象。这就是典型的privacy leak！！发生了。</span><br><span class="hljs-string">        例如在这个，list就是该mutable var，而如果以path或res 为传参，放在__DFS 中， 那么就相当于在__DFS内部，实际上用的都是一个物理地址下的res和path，类似于全局变量。</span><br><span class="hljs-string">        因此combinationSum下的局部变量path和res也在——DFS运行的过程中发生了改变。</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        利用这个性质，我们可以把mutable var当成传入参数，从而实现全局变量的效果。</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        self.__DFS(candidates, target, <span class="hljs-number">0</span>, path, res)<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        DFS的实现</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__DFS</span>(<span class="hljs-params">self, candidates, target, begin, path, res</span>):<br>        path = path.copy()<br>        <span class="hljs-comment"># 递归出口 就是余数为0</span><br>        <span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span>:<br>            res.append(path)   <span class="hljs-comment">#记录该符合条件的结果</span><br>            <span class="hljs-keyword">return</span><br>        <br>        <span class="hljs-comment">#若当前路径有可能可行。</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(begin, <span class="hljs-built_in">len</span>(candidates)):  <span class="hljs-comment"># 我们现在到begin的节点上了</span><br>            <span class="hljs-keyword">if</span> target - candidates[i] &lt; <span class="hljs-number">0</span>:  <span class="hljs-comment"># 剪枝条件</span><br>                <span class="hljs-keyword">return</span>                      <span class="hljs-comment"># 如果当前节点就不行了，就不用继续了,这里到不用继续了即包括该depth不用继续了，也包括该节点更大到child也不用继续了，该节点pop出来</span><br>            <br>            path.append(candidates[i])  <span class="hljs-comment">#记录当前为止</span><br>            self.__DFS(candidates, target - candidates[i], i, path, res)<span class="hljs-comment"># 向下继续走，记住递归不是return，递归到实现是调用！一旦return发生，递归停止。</span><br>            path.pop()  <span class="hljs-comment"># 回朔清理。当前节点下的所有情况都进行完了，该节点也不应该在path里面了。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/2023/02/23/Docker/"/>
    <url>/2023/02/23/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="1-初识Docker"><a href="#1-初识Docker" class="headerlink" title="1.初识Docker"></a>1.初识Docker</h1><h2 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1.什么是Docker"></a>1.1.什么是Docker</h2><p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p><ul><li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li><li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li></ul><h3 id="1-1-1-应用部署的环境问题"><a href="#1-1-1-应用部署的环境问题" class="headerlink" title="1.1.1.应用部署的环境问题"></a>1.1.1.应用部署的环境问题</h3><p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p><ul><li><p>依赖关系复杂，容易出现兼容性问题</p></li><li><p>开发、测试、生产环境有差异</p></li></ul><p><img src="/../docker_pic/image-20210731141907366.png" alt="image-20210731141907366"></p><p>例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</p><h3 id="1-1-2-Docker解决依赖兼容问题"><a href="#1-1-2-Docker解决依赖兼容问题" class="headerlink" title="1.1.2.Docker解决依赖兼容问题"></a>1.1.2.Docker解决依赖兼容问题</h3><p>而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？</p><p>Docker为了解决依赖的兼容问题的，采用了两个手段：</p><ul><li><p>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</p></li><li><p>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</p></li></ul><p><img src="/../docker_pic/image-20210731142219735.png" alt="image-20210731142219735"></p><p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p><p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p><h3 id="1-1-3-Docker解决操作系统环境差异"><a href="#1-1-3-Docker解决操作系统环境差异" class="headerlink" title="1.1.3.Docker解决操作系统环境差异"></a>1.1.3.Docker解决操作系统环境差异</h3><p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下：</p><p><img src="/../docker_pic/image-20210731143401460.png" alt="image-20210731143401460"></p><p>结构包括：</p><ul><li>计算机硬件：例如CPU、内存、磁盘等</li><li>系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供<strong>内核指令</strong>，用于操作计算机硬件。</li><li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li></ul><p>应用于计算机交互的流程如下：</p><p>1）应用调用操作系统应用（函数库），实现各种功能</p><p>2）系统函数库是对内核指令集的封装，会调用内核指令</p><p>3）内核指令操作计算机硬件</p><p>Ubuntu和CentOSpringBoot都是基于Linux内核，无非是系统应用不同，提供的函数库有差异：</p><p><img src="/../docker_pic/image-20210731144304990.png" alt="image-20210731144304990"></p><p>此时，如果将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了：</p><p><img src="/../docker_pic/image-20210731144458680.png" alt="image-20210731144458680"></p><p>Docker如何解决不同系统环境的问题？</p><ul><li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li><li>Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行</li></ul><p>如图：</p><p><img src="/../docker_pic/image-20210731144820638.png" alt="image-20210731144820638"></p><h3 id="1-1-4-小结"><a href="#1-1-4-小结" class="headerlink" title="1.1.4.小结"></a>1.1.4.小结</h3><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li></ul><p>Docker如何解决开发、测试、生产环境有差异的问题？</p><ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul><p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p><ul><li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li><li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li><li>启动、移除都可以通过一行命令完成，方便快捷</li></ul><h2 id="1-2-Docker和虚拟机的区别"><a href="#1-2-Docker和虚拟机的区别" class="headerlink" title="1.2.Docker和虚拟机的区别"></a>1.2.Docker和虚拟机的区别</h2><p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p><p>两者有什么差异呢？</p><p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟</strong>硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</p><p><strong>Docker</strong>仅仅是封装函数库，并没有模拟完整的操作系统，如图：</p><p><img src="/../docker_pic/image-20210731145914960.png" alt="image-20210731145914960"></p><p>对比来看：</p><p><img src="/../docker_pic/image-20210731152243765.png" alt="image-20210731152243765"></p><p>小结：</p><p>Docker和虚拟机的差异：</p><ul><li><p>docker是一个系统进程；虚拟机是在操作系统中的操作系统</p></li><li><p>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</p></li></ul><h2 id="1-3-Docker架构"><a href="#1-3-Docker架构" class="headerlink" title="1.3.Docker架构"></a>1.3.Docker架构</h2><h3 id="1-3-1-镜像和容器"><a href="#1-3-1-镜像和容器" class="headerlink" title="1.3.1.镜像和容器"></a>1.3.1.镜像和容器</h3><p>Docker中有几个重要的概念：</p><p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p><p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p><p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p><p>而<strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p><p><strong>容器</strong>呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p><p><img src="/../docker_pic/image-20210731153059464.png" alt="image-20210731153059464"></p><p>例如你下载了一个QQ，如果我们将QQ在磁盘上的运行<strong>文件</strong>及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。</p><h3 id="1-3-2-DockerHub"><a href="#1-3-2-DockerHub" class="headerlink" title="1.3.2.DockerHub"></a>1.3.2.DockerHub</h3><p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。</p><ul><li><p>DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。</p></li><li><p>国内也有类似于DockerHub 的公开服务，比如 <a href="https://c.163yun.com/hub">网易云镜像服务</a>、<a href="https://cr.console.aliyun.com/">阿里云镜像库</a>等。</p></li></ul><p>我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像：</p><p><img src="/../docker_pic/image-20210731153743354.png" alt="image-20210731153743354"></p><h3 id="1-3-3-Docker架构"><a href="#1-3-3-Docker架构" class="headerlink" title="1.3.3.Docker架构"></a>1.3.3.Docker架构</h3><p>我们要使用Docker来操作镜像、容器，就必须要安装Docker。</p><p>Docker是一个CS架构的程序，由两部分组成：</p><ul><li><p>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</p></li><li><p>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</p></li></ul><p>如图：</p><p><img src="/../docker_pic/image-20210731154257653.png" alt="image-20210731154257653"></p><h3 id="1-3-4-小结"><a href="#1-3-4-小结" class="headerlink" title="1.3.4.小结"></a>1.3.4.小结</h3><p>镜像：</p><ul><li>将应用程序及其依赖、环境、配置打包在一起</li></ul><p>容器：</p><ul><li>镜像运行起来就是容器，一个镜像可以运行多个容器</li></ul><p>Docker结构：</p><ul><li><p>服务端：接收命令或远程请求，操作镜像或容器</p></li><li><p>客户端：发送命令或者请求到Docker服务端</p></li></ul><p>DockerHub：</p><ul><li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li></ul><h2 id="1-4-安装Docker"><a href="#1-4-安装Docker" class="headerlink" title="1.4.安装Docker"></a>1.4.安装Docker</h2><p>企业部署一般都是采用Linux操作系统，而其中又数CentOS发行版占比最多，因此我们在CentOS下安装Docker。参考课前资料中的文档：</p><p><img src="/../docker_pic/image-20210731155002425.png" alt="image-20210731155002425"></p><h1 id="2-Docker的基本操作"><a href="#2-Docker的基本操作" class="headerlink" title="2.Docker的基本操作"></a>2.Docker的基本操作</h1><h2 id="2-1-镜像操作"><a href="#2-1-镜像操作" class="headerlink" title="2.1.镜像操作"></a>2.1.镜像操作</h2><h3 id="2-1-1-镜像名称"><a href="#2-1-1-镜像名称" class="headerlink" title="2.1.1.镜像名称"></a>2.1.1.镜像名称</h3><p>首先来看下镜像的名称组成：</p><ul><li>镜名称一般分两部分组成：[repository]:[tag]。</li><li>在没有指定tag时，默认是latest，代表最新版本的镜像</li></ul><p>如图：</p><p><img src="/../docker_pic/image-20210731155141362.png" alt="image-20210731155141362"></p><p>这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。</p><h3 id="2-1-2-镜像命令"><a href="#2-1-2-镜像命令" class="headerlink" title="2.1.2.镜像命令"></a>2.1.2.镜像命令</h3><p>常见的镜像操作命令如图：</p><p><img src="/../docker_pic/image-20210731155649535.png" alt="image-20210731155649535"></p><h3 id="2-1-3-案例1-拉取、查看镜像"><a href="#2-1-3-案例1-拉取、查看镜像" class="headerlink" title="2.1.3.案例1-拉取、查看镜像"></a>2.1.3.案例1-拉取、查看镜像</h3><p>需求：从DockerHub中拉取一个nginx镜像并查看</p><p>1）首先去镜像仓库搜索nginx镜像，比如<a href="https://hub.docker.com/">DockerHub</a>:</p><p><img src="/../docker_pic/image-20210731155844368.png" alt="image-20210731155844368"></p><p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p><p><img src="/../docker_pic/image-20210731155856199.png" alt="image-20210731155856199"></p><p>3）通过命令：docker images 查看拉取到的镜像</p><p><img src="/../docker_pic/image-20210731155903037.png" alt="image-20210731155903037"></p><h3 id="2-1-4-案例2-保存、导入镜像"><a href="#2-1-4-案例2-保存、导入镜像" class="headerlink" title="2.1.4.案例2-保存、导入镜像"></a>2.1.4.案例2-保存、导入镜像</h3><p>需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来</p><p>1）利用docker xx –help命令查看docker save和docker load的语法</p><p>例如，查看save命令用法，可以输入命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker save --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/../docker_pic/image-20210731161104732.png" alt="image-20210731161104732"></p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker save -o [保存的目标文件名称] [镜像名称]<br></code></pre></td></tr></table></figure><p>2）使用docker save导出镜像到磁盘 </p><p>运行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker save -o nginx.tar nginx:latest<br></code></pre></td></tr></table></figure><p>结果如图：</p><p><img src="/../docker_pic/image-20210731161354344.png" alt="image-20210731161354344"></p><p>3）使用docker load加载镜像</p><p>先删除本地的nginx镜像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker rmi nginx:latest<br></code></pre></td></tr></table></figure><p>然后运行命令，加载本地文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker load -i nginx.tar<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/../docker_pic/image-20210731161746245.png" alt="image-20210731161746245"></p><h3 id="2-1-5-练习"><a href="#2-1-5-练习" class="headerlink" title="2.1.5.练习"></a>2.1.5.练习</h3><p>需求：去DockerHub搜索并拉取一个Redis镜像</p><p>目标：</p><p>1）去DockerHub搜索Redis镜像</p><p>2）查看Redis镜像的名称和版本</p><p>3）利用docker pull命令拉取镜像</p><p>4）利用docker save命令将 redis:latest打包为一个redis.tar包</p><p>5）利用docker rmi 删除本地的redis:latest</p><p>6）利用docker load 重新加载 redis.tar文件</p><h2 id="2-2-容器操作"><a href="#2-2-容器操作" class="headerlink" title="2.2.容器操作"></a>2.2.容器操作</h2><h3 id="2-2-1-容器相关命令"><a href="#2-2-1-容器相关命令" class="headerlink" title="2.2.1.容器相关命令"></a>2.2.1.容器相关命令</h3><p>容器操作的命令如图：</p><p><img src="/../docker_pic/image-20210731161950495.png" alt="image-20210731161950495"></p><p>容器保护三个状态：</p><ul><li>运行：进程正常运行</li><li>暂停：进程暂停，CPU不再运行，并不释放内存</li><li>停止：进程终止，回收进程占用的内存、CPU等资源</li></ul><p>其中：</p><ul><li><p>docker run：创建并运行一个容器，处于运行状态</p></li><li><p>docker pause：让一个运行的容器暂停</p></li><li><p>docker unpause：让一个容器从暂停状态恢复运行</p></li><li><p>docker stop：停止一个运行的容器</p></li><li><p>docker start：让一个停止的容器再次运行</p></li><li><p>docker rm：删除一个容器</p></li></ul><h3 id="2-2-2-案例-创建并运行一个容器"><a href="#2-2-2-案例-创建并运行一个容器" class="headerlink" title="2.2.2.案例-创建并运行一个容器"></a>2.2.2.案例-创建并运行一个容器</h3><p>创建并运行nginx容器的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run --name containerName -p 80:80 -d nginx<br></code></pre></td></tr></table></figure><p>命令解读：</p><ul><li>docker run ：创建并运行一个容器</li><li>–name : 给容器起一个名字，比如叫做mn</li><li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li><li>-d：后台运行容器</li><li>nginx：镜像名称，例如nginx</li></ul><p>这里的<code>-p</code>参数，是将容器端口映射到宿主机端口。</p><p>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。</p><p>现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了：</p><p><img src="/../docker_pic/image-20210731163255863.png" alt="image-20210731163255863"></p><h3 id="2-2-3-案例-进入容器，修改文件"><a href="#2-2-3-案例-进入容器，修改文件" class="headerlink" title="2.2.3.案例-进入容器，修改文件"></a>2.2.3.案例-进入容器，修改文件</h3><p><strong>需求</strong>：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您”</p><p><strong>提示</strong>：进入容器要用到docker exec命令。</p><p><strong>步骤</strong>：</p><p>1）进入容器。进入我们刚刚创建的nginx容器的命令为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it mn bash<br></code></pre></td></tr></table></figure><p>命令解读：</p><ul><li><p>docker exec ：进入容器内部，执行一个命令</p></li><li><p>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p></li><li><p>mn ：要进入的容器的名称</p></li><li><p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p></li></ul><p>2）进入nginx的HTML所在目录 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</p><p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p><p><img src="/../docker_pic/image-20210731164159811.png" alt="image-20210731164159811"></p><p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p><p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p><p>我们执行命令，进入该目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/share/nginx/html<br></code></pre></td></tr></table></figure><p> 查看目录下文件：</p><p><img src="/../docker_pic/image-20210731164455818.png" alt="image-20210731164455818"></p><p>3）修改index.html的内容</p><p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sed -i -e <span class="hljs-string">&#x27;s#Welcome to nginx#传智教育欢迎您#g&#x27;</span> -e <span class="hljs-string">&#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27;</span> index.html<br></code></pre></td></tr></table></figure><p>在浏览器访问自己的虚拟机地址，例如我的是：<a href="http://192.168.150.101，即可看到结果：">http://192.168.150.101，即可看到结果：</a></p><p><img src="/../docker_pic/image-20210731164717604.png" alt="image-20210731164717604"></p><h3 id="2-2-4-小结"><a href="#2-2-4-小结" class="headerlink" title="2.2.4.小结"></a>2.2.4.小结</h3><p>docker run命令的常见参数有哪些？</p><ul><li>–name：指定容器名称</li><li>-p：指定端口映射</li><li>-d：让容器后台运行</li></ul><p>查看容器日志的命令：</p><ul><li>docker logs</li><li>添加 -f 参数可以持续查看日志</li></ul><p>查看容器状态：</p><ul><li>docker ps</li><li>docker ps -a 查看所有容器，包括已经停止的</li></ul><h2 id="2-3-数据卷（容器数据管理）"><a href="#2-3-数据卷（容器数据管理）" class="headerlink" title="2.3.数据卷（容器数据管理）"></a>2.3.数据卷（容器数据管理）</h2><p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。</p><p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p><p><img src="/../docker_pic/image-20210731172440275.png" alt="image-20210731172440275"></p><p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p><h3 id="2-3-1-什么是数据卷"><a href="#2-3-1-什么是数据卷" class="headerlink" title="2.3.1.什么是数据卷"></a>2.3.1.什么是数据卷</h3><p><strong>数据卷（volume）</strong>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p><p><img src="/../docker_pic/image-20210731173541846.png" alt="image-20210731173541846"></p><p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p><p>这样，我们操作宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html目录，就等于操作容器内的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html目录了</p><h3 id="2-3-2-数据集操作命令"><a href="#2-3-2-数据集操作命令" class="headerlink" title="2.3.2.数据集操作命令"></a>2.3.2.数据集操作命令</h3><p>数据卷操作的基本语法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker volume [COMMAND]<br></code></pre></td></tr></table></figure><p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p><ul><li>create 创建一个volume</li><li>inspect 显示一个或多个volume的信息</li><li>ls 列出所有的volume</li><li>prune 删除未使用的volume</li><li>rm 删除一个或多个指定的volume</li></ul><h3 id="2-3-3-创建和查看数据卷"><a href="#2-3-3-创建和查看数据卷" class="headerlink" title="2.3.3.创建和查看数据卷"></a>2.3.3.创建和查看数据卷</h3><p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p><p>① 创建数据卷</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker volume create html<br></code></pre></td></tr></table></figure><p>② 查看所有数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker volume <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/../docker_pic/image-20210731173746910.png" alt="image-20210731173746910"></p><p>③ 查看数据卷详细信息卷</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker volume inspect html<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/../docker_pic/image-20210731173809877.png" alt="image-20210731173809877"></p><p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p><p><strong>小结</strong>：</p><p>数据卷的作用：</p><ul><li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li></ul><p>数据卷操作：</p><ul><li>docker volume create：创建数据卷</li><li>docker volume ls：查看所有数据卷</li><li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li><li>docker volume rm：删除指定数据卷</li><li>docker volume prune：删除所有未使用的数据卷</li></ul><h3 id="2-3-4-挂载数据卷"><a href="#2-3-4-挂载数据卷" class="headerlink" title="2.3.4.挂载数据卷"></a>2.3.4.挂载数据卷</h3><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run \<br>  --name mn \<br>  -v html:/root/html \<br>  -p 8080:80<br>  nginx \<br></code></pre></td></tr></table></figure><p>这里的-v就是挂载数据卷的命令：</p><ul><li><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的&#x2F;root&#x2F;html这个目录中</li></ul><h3 id="2-3-5-案例-给nginx挂载数据卷"><a href="#2-3-5-案例-给nginx挂载数据卷" class="headerlink" title="2.3.5.案例-给nginx挂载数据卷"></a>2.3.5.案例-给nginx挂载数据卷</h3><p><strong>需求</strong>：创建一个nginx容器，修改容器内的html目录内的index.html内容</p><p><strong>分析</strong>：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。</p><p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p><p>步骤：</p><p>① 创建容器并挂载数据卷到容器内的HTML目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx<br></code></pre></td></tr></table></figure><p>② 进入html数据卷所在位置，并修改HTML内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看html数据卷的位置</span><br>docker volume inspect html<br><span class="hljs-comment"># 进入该目录</span><br><span class="hljs-built_in">cd</span> /var/lib/docker/volumes/html/_data<br><span class="hljs-comment"># 修改文件</span><br>vi index.html<br></code></pre></td></tr></table></figure><h3 id="2-3-6-案例-给MySQL挂载本地目录"><a href="#2-3-6-案例-给MySQL挂载本地目录" class="headerlink" title="2.3.6.案例-给MySQL挂载本地目录"></a>2.3.6.案例-给MySQL挂载本地目录</h3><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p><ul><li>带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录</li><li>直接挂载模式：宿主机目录 —&gt; 容器内目录</li></ul><p>如图：</p><p><img src="/../docker_pic/image-20210731175155453.png" alt="image-20210731175155453"></p><p><strong>语法</strong>：</p><p>目录挂载与数据卷挂载的语法是类似的：</p><ul><li>-v [宿主机目录]:[容器内目录]</li><li>-v [宿主机文件]:[容器内文件]</li></ul><p><strong>需求</strong>：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</p><p>实现思路如下：</p><p>1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像</p><p>2）创建目录&#x2F;tmp&#x2F;mysql&#x2F;data</p><p>3）创建目录&#x2F;tmp&#x2F;mysql&#x2F;conf，将课前资料提供的hmy.cnf文件上传到&#x2F;tmp&#x2F;mysql&#x2F;conf</p><p>4）去DockerHub查阅资料，创建并运行MySQL容器，要求：</p><p>① 挂载&#x2F;tmp&#x2F;mysql&#x2F;data到mysql容器内数据存储目录</p><p>② 挂载&#x2F;tmp&#x2F;mysql&#x2F;conf&#x2F;hmy.cnf到mysql容器的配置文件</p><p>③ 设置MySQL密码</p><h3 id="2-3-7-小结"><a href="#2-3-7-小结" class="headerlink" title="2.3.7.小结"></a>2.3.7.小结</h3><p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p><ul><li>-v volume名称:容器内目录</li><li>-v 宿主机文件:容器内文</li><li>-v 宿主机目录:容器内目录</li></ul><p>数据卷挂载与目录直接挂载的</p><ul><li>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</li><li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li></ul><h1 id="3-Dockerfile自定义镜像"><a href="#3-Dockerfile自定义镜像" class="headerlink" title="3.Dockerfile自定义镜像"></a>3.Dockerfile自定义镜像</h1><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p><p>而要自定义镜像，就必须先了解镜像的结构才行。</p><h2 id="3-1-镜像结构"><a href="#3-1-镜像结构" class="headerlink" title="3.1.镜像结构"></a>3.1.镜像结构</h2><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p><p>我们以MySQL为例，来看看镜像的组成结构：</p><p><img src="/../docker_pic/image-20210731175806273.png" alt="image-20210731175806273"></p><p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p><p>我们要构建镜像，其实就是实现上述打包的过程。</p><h2 id="3-2-Dockerfile语法"><a href="#3-2-Dockerfile语法" class="headerlink" title="3.2.Dockerfile语法"></a>3.2.Dockerfile语法</h2><p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p><p>我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。</p><p>而描述上述信息的文件就是Dockerfile文件。</p><p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p><p><img src="/../docker_pic/image-20210731180321133.png" alt="image-20210731180321133"></p><p>更新详细语法说明，请参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p><h2 id="3-3-构建Java项目"><a href="#3-3-构建Java项目" class="headerlink" title="3.3.构建Java项目"></a>3.3.构建Java项目</h2><h3 id="3-3-1-基于Ubuntu构建Java项目"><a href="#3-3-1-基于Ubuntu构建Java项目" class="headerlink" title="3.3.1.基于Ubuntu构建Java项目"></a>3.3.1.基于Ubuntu构建Java项目</h3><p>需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目</p><ul><li><p>步骤1：新建一个空文件夹docker-demo</p><p><img src="/../docker_pic/image-20210801101207444.png" alt="image-20210801101207444"></p></li><li><p>步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录</p><p><img src="/../docker_pic/image-20210801101314816.png" alt="image-20210801101314816"></p></li><li><p>步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录</p><p><img src="/../docker_pic/image-20210801101410200.png" alt="image-20210801101410200"></p></li><li><p>步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录</p><p><img src="/../docker_pic/image-20210801101455590.png" alt="image-20210801101455590"></p><p>其中的内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 指定基础镜像</span><br><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">16.04</span><br><span class="hljs-comment"># 配置环境变量，JDK的安装目录</span><br><span class="hljs-keyword">ENV</span> JAVA_DIR=/usr/local<br><br><span class="hljs-comment"># 拷贝jdk和java项目的包</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="hljs-variable">$JAVA_DIR</span>/</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span><br><br><span class="hljs-comment"># 安装JDK</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> <span class="hljs-variable">$JAVA_DIR</span> \</span><br><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span><br><span class="language-bash"> &amp;&amp; <span class="hljs-built_in">mv</span> ./jdk1.8.0_144 ./java8</span><br><br><span class="hljs-comment"># 配置环境变量</span><br><span class="hljs-keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8<br><span class="hljs-keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin<br><br><span class="hljs-comment"># 暴露端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8090</span><br><span class="hljs-comment"># 入口，java项目的启动命令</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span><br></code></pre></td></tr></table></figure></li><li><p>步骤5：进入docker-demo</p><p>将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下</p></li><li><p>步骤6：运行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker build -t javaweb:1.0 .<br></code></pre></td></tr></table></figure></li></ul><p>最后访问 <a href="http://192.168.150.101:8090/hello/count%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84ip%E6%94%B9%E6%88%90%E4%BD%A0%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BAip">http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip</a></p><h3 id="3-3-2-基于java8构建Java项目"><a href="#3-3-2-基于java8构建Java项目" class="headerlink" title="3.3.2.基于java8构建Java项目"></a>3.3.2.基于java8构建Java项目</h3><p>虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p><p>例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。</p><p>需求：基于java:8-alpine镜像，将一个Java项目构建为镜像</p><p>实现思路如下：</p><ul><li><p>① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile</p></li><li><p>② 拷贝课前资料提供的docker-demo.jar到这个目录中</p></li><li><p>③ 编写Dockerfile文件：</p><ul><li><p>a ）基于java:8-alpine作为基础镜像</p></li><li><p>b ）将app.jar拷贝到镜像中</p></li><li><p>c ）暴露端口</p></li><li><p>d ）编写入口ENTRYPOINT</p><p>内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span>-alpine<br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./app.jar /tmp/app.jar</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8090</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>④ 使用docker build命令构建镜像</p></li><li><p>⑤ 使用docker run创建容器并运行</p></li></ul><h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4.小结"></a>3.4.小结</h2><p>小结：</p><ol><li><p>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</p></li><li><p>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</p></li><li><p>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</p></li></ol><h1 id="4-Docker-Compose"><a href="#4-Docker-Compose" class="headerlink" title="4.Docker-Compose"></a>4.Docker-Compose</h1><p>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p><p><img src="/../docker_pic/image-20210731180921742.png" alt="image-20210731180921742"></p><h2 id="4-1-初识DockerCompose"><a href="#4-1-初识DockerCompose" class="headerlink" title="4.1.初识DockerCompose"></a>4.1.初识DockerCompose</h2><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json">version<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3.8&quot;</span><br> services<span class="hljs-punctuation">:</span><br>  mysql<span class="hljs-punctuation">:</span><br>    image<span class="hljs-punctuation">:</span> mysql<span class="hljs-punctuation">:</span><span class="hljs-number">5.7</span><span class="hljs-number">.25</span><br>    environment<span class="hljs-punctuation">:</span><br>     MYSQL_ROOT_PASSWORD<span class="hljs-punctuation">:</span> <span class="hljs-number">123</span> <br>    volumes<span class="hljs-punctuation">:</span><br>     - <span class="hljs-string">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span><br>     - <span class="hljs-string">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span><br>  web<span class="hljs-punctuation">:</span><br>    build<span class="hljs-punctuation">:</span> .<br>    ports<span class="hljs-punctuation">:</span><br>     - <span class="hljs-string">&quot;8090:8090&quot;</span><br><br></code></pre></td></tr></table></figure><p>上面的Compose文件就描述一个项目，其中包含两个容器：</p><ul><li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li><li>web：一个基于<code>docker build</code>临时构建的镜像容器，映射端口时8090</li></ul><p>DockerCompose的详细语法参考官网：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p><p>其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。</p><h2 id="4-2-安装DockerCompose"><a href="#4-2-安装DockerCompose" class="headerlink" title="4.2.安装DockerCompose"></a>4.2.安装DockerCompose</h2><p>参考课前资料</p><h2 id="4-3-部署微服务集群"><a href="#4-3-部署微服务集群" class="headerlink" title="4.3.部署微服务集群"></a>4.3.部署微服务集群</h2><p><strong>需求</strong>：将之前学习的cloud-demo微服务集群利用DockerCompose部署</p><p><strong>实现思路</strong>：</p><p>① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件</p><p>② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名</p><p>③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar</p><p>④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中</p><p>⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署</p><h3 id="4-3-1-compose文件"><a href="#4-3-1-compose文件" class="headerlink" title="4.3.1.compose文件"></a>4.3.1.compose文件</h3><p>查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录：</p><p><img src="/../docker_pic/image-20210731181341330.png" alt="image-20210731181341330"></p><p>内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.2&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">nacos:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nacos/nacos-server</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MODE:</span> <span class="hljs-string">standalone</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8848:8848&quot;</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7.25</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-number">123</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;$PWD/mysql/data:/var/lib/mysql&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;</span><br>  <span class="hljs-attr">userservice:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./user-service</span><br>  <span class="hljs-attr">orderservice:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./order-service</span><br>  <span class="hljs-attr">gateway:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./gateway</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;10010:10010&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到，其中包含5个service服务：</p><ul><li><code>nacos</code>：作为注册中心和配置中心<ul><li><code>image: nacos/nacos-server</code>： 基于nacos&#x2F;nacos-server镜像构建</li><li><code>environment</code>：环境变量<ul><li><code>MODE: standalone</code>：单点模式启动</li></ul></li><li><code>ports</code>：端口映射，这里暴露了8848端口</li></ul></li><li><code>mysql</code>：数据库<ul><li><code>image: mysql:5.7.25</code>：镜像版本是mysql:5.7.25</li><li><code>environment</code>：环境变量<ul><li><code>MYSQL_ROOT_PASSWORD: 123</code>：设置数据库root账户的密码为123</li></ul></li><li><code>volumes</code>：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据</li></ul></li><li><code>userservice</code>、<code>orderservice</code>、<code>gateway</code>：都是基于Dockerfile临时构建的</li></ul><p>查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表：</p><p><img src="/../docker_pic/image-20210801095205034.png" alt="image-20210801095205034"></p><p>查看微服务目录，可以看到都包含Dockerfile文件：</p><p><img src="/../docker_pic/image-20210801095320586.png" alt="image-20210801095320586"></p><p>内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span>-alpine<br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./app.jar /tmp/app.jar</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span><br></code></pre></td></tr></table></figure><h3 id="4-3-2-修改微服务配置"><a href="#4-3-2-修改微服务配置" class="headerlink" title="4.3.2.修改微服务配置"></a>4.3.2.修改微服务配置</h3><p>因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。</p><p>如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://mysql:3306/cloud_order?useSSL=false</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">orderservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">nacos:8848</span> <span class="hljs-comment"># nacos服务地址</span><br></code></pre></td></tr></table></figure><h3 id="4-3-3-打包"><a href="#4-3-3-打包" class="headerlink" title="4.3.3.打包"></a>4.3.3.打包</h3><p>接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。</p><p>可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 服务打包的最终名称 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>app<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>打包后：</p><p><img src="/../docker_pic/image-20210801095951030.png" alt="image-20210801095951030"></p><h3 id="4-3-4-拷贝jar包到部署目录"><a href="#4-3-4-拷贝jar包到部署目录" class="headerlink" title="4.3.4.拷贝jar包到部署目录"></a>4.3.4.拷贝jar包到部署目录</h3><p>编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。</p><p>user-service：</p><p><img src="/../docker_pic/image-20210801100201253.png" alt="image-20210801100201253"></p><p>order-service：</p><p><img src="/../docker_pic/image-20210801100231495.png" alt="image-20210801100231495"></p><p>gateway：</p><p><img src="/../docker_pic/image-20210801100308102.png" alt="image-20210801100308102"></p><h3 id="4-3-5-部署"><a href="#4-3-5-部署" class="headerlink" title="4.3.5.部署"></a>4.3.5.部署</h3><p>最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。</p><p>上传到任意目录：</p><p><img src="/../docker_pic/image-20210801100955653.png" alt="image-20210801100955653"></p><p>部署：</p><p>进入cloud-demo目录，然后运行下面的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker-compose up -d<br></code></pre></td></tr></table></figure><h1 id="5-Docker镜像仓库"><a href="#5-Docker镜像仓库" class="headerlink" title="5.Docker镜像仓库"></a>5.Docker镜像仓库</h1><h2 id="5-1-搭建私有镜像仓库"><a href="#5-1-搭建私有镜像仓库" class="headerlink" title="5.1.搭建私有镜像仓库"></a>5.1.搭建私有镜像仓库</h2><p>参考课前资料《CentOS7安装Docker.md》</p><h2 id="5-2-推送、拉取镜像"><a href="#5-2-推送、拉取镜像" class="headerlink" title="5.2.推送、拉取镜像"></a>5.2.推送、拉取镜像</h2><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p><p>① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080&#x2F;</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure><p>② 推送镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker push 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure><p>③ 拉取镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringMvc</title>
    <link href="/2023/02/22/JavaWeb/"/>
    <url>/2023/02/22/JavaWeb/</url>
    
    <content type="html"><![CDATA[<h2 id="Seesion和Cookie"><a href="#Seesion和Cookie" class="headerlink" title="Seesion和Cookie"></a>Seesion和Cookie</h2><ul><li>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li><li>有效期不同，Cookie  可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li><li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li><li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li><li>session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到。Cookie有个setPath的方法，可以设置可访问的路径，那么同一个网站中不同路径下的cookie互相是访问不到的</li></ul><h2 id="什么是-Cookie："><a href="#什么是-Cookie：" class="headerlink" title="什么是 Cookie："></a>什么是 Cookie：</h2><p>Cookie是服务器发送到客户端并保存在本地的一小块数据，它会在客户端下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。cookie中的数据以{key：value}的形式存在。</p><h3 id="cookie机制原理："><a href="#cookie机制原理：" class="headerlink" title="cookie机制原理："></a>cookie机制原理：</h3><p>比如服务端要想记录用户的状态，就使用response向浏览器发送一个Cookie。客户端浏览器会将这个cookie保存起来。浏览器再次请求服务端时，浏览器会把这个cookie带上。服务端检查这个cookie来获取用户状态。</p><h3 id="Cookie常用属性："><a href="#Cookie常用属性：" class="headerlink" title="Cookie常用属性："></a>Cookie常用属性：</h3><ul><li>name cookie的名字，Cookie一旦创建，名称便不可更改</li><li>value cookie的值</li><li>domain 可以访问该cookie的域名。如果设置为“.baidu.com”，则所有以“baidu.com”结尾的域名都可以访问该Cookie；第一个字符必须为“.”</li><li>maxAge Cookie失效的时间，单位秒。 正数，则超过maxAge秒之后失效。 负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。 为0，表示删除该Cookie。</li><li>isHttpOnly HttpOnly属性是用来限制非HTTP协议程序接口对客户端Cookie进行访问，将取Cookie的操作放到服务端，这样能有效的防止XSS攻击。</li></ul><h3 id="创建Cookie："><a href="#创建Cookie：" class="headerlink" title="创建Cookie："></a>创建Cookie：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;cookieSessionId&quot;</span>,<span class="hljs-string">&quot;qwertyuiop&quot;</span>); <span class="hljs-comment">//构造函数</span><br>cookie.setDomain(<span class="hljs-string">&quot;.baidu.com&quot;</span>);             <span class="hljs-comment">// 设置域名</span><br>cookie.setPath(<span class="hljs-string">&quot;/&quot;</span>);                        <span class="hljs-comment">// 设置路径</span><br>cookie.setMaxAge(Integer.MAX_VALUE);        <span class="hljs-comment">// 设置有效期为永久</span><br>response.addCookie(cookie);                 <span class="hljs-comment">// 回写到客户端</span><br></code></pre></td></tr></table></figure><h3 id="Cookie更新与删除："><a href="#Cookie更新与删除：" class="headerlink" title="Cookie更新与删除："></a>Cookie更新与删除：</h3><p>Cookie本身并没有提供修改和删除的方法，一般通过使用相同name的Cookie来覆盖原来的Cookie,以达到更新或删除的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;cookieSessionId&quot;</span>,<span class="hljs-string">&quot;new-qwertyuiop&quot;</span>);<br>response.addCookie(cookie);<br><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;cookieSessionId&quot;</span>,<span class="hljs-string">&quot;new-qwertyuiop&quot;</span>);<br>cookie.setMaxAge(<span class="hljs-number">0</span>);<span class="hljs-comment">//设置一个立即失效的cookie覆盖原cookie</span><br>response.addCookie(cookie);<br></code></pre></td></tr></table></figure><h3 id="如何获取与发送cookie"><a href="#如何获取与发送cookie" class="headerlink" title="如何获取与发送cookie"></a>如何获取与发送cookie</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//服务端从客户端取得cookie</span><br>Cookie[] cookies = request.getCookies();<br><br><span class="hljs-comment">//服务端向客户端发送cookie</span><br>response.addCookie(cookie);   <br></code></pre></td></tr></table></figure><p>对于Cookie来说，Cookie的同源只关注域名，是忽略协议和端口的。所以一般情况下，<a href="https://localhost:80和http://localhost:8080的Cookie是共享的。单个">https://localhost:80和http://localhost:8080的Cookie是共享的。单个</a> Cookie 保存的数据不能超过 4K。</p><h3 id="cookie的优缺点："><a href="#cookie的优缺点：" class="headerlink" title="cookie的优缺点："></a>cookie的优缺点：</h3><ul><li>优点： 适合用于存放需要每个请求都必须携带的数据 服务端也可以直接操作 Cookie 可以通过 domain 以及 path 控制数据存储的范围</li><li>缺点： 容量有限，规范只要求每个域名下最低提供 4kb 的存储空间 每次请求都会携带，如果存放了大量不必要的数据很显然会影响页面性能 不安全，永远不要在 Cookie 中存放用户的敏感数据 前端 API 不友好，CRUD 都是通过 document.cookie 进行，没有提供相关操作的方法</li></ul><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><blockquote><p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p></blockquote><h3 id="session机制原理："><a href="#session机制原理：" class="headerlink" title="session机制原理："></a>session机制原理：</h3><p>当客户端请求创建一个session时，服务端会先检查客户端的请求里面有没有带着session标识-sessionId。如果有，则说明服务器以前已为此客户端创建过session，于是就根据这个sessionId把session检索出来。如果客户端请求中不包含sessionId，则为客户端创建一个session并且生成一个与这个session相关联的sessionId。 这个sessionId将被在本次响应中返回给客户端保存。保存sessionId的方式大多情况下用的是cookie。</p><h3 id="创建session"><a href="#创建session" class="headerlink" title="创建session"></a>创建session</h3><p>HttpSession session &#x3D; request.getSession();</p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h3 id="当接收一个请求时，springMvc的处理流程"><a href="#当接收一个请求时，springMvc的处理流程" class="headerlink" title="当接收一个请求时，springMvc的处理流程"></a>当接收一个请求时，springMvc的处理流程</h3><p><img src="/../web_pic/1.png"></p><h3 id="拦截器概念"><a href="#拦截器概念" class="headerlink" title="拦截器概念"></a>拦截器概念</h3><p><img src="/../web_pic/2.png"></p><h3 id="拦截器与过滤器的区别"><a href="#拦截器与过滤器的区别" class="headerlink" title="拦截器与过滤器的区别"></a>拦截器与过滤器的区别</h3><p><img src="/../web_pic/3.png"></p><h2 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h2><p>MVC是一种软件架构的思想，将软件按照模型，视图，控制器来划分</p><p>M：Model,模型层，指工程中的JavaBean,作用是处理数据</p><p>JavaBean分为两类：</p><ul><li>一类称为实体类Bean:专门存储业务数据的，如Student,User等</li><li>一类称为业务处理Bean：指Service或Dao，专门用于处理业务逻辑和数据访问。</li></ul><p>V：View,视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</p><p>C：Controller,控制层，指工程中的Servlet,作用是接收请求和响应浏览器</p><p>MVC的工作流程：</p><p>用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller,Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Juc</title>
    <link href="/2023/02/22/Juc/"/>
    <url>/2023/02/22/Juc/</url>
    
    <content type="html"><![CDATA[<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><p>在Java中，线程部分是一个重点，本篇文章说的JUC也是关于线程的。JUC就是java.util.concurrent工具包的简称。这是一个处理线程的工具包。</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p><strong>进程</strong> 是计算机中程序关于某数据集合的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p><p><strong>线程</strong>是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><p>简单来说：</p><p>进程：指系统中正在运行的一个应用程序；程序一旦运行就是进程；进程—–资源配分的最小单位</p><p>线程：系统分配处理机时间资源的基本单位，或者说进程之内独立执行的一个单元的执行流。线程—-程序执行的最小单位。</p><p>比如360安全卫士，打开这个软件就是一个进程，里面有木马查杀，垃圾清理，优化加速等可以分别执行的线程。</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>一、<strong>简介</strong><br>volatile是Java提供的一种轻量级的同步机制。Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized（synchronized通常称为重量级锁），volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。</p><p>二、<strong>并发编程的3个基本概念</strong><br>1.<strong>原子性</strong><br>     定义： 即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><pre><code class="hljs">原子性是拒绝多线程操作的，不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。简而言之，在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。例如 a=1是原子性操作，但是a++和a +=1就不是原子性操作。Java中的原子性操作包括：</code></pre><p>（1）基本类型的读取和赋值操作，且赋值必须是值赋给变量，变量之间的相互赋值不是原子性操作。</p><p>（2）所有引用reference的赋值操作</p><p>（3）java.concurrent.Atomic.* 包中所有类的一切操作</p><p>2.<strong>可见性</strong><br>   定义：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p>   在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。Java提供了volatile来保证可见性，当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，其他线程读取共享变量时，会直接从主内存中读取。当然，synchronize和Lock都可以保证可见性。synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><p>3.<strong>有序性</strong><br>   定义：即程序执行的顺序按照代码的先后顺序执行。</p><p>   Java内存模型中的有序性可以总结为：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。</p><p>   在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序不会影响单线程的运行结果，但是对多线程会有影响。Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）。另外，可以通过synchronized和Lock来保证有序性，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p><p>三、<strong>锁的互斥和可见性</strong><br>   锁提供了两种主要特性：互斥（mutual exclusion） 和可见性（visibility）。</p><p>（1）互斥即一次只允许一个线程持有某个特定的锁，一次就只有一个线程能够使用该共享数据。</p><p>（2）可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。也即当一条线程修改了共享变量的值，新值对于其他线程来说是可以立即得知的。如果没有同步机制提供的这种可见性保证，线程看到的共享变  量可能是修改前的值或不一致的值，这将引发许多严重问题。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：</p><pre><code class="hljs">a.对变量的写操作不依赖于当前值。b.该变量没有包含在具有其他变量的不变式中。</code></pre><p>  实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。事实上就是保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p><p>四、<strong>Java的内存模型JMM以及共享变量的可见性</strong><br> JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。</p><p><img src="/../JUC_pic/31.png" alt="juc"></p><p>   对于普通的共享变量来讲，线程A将其修改为某个值发生在线程A的本地内存中，此时还未同步到主内存中去；而线程B已经缓存了该变量的旧值，所以就导致了共享变量值的不一致。解决这种共享变量在多线程模型中的不可见性问题，较粗暴的方式自然就是加锁，但是此处使用synchronized或者Lock这些方式太重量级了，比较合理的方式其实就是volatile。</p><p>  需要注意的是，JMM是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应cpu缓存和物理内存</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileTest</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">boolean</span> run = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> throws InterruptedException </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span>(run)&#123;<br>                <br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>        t.<span class="hljs-built_in">start</span>();<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        run = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程t不会如预想的停下来</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行以上代码，可以看到结果，程序并没有结束，而是一直处于运行状态，按道理来说主线程不是将run 置于false了吗？t1应该暂停才对啊，这就涉及到可见性问题，主线程在自己的工作内存修改了run的值，但是t1线程不知道主线程修改了run的值，所以一直在运行。</p><p>解决办法：</p><ul><li>将run用volatile修饰</li></ul><p>再次运行程序，程序暂停下来了，说明volatile可以将run在任何一个线程中做出的修改马上让其他线程可见。(volatile是Java提供的一种轻量级的同步机制)</p><ul><li><p>在while(){}里加一个System.out.println();</p><p>点开println()方法</p><p><img src="/../JUC_pic/40.png" alt="juc"></p></li></ul><p>可以看到println()里加了synchronized锁</p><p>JMM关于synchronized的两条规定:</p><p>1）线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值</p><p>2）线程解锁前，必须把共享变量的最新值刷新到主内存中</p><p>（注意：加锁与解锁需要是同一把锁）</p><p>synchronized具体过程是：</p><p>获得同步锁；<br>清空工作内存；<br>从主内存拷贝对象副本到工作内存；<br>执行代码(计算或者输出等)；<br>刷新主内存数据；<br>释放同步锁。</p><p>五、<strong>volatile变量的特性</strong><br> 1.保证可见性，不保证原子性<br>  （1）当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去；</p><p>  （2）这个写会操作会导致其他线程中的volatile变量缓存无效。</p><p> 2.禁止指令重排<br>    重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：</p><p> （1）重排序操作不会对存在数据依赖关系的操作进行重排序。</p><p>　 比如：a&#x3D;1;b&#x3D;a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。</p><p> （2）重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变</p><p>　 比如：a&#x3D;1;b&#x3D;2;c&#x3D;a+b这三个操作，第一步（a&#x3D;1)和第二步(b&#x3D;2)由于不存在数据依赖关系， 所以可能会发生重排序，但是c&#x3D;a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c&#x3D;a+b&#x3D;3。</p><pre><code class="hljs">重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果，下例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行status=true再执行a=2。而此时线程B会顺利到达4处，而线程A中a=2这个操作还未被执行，所以b=a+1的结果也有可能依然等于2。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestVolatile</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//状态切换为true</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> changeStatus&#123;<br>        a = <span class="hljs-number">2</span>;   <span class="hljs-comment">//1</span><br>        status = <span class="hljs-literal">true</span>;  <span class="hljs-comment">//2</span><br>    &#125;<span class="hljs-comment">//若状态为true，则为running</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(status)&#123;   <span class="hljs-comment">//3</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a + <span class="hljs-number">1</span>;  <span class="hljs-comment">//4</span><br>        System.out.println(b);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​     使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序,volatile禁止指令重排序也有一些规则：</p><pre><code class="hljs"> a.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； b.在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见。</code></pre><p>六、<strong>volatile不适用的场景</strong><br> 1.volatile不适合复合操作<br>  例如，int++不是一个原子性操作，可以由读取、加、赋值3步组成，所以结果并不能达到30000。.</p><p><img src="/../JUC_pic/32.png"></p><p>  2.解决方法<br> （1）采用synchronized</p><p><img src="/../JUC_pic/33.png"></p><p> （2）采用Lock</p><p><img src="/../JUC_pic/34.png"></p><p> （3）采用java并发包中的原子操作类，原子操作类是通过CAS循环的方式来保证其原子性的</p><p><img src="/../JUC_pic/35.png"></p><p>七、<strong>volatile原理</strong><br>  volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p><p>（1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p><p>（2）它会强制将对缓存的修改操作立即写入主存；</p><p>（3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p><p>八、<strong>单例模式的双重锁为什么要加volatile</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestInstance</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> TestInstance instance;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestInstance <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span>(TestInstance.class)&#123; <br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestInstance</span>();<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>   需要volatile关键字的原因是，在并发情况下，如果没有volatile关键字，在第5行会出现问题。instance &#x3D; new TestInstance();可以分解为3行伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">a. memory = allocate() <span class="hljs-comment">//分配内存</span><br>b. ctorInstanc(memory) <span class="hljs-comment">//初始化对象</span><br>c. instance = memory <span class="hljs-comment">//设置instance指向刚分配的地址 </span><br></code></pre></td></tr></table></figure><p>   上面的代码在编译运行时，可能会出现重排序从a-b-c排序为a-c-b。在多线程的情况下会出现以下问题。当线程A在执行第5行代码时，B线程进来执行到第2行代码。假设此时A执行的过程中发生了指令重排序，即先执行了a和c，没有执行b。那么由于A线程执行了c导致instance指向了一段地址，所以B线程判断instance不为null，会直接跳到第6行并返回一个未初始化的对象。</p><h2 id="创建多线程的几种方式"><a href="#创建多线程的几种方式" class="headerlink" title="创建多线程的几种方式"></a>创建多线程的几种方式</h2><h3 id="继承Thread类创建线程"><a href="#继承Thread类创建线程" class="headerlink" title="继承Thread类创建线程"></a>继承Thread类创建线程</h3><p><strong>通过继承Thread</strong>类来创建并启动多线程的一般步骤如下：</p><p>1】定义Tread类的子类MyThread，并重写run()方法.run()方法的方法体（线程执行体）就是线程要执行的任务。</p><p>2】创建My<a href="https://so.csdn.net/so/search?q=Thread%E7%B1%BB&spm=1001.2101.3001.7020">Thread类</a>的实例</p><p>3】调用子类实例的start()方法来启动线程</p><p>创建Thread1类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;a&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建Thread2类</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    public void run() &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;b&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在主方法中：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        Thread t1 =<span class="hljs-keyword">new</span> <span class="hljs-type">Thread1</span>();<br>        Thread t2 =<span class="hljs-keyword">new</span> <span class="hljs-type">Thread2</span>();<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现-Runnable接口创建线程"><a href="#实现-Runnable接口创建线程" class="headerlink" title="实现 Runnable接口创建线程"></a><strong>实现 Runnable接口创建线程</strong></h3><p>通过实现Runnable接口创建并启动线程的一般步骤如下：</p><p>1】定义Runnable接口的实现类，必须重写run(）方法，这个run()方法和Thread中的run()方法一样，是线程的执行体</p><p>2】创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象</p><p>3】调用start()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;: &quot;</span>+i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">RunnableTest</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableTest</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r,<span class="hljs-string">&quot;线程1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r,<span class="hljs-string">&quot;线程2&quot;</span>);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">线程2: 0</span><br><span class="hljs-section">线程2: 1</span><br><span class="hljs-section">线程1: 0</span><br><span class="hljs-section">线程2: 2</span><br><span class="hljs-section">线程1: 1</span><br><span class="hljs-section">线程2: 3</span><br><span class="hljs-section">线程1: 2</span><br><span class="hljs-section">线程2: 4</span><br><span class="hljs-section">线程1: 3</span><br><span class="hljs-section">线程1: 4</span><br></code></pre></td></tr></table></figure><h3 id="继承Thread和实现Runnable接口的区别"><a href="#继承Thread和实现Runnable接口的区别" class="headerlink" title="继承Thread和实现Runnable接口的区别"></a>继承Thread和实现Runnable接口的区别</h3><ul><li>实现Runnable接口避免单继承局限</li><li>当子类实现Runnable接口，此时子类</li></ul><h3 id="实现Callable接口配合FutureTask"><a href="#实现Callable接口配合FutureTask" class="headerlink" title="实现Callable接口配合FutureTask"></a>实现Callable接口配合FutureTask</h3><p>实现</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gcode">步骤：<br><span class="hljs-number">1.</span>创建一个实现Callable的实现类<br><span class="hljs-number">2.</span>实现<span class="hljs-keyword">call</span>方法，将此线程需要执行的操作声明在<span class="hljs-keyword">call</span><span class="hljs-comment">()</span>中<br><span class="hljs-number">3.</span>创建Callable接口实现类的对象<br><span class="hljs-number">4.</span>将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象<br><span class="hljs-number">5.</span>将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start<span class="hljs-comment">()</span><br><span class="hljs-number">6.</span>获取Callable中<span class="hljs-keyword">call</span>方法的返回值<br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">**实现Callable接口的方式创建线程的强大之处**<br><span class="hljs-keyword">call</span><span class="hljs-comment">()</span>可以有返回值的<br><span class="hljs-keyword">call</span><span class="hljs-comment">()</span>可以抛出异常，被外面的操作捕获，获取异常的信息<br>Callable是支持泛型的<br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadNew</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        <span class="hljs-comment">//3.创建Callable接口实现类的对象</span><br>        NumThread numThread = <span class="hljs-keyword">new</span> NumThread();<br><br>        <span class="hljs-comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span><br>        FutureTask futureTask = <span class="hljs-keyword">new</span> FutureTask(numThread);<br><br>        <span class="hljs-comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span><br>        <span class="hljs-keyword">new</span> Thread(futureTask).start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//6.获取Callable中call方法的返回值</span><br>            <span class="hljs-comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span><br>            Object <span class="hljs-keyword">sum</span> = futureTask.get();<br>            System.out.println(<span class="hljs-string">&quot;总和为：&quot;</span> + <span class="hljs-keyword">sum</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_ inherited__">Callable</span> &#123;<br>    <span class="hljs-comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span><br>    @Override<br>    <span class="hljs-keyword">public</span> Object call() throws Exception &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//把100以内的偶数相加</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(i);<br>                <span class="hljs-keyword">sum</span> += i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">sum</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程池创建"><a href="#线程池创建" class="headerlink" title="线程池创建"></a>线程池创建</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">来自项目中的代码<br><span class="hljs-comment">//定义一个线程池</span><br>    <span class="hljs-keyword">private</span> static final ExecutorService CACHE_REBUILD_EXECUTOR =      <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">FixedThreadPool(10)</span>;<br>  .<br>  .<br>  .<br>  .<br>      <span class="hljs-comment">//6.3获取锁成功 ，开启独立线程进行缓存重建</span><br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CACHE_REBUILD_EXECUTOR</span>.</span></span>submit(<span class="hljs-literal">()</span>-&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//查询数据库</span><br>                    R r1 = dbFallback.apply(id);<br>                    <span class="hljs-comment">//写入redis</span><br>                    this.set<span class="hljs-constructor">WithLogicExpire(<span class="hljs-params">key</span>,<span class="hljs-params">r1</span>,<span class="hljs-params">time</span>,<span class="hljs-params">unit</span>)</span>;<br>                &#125; catch (Exception e) &#123;<br>                    throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">RuntimeException(<span class="hljs-params">e</span>)</span>;<br>                &#125;finally &#123;<br>                    <span class="hljs-comment">//释放🔒</span><br>                    unlock(lockKey);<br>                &#125;<br>            &#125;);<br>    <br>  <br></code></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h3><ul><li><strong>互斥条件</strong>：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。</li><li><strong>不可剥夺条件</strong>：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。</li><li><strong>请求和保持条件</strong>：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。</li><li><strong>循环等待条件</strong>：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源。</li></ul><p>以上给出了导致死锁的四个必要条件，只要系统发生死锁则以上四个条件至少有一个成立。事实上循环等待的成立蕴含了前三个条件的成立，似乎没有必要列出然而考虑这些条件对死锁的预防是有利的，因为可以通过破坏四个条件中的任何一个来预防死锁的发生。</p><p>面试官：手写一个死锁demo~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">deadLockDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadLockTusk</span>(lock1,lock2,<span class="hljs-literal">true</span>),<span class="hljs-string">&quot;线程1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadLockTusk</span>(lock1,lock2,<span class="hljs-literal">false</span>),<span class="hljs-string">&quot;线程2&quot;</span>).start();<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockTusk</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>        <span class="hljs-keyword">private</span> Object lock1;<br>        <span class="hljs-keyword">private</span> Object lock2;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> flag;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DeadLockTusk</span><span class="hljs-params">(Object lock1, Object lock2, <span class="hljs-type">boolean</span> flag)</span> &#123;<br>            <span class="hljs-built_in">this</span>.lock1 = lock1;<br>            <span class="hljs-built_in">this</span>.lock2 = lock2;<br>            <span class="hljs-built_in">this</span>.flag = flag;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span>(flag) &#123;<br>                <span class="hljs-keyword">synchronized</span> (lock1)&#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;拿到了锁1&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;等待锁2释放&quot;</span>);<br>                    <span class="hljs-keyword">synchronized</span> (lock2)&#123;<br>                        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;拿到了锁2&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!flag) &#123;<br>                <span class="hljs-keyword">synchronized</span> (lock2)&#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;拿到了锁2&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;等待锁1释放&quot;</span>);<br>                    <span class="hljs-keyword">synchronized</span> (lock1)&#123;<br>                        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;拿到了锁1&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>我们可以通过破坏死锁产生的4个必要条件来 预防死锁，由于资源互斥是资源使用的固有特性是无法改变的。</p><ul><li><strong>破坏“不可剥夺”条件</strong>：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间它占有的资源将被隐式的释放重新加入到 系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。</li><li><strong>破坏”请求与保持条件“</strong>：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。</li><li><strong>破坏“循环等待”条件</strong>：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。</li></ul><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p><ul><li>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</li><li>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</li><li>BLOCKED ：阻塞状态，需要等待锁释放。</li><li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。(不见不散)</li><li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。（过时不候）</li><li>TERMINATED：终止状态，表示该线程已经运行完毕。</li></ul><p><img src="/../JUC_pic/1.png"></p><p>由上图可以看出：</p><ul><li><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p></li><li><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</p></li><li><p><strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</p></li><li><p>当线程进入 <code>synchronized</code> 方法&#x2F;块或者调用 <code>wait</code> 后（被 <code>notify</code>）重新进入 <code>synchronized</code> 方法&#x2F;块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。</p></li><li><p>线程在执行完了 <code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p></li></ul><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><ul><li>需要等待结果返回才能继续运行就是同步</li><li>不需要等待结果返回就能继续运行就是异步</li></ul><h2 id="查看进程和线程的方法"><a href="#查看进程和线程的方法" class="headerlink" title="查看进程和线程的方法"></a>查看进程和线程的方法</h2><p>Windows</p><ul><li>任务管理器</li><li>tasklist查看进程 ( tasklist | findstr “xx”)</li><li>taskkill杀死进程</li></ul><p>Linux</p><ul><li>ps  -ef查看所有进程(ps -ef | grep 关键字)</li><li>ps -fT -p <PID> 查看某个进程(PID)的所有线程</li><li>kill 杀死进程</li><li>top 按大写H切换是否显示线程</li><li>top -H -p <PID> 查看某个进程(PID)的所有线程</li></ul><p>Java</p><ul><li>jps命令查看所有Java进程</li><li>jstack <PID>查看某个Java进程(PID)的所有线程状态</li><li>jconsole来查看某个Java进程中线程的运行情况(图像界面)</li></ul><h2 id="线程中的常见方法"><a href="#线程中的常见方法" class="headerlink" title="线程中的常见方法"></a>线程中的常见方法</h2><p><img src="/../JUC_pic/2.png"></p><p><img src="/../JUC_pic/3.png"></p><p><img src="/../JUC_pic/4.png"></p><h3 id="start与run的区别"><a href="#start与run的区别" class="headerlink" title="start与run的区别"></a>start与run的区别</h3><ul><li><p>直接调用 run 是在主线程中执行了 run，没有启动新的线程</p></li><li><p>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</p></li></ul><h3 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h3><ol><li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException </li><li>睡眠结束后的线程未必会立刻得到执行</li><li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li></ol><h3 id="yield-让出，谦让"><a href="#yield-让出，谦让" class="headerlink" title="yield(让出，谦让)"></a>yield(让出，谦让)</h3><ol><li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程 </li><li>具体的实现依赖于操作系统的任务调度器</li></ol><h3 id="join-重要"><a href="#join-重要" class="headerlink" title="join(重要)"></a>join(重要)</h3><p>下面的代码执行，打印 r 是什么？</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">static</span> int r = <span class="hljs-number">0</span>;<br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br> test1();<br>&#125;<br>private <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> test1() throws InterruptedException &#123;<br> log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br> Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;开始&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> sleep(<span class="hljs-number">1</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;结束&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> r = <span class="hljs-number">10</span>;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;结果为:&#123;&#125;&quot;</span>, r)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;结束&quot;</span>)</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>分析</p><ul><li>因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出 r&#x3D;10</li><li>而主线程一开始就要打印 r 的结果，所以只能打印出 r&#x3D;0</li></ul><p>解决方法 </p><ul><li>用 sleep 行不行？为什么？</li><li>用 join，加在 t1.start() 之后即可</li></ul><p>Eg:  t1.join()  &#x3D;&#x3D; 主线程等待t1运行结束再运行后面的内容。</p><p>加了join，异步—&gt;同步</p><h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><p><strong>注意</strong>：interrupt只会给线程打个标记，不会真的打断线程，要打断线程还是得靠isInterrupted()方法判断再决定是否打断。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br>        Thread thread=<span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                System.out.println(<span class="hljs-string">&quot;正在运行。。。&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;,<span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">thread</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">Thread</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">500</span>)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">thread</span>.<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br></code></pre></td></tr></table></figure><p>结果是不断得打印“正在运行。。。”</p><p>可以打断 sleep，wait，join 的线程</p><p>这几个方法都会让线程进入阻塞状态</p><p>打断sleep,wait,join的线程，会清空打断状态</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">private <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> test1() throws InterruptedException &#123;<br> Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> sleep(<span class="hljs-number">1</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">0.5</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted())</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输出:<br>java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.InterruptedException</span>: sleep interrupted<br> at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.sleep</span>(Native Method)<br> at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.sleep</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">340</span>)<br> at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.TimeUnit</span><span class="hljs-selector-class">.sleep</span>(TimeUnit<span class="hljs-selector-class">.java</span>:<span class="hljs-number">386</span>)<br> at cn<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.n2</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Sleeper</span><span class="hljs-selector-class">.sleep</span>(Sleeper<span class="hljs-selector-class">.java</span>:<span class="hljs-number">8</span>)<br> at cn<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.n4</span><span class="hljs-selector-class">.TestInterrupt</span>.lambda<span class="hljs-variable">$test1</span>$<span class="hljs-number">3</span>(TestInterrupt<span class="hljs-selector-class">.java</span>:<span class="hljs-number">59</span>)<br> at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.run</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">745</span>)<br><span class="hljs-number">21</span>:<span class="hljs-number">18</span>:<span class="hljs-number">10.374</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 打断状态: false<br></code></pre></td></tr></table></figure><p>打断正常运行的线程, 不会清空打断状态</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript">private <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> test2() throws InterruptedException &#123;<br> Thread t2 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> Thread thread = Thread.currentThread();</span></span><br><span class="hljs-params"><span class="hljs-function"> boolean interrupted = thread.isInterrupted();</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">if</span>(interrupted) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">break</span>;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t2&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">0.5</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t2</span>.<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">37</span>.<span class="hljs-number">964</span><span class="hljs-meta"> [t2] c.TestInterrupt - 打断状态: true </span><br></code></pre></td></tr></table></figure><h3 id="两阶段终止模式"><a href="#两阶段终止模式" class="headerlink" title="两阶段终止模式"></a>两阶段终止模式</h3><p>Two Phase Termination</p><p>在一个线程T1中如何‘优雅“终止线程T2？这里的”优雅“指的是给T2一个料理后事的机会</p><p>比如释放资源，避免不释放资源的情况</p><p><img src="/../JUC_pic/5.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws InterruptedException</span> &#123;<br>        TwoPhaseTermination tpt = <span class="hljs-keyword">new</span> TwoPhaseTermination();<br>        tpt.start();<br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        tpt.stop();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">TwoPhaseTermination</span> &#123;<br>    <span class="hljs-keyword">private</span> Thread monitor;<br>    <span class="hljs-comment">// 启动监控线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span>()</span> &#123;<br>        monitor = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            @Override<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    Thread thread = Thread.currentThread();<br>                    <span class="hljs-keyword">if</span> (thread.isInterrupted()) &#123;<span class="hljs-comment">//通过线程自带的是否被中断过标签</span><br>                        <span class="hljs-comment">/*</span><br><span class="hljs-comment">                         *被打断后的操作，业务处理在这里处理</span><br><span class="hljs-comment">                        */</span><br>                        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;后置处理&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">// 睡眠</span><br>                        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;执行监控记录&quot;</span>);<span class="hljs-comment">// 在此被打断不会异常</span><br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<span class="hljs-comment">// 在睡眠期间被打断，进入异常处理的逻辑</span><br>                        e.printStackTrace();<br>                        <span class="hljs-comment">// 重新设置打断标记，打断 sleep 会清除打断状态</span><br>                        thread.interrupt();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        monitor.start();<br>    &#125;<br>    <span class="hljs-comment">// 停止监控线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span>()</span> &#123;<br>        monitor.interrupt();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="park"><a href="#park" class="headerlink" title="park"></a>park</h3><p>使用park，线程会在该处停止，可以用interrupt方法打断使其继续运行，但是interrupt会使打断标记为true，park接下来会失效，不会阻塞，isInterruped方法不会清除打断标记，打断标记依然为ture，park依然失效，此时使用Interruped方法，会清除打断标记，此时打断标记为false，park又可以生效了，继续阻塞。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript">private <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> test3() throws InterruptedException &#123;<br> Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;park...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> LockSupport.park();</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;打断状态：&#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">0.5</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">21</span>:<span class="hljs-number">11</span>:<span class="hljs-number">52.795</span> <span class="hljs-selector-attr">[t1]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - park... <br><span class="hljs-number">21</span>:<span class="hljs-number">11</span>:<span class="hljs-number">53.295</span> <span class="hljs-selector-attr">[t1]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - unpark... <br><span class="hljs-number">21</span>:<span class="hljs-number">11</span>:<span class="hljs-number">53.295</span> <span class="hljs-selector-attr">[t1]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 打断状态：true<br></code></pre></td></tr></table></figure><p>打断标记为真时，park会失效</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript">private <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> test4() &#123;<br> Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;park...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> LockSupport.park();</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;打断状态：&#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">21</span>:<span class="hljs-number">13</span>:<span class="hljs-number">48.783</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - park... <br><span class="hljs-number">21</span>:<span class="hljs-number">13</span>:<span class="hljs-number">49.809</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 打断状态：true <br><span class="hljs-number">21</span>:<span class="hljs-number">13</span>:<span class="hljs-number">49.812</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - park... <br><span class="hljs-number">21</span>:<span class="hljs-number">13</span>:<span class="hljs-number">49.813</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 打断状态：true <br><span class="hljs-number">21</span>:<span class="hljs-number">13</span>:<span class="hljs-number">49.813</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - park... <br><span class="hljs-number">21</span>:<span class="hljs-number">13</span>:<span class="hljs-number">49.813</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 打断状态：true <br><span class="hljs-number">21</span>:<span class="hljs-number">13</span>:<span class="hljs-number">49.813</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - park... <br><span class="hljs-number">21</span>:<span class="hljs-number">13</span>:<span class="hljs-number">49.813</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 打断状态：true <br><span class="hljs-number">21</span>:<span class="hljs-number">13</span>:<span class="hljs-number">49.813</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - park... <br><span class="hljs-number">21</span>:<span class="hljs-number">13</span>:<span class="hljs-number">49.813</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 打断状态：true <br><br></code></pre></td></tr></table></figure><p>提示:</p><p>可以使用 Thread.interrupted() 清除打断状态</p><h3 id="wait-x2F-notify用例"><a href="#wait-x2F-notify用例" class="headerlink" title="wait&#x2F;notify用例"></a>wait&#x2F;notify用例</h3><p>让我们先通过一个示例解析</p><p>wait()方法可以使线程进入等待状态，并且会释放synchronized锁,而notify()可以使等待的状态唤醒。这样的同步机制十分适合生产者、消费者模式：消费者消费某个资源，而生产者生产该资源。当该资源缺失时，消费者调用wait()方法进行自我阻塞，等待生产者的生产；生产者生产完毕后调用notify&#x2F;notifyAll()唤醒消费者进行消费。</p><p>以下是代码示例，其中flag标志表示资源的有无。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ThreadTest &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();  <span class="hljs-comment">//对象锁</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        Thread consume = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Consume(), <span class="hljs-string">&quot;Consume&quot;</span>);<br>        Thread produce = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Produce(), <span class="hljs-string">&quot;Produce&quot;</span>);<br>        consume.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        produce.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            produce.<span class="hljs-keyword">join</span>();<br>            consume.<span class="hljs-keyword">join</span>();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 生产者线程</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> Produce <span class="hljs-keyword">implements</span> Runnable &#123;<br><br>        @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() &#123;<br>            <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>                System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;进入生产者线程&quot;</span>);<br>                System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;生产&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">2000</span>);  <span class="hljs-comment">//模拟生产过程</span><br>                    flag = <span class="hljs-keyword">true</span>;<br>                    obj.notify();  <span class="hljs-comment">//通知消费者</span><br>                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">//模拟其他耗时操作</span><br>                    System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;退出生产者线程&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//消费者线程</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> Consume <span class="hljs-keyword">implements</span> Runnable &#123;<br><br>        @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() &#123;<br>            <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>                System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;进入消费者线程&quot;</span>);<br>                System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;wait flag 1:&quot;</span> + flag);<br>                <span class="hljs-keyword">while</span> (!flag) &#123;  <span class="hljs-comment">//判断条件是否满足，若不满足则等待</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;还没生产，进入等待&quot;</span>);<br>                        obj.wait();<br>                        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;结束等待&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;wait flag 2:&quot;</span> + flag);<br>                System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;消费&quot;</span>);<br>                System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;退出消费者线程&quot;</span>);<br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">进入消费者线程<br><br><span class="hljs-built_in">wait</span> flag 1:<span class="hljs-literal">false</span><br><br>还没生产，进入等待<br><br>进入生产者线程<br><br>生产<br><br>退出生产者线程<br><br>结束等待<br><br><span class="hljs-built_in">wait</span> flag 2:<span class="hljs-literal">true</span><br><br>消费<br><br>退出消费者线程<br></code></pre></td></tr></table></figure><p>理解了输出结果的顺序，也就明白了wait&#x2F;notify的基本用法。有以下几点需要知道：</p><ol><li>在示例中没有体现但很重要的是，<strong>wait&#x2F;notify方法的调用必须处在该对象的锁（Monitor）中，也即，在调用这些方法时首先需要获得该对象的锁。</strong>否则会抛出IllegalMonitorStateException异常。</li><li>从输出结果来看，在生产者调用notify()后，消费者并没有立即被唤醒，而是等到生产者退出同步块后才唤醒执行。（这点其实也好理解，synchronized同步方法（块）同一时刻只允许一个线程在里面，生产者不退出，消费者也进不去）</li><li>注意，消费者被唤醒后是从wait()方法（被阻塞的地方）后面执行，而不是重新从同步块开始。</li></ol><p>这一节我们探讨wait&#x2F;notify与线程状态之间的关系。深入了解线程的生命周期。</p><p>由前面线程的状态转化图可知，当调用wait()方法后，线程会进入WAITING(等待状态)，后续被notify()后，并没有立即被执行，而是进入等待获取锁的阻塞队列。</p><p><img src="/../JUC_pic/39.png"></p><p>对于每个对象来说，都有自己的等待队列和阻塞队列。以前面的生产者、消费者为例，我们拿obj对象作为对象锁，配合图示。内部流程如下</p><ol><li>当线程A（消费者）调用wait()方法后，线程A让出锁，自己进入等待状态，同时加入锁对象的等待队列。</li><li>线程B（生产者）获取锁后，调用notify方法通知锁对象的等待队列，使得线程A从等待队列进入阻塞队列。</li><li>线程A进入阻塞队列后，直至线程B释放锁后，线程A竞争得到锁继续从wait()方法后执行。</li></ol><h2 id="主线程和守护线程"><a href="#主线程和守护线程" class="headerlink" title="主线程和守护线程"></a>主线程和守护线程</h2><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守 护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript">log.debug(<span class="hljs-string">&quot;开始运行...&quot;</span>);<br>Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;开始运行...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> sleep(<span class="hljs-number">2</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;运行结束...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;, <span class="hljs-string">&quot;daemon&quot;</span>)</span>;</span><br><span class="hljs-function">// 设置该线程为守护线程</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">setDaemon</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;运行结束...&quot;</span>)</span>;</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">08</span>:<span class="hljs-number">26</span>:<span class="hljs-number">38.123</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.TestDaemon</span> - 开始运行... <br><span class="hljs-number">08</span>:<span class="hljs-number">26</span>:<span class="hljs-number">38.213</span> <span class="hljs-selector-attr">[daemon]</span> c<span class="hljs-selector-class">.TestDaemon</span> - 开始运行... <br><span class="hljs-number">08</span>:<span class="hljs-number">26</span>:<span class="hljs-number">39.215</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.TestDaemon</span> - 运行结束... <br></code></pre></td></tr></table></figure><p>注意 </p><ul><li>垃圾回收器线程就是一种守护线程 </li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求</li></ul><h2 id="线程的五种状态"><a href="#线程的五种状态" class="headerlink" title="线程的五种状态"></a>线程的五种状态</h2><p>这里的五种状态是从<strong>操作系统</strong>层面描述的</p><p><img src="/../JUC_pic/6.png"></p><ul><li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联 </li><li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行 </li><li>【运行状态】指获取了 CPU 时间片运行中的状态 当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换 </li><li>【阻塞状态】 如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】 <ul><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑 调度它们</li></ul></li><li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h2 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h2><p>这里从<strong>Java API</strong>层面描述的</p><p>根据Thread.State，分为六种状态</p><p><img src="/../JUC_pic/7.png"></p><p><img src="/../JUC_pic/38.png"></p><ul><li><table><thead><tr><th>状态名称</th><th>说明</th></tr></thead><tbody><tr><td>NEW</td><td>初始状态，线程被构建，但未调用start()方法</td></tr><tr><td>RUNNABLE</td><td>运行状态，调用start()方法后。在java线程中，将操作系统线程的就绪和运行统称运行状态</td></tr><tr><td>BLOCKED</td><td>阻塞状态，线程等待进入synchronized代码块或方法中，等待获取锁</td></tr><tr><td>WAITING</td><td>等待状态，线程可调用wait、join等操作使自己陷入等待状态，并等待其他线程做出特定操作（如notify或中断）</td></tr><tr><td>TIMED_WAITING</td><td>超时等待，线程调用sleep(timeout)、wait(timeout)等操作进入超时等待状态，超时后自行返回</td></tr><tr><td>TERMINATED</td><td>终止状态，线程运行结束</td></tr></tbody></table></li></ul><h2 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h2><p>线程安全问题Java体现</p><p>两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">static</span> int counter = <span class="hljs-number">0</span>;<br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br> Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> counter++;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">Thread</span> <span class="hljs-title">t2</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> counter--;</span></span><br><span class="hljs-params"><span class="hljs-function">  &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t2&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t2</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,counter)</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>问题分析</p><p>以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作，要彻底理 解，必须从字节码来进行分析</p><p>例如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">getstatic i <span class="hljs-regexp">//</span> 获取静态变量i的值<br>iconst_1 <span class="hljs-regexp">//</span> 准备常量<span class="hljs-number">1</span><br>iadd <span class="hljs-regexp">//</span> 自增<br>putstatic i <span class="hljs-regexp">//</span> 将修改后的值存入静态变量i<br></code></pre></td></tr></table></figure><p>而对应 i– 也是类似：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">getstatic i <span class="hljs-regexp">//</span> 获取静态变量i的值<br>iconst_1 <span class="hljs-regexp">//</span> 准备常量<span class="hljs-number">1</span><br>isub <span class="hljs-regexp">//</span> 自减<br>putstatic i <span class="hljs-regexp">//</span> 将修改后的值存入静态变量i<br><br></code></pre></td></tr></table></figure><p><img src="/../JUC_pic/8.png"></p><p><img src="/../JUC_pic/9.png"></p><h3 id="临界区-Critical-Section"><a href="#临界区-Critical-Section" class="headerlink" title="临界区 Critical Section"></a>临界区 Critical Section</h3><ul><li>一个程序运行多个线程本身是没有问题的 </li><li>问题出在多个线程访问<strong>共享资源</strong> <ul><li>多个线程读<strong>共享资源</strong>其实也没有问题 </li><li>在多个线程对<strong>共享资源</strong>读写操作时发生指令交错，就会出现问题</li></ul></li><li>一段代码块内如果存在对<strong>共享资源</strong>的多线程读写操作，称这段代码块为<strong>临界区</strong></li></ul><p>例如，下面代码中的临界区</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> counter = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span>() </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区</span></span><br>&#123; <br> counter++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span>() </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区</span></span><br>&#123; <br> counter--;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>解决办法一：加synchronized锁对临界区进行保护</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">static</span> final <span class="hljs-built_in">Object</span> lock =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>    <span class="hljs-keyword">static</span> int counter = <span class="hljs-number">0</span>;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    synchronized (lock)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                        counter++;</span></span><br><span class="hljs-params"><span class="hljs-function">                    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">Thread</span> <span class="hljs-title">t2</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    synchronized (lock)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                        counter--;</span></span><br><span class="hljs-params"><span class="hljs-function">                    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;, <span class="hljs-string">&quot;t2&quot;</span>)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">t1</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">t2</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,counter)</span>;</span><br><span class="hljs-function">    &#125;</span><br></code></pre></td></tr></table></figure><p>你可以做这样的类比：</p><ul><li>synchronized(对象) 中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人 进行计算，线程 t1，t2 想象成两个人</li><li>当线程 t1 执行到 synchronized(room) 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行 count++ 代码</li><li>这时候如果 t2 也运行到了 synchronized(room) 时，它发现门被锁住了，只能在门外等待，发生了上下文切 换，阻塞住了</li><li>这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去哦）， 这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得时间片时才 能开门进入</li><li>当 t1 执行完 synchronized{} 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥 匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 count– 代码</li></ul><p><strong>synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换 所打断。</strong>确保了一个操作的原子性。</p><h3 id="方法上的-synchronized"><a href="#方法上的-synchronized" class="headerlink" title="方法上的 synchronized"></a>方法上的 synchronized</h3><p>一：加在普通方法上</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br> <span class="hljs-keyword">public</span> synchronized <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br> <br> &#125;<br>&#125;<br>等价于<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span></span>) &#123;<br> <br> &#125;<br> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>相当于锁住this对象</p><p>二：加在静态方法上</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br> <span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br> <br> &#125;<br>&#125;<br>等价于<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-title function_">synchronized</span>(<span class="hljs-params">Test.<span class="hljs-keyword">class</span></span>) &#123;<br> <br> &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>加在静态方法上相当于锁住类对象。</p><h2 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h2><h3 id="成员变量和静态变量是否线程安全？"><a href="#成员变量和静态变量是否线程安全？" class="headerlink" title="成员变量和静态变量是否线程安全？"></a>成员变量和静态变量是否线程安全？</h3><ul><li>如果它们没有共享，则线程安全</li><li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><h3 id="局部变量是否线程安全"><a href="#局部变量是否线程安全" class="headerlink" title="局部变量是否线程安全"></a>局部变量是否线程安全</h3><ul><li>局部变量是线程安全的</li><li>但局部变量引用的对象未必<ul><li>如果该对象没有逃离方法的作用访问，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul><h3 id="局部变量线程安全分析"><a href="#局部变量线程安全分析" class="headerlink" title="局部变量线程安全分析"></a>局部变量线程安全分析</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">这里的<span class="hljs-keyword">static</span>是加在方法上，test1()是一个静态方法，i还是局部变量<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span>()</span> &#123;<br> <span class="hljs-built_in">int</span> i = <span class="hljs-number">10</span>;<br> i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">public</span> static void test1();<br> <span class="hljs-attribute">descriptor</span>: ()V<br> <span class="hljs-attribute">flags</span>: ACC_PUBLIC, ACC_STATIC<br> <span class="hljs-attribute">Code</span>:<br> <span class="hljs-attribute">stack</span>=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">0</span><br> <span class="hljs-attribute">0</span>: bipush <span class="hljs-number">10</span><br> <span class="hljs-attribute">2</span>: istore_0<br> <span class="hljs-attribute">3</span>: iinc <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br> <span class="hljs-attribute">6</span>: return<br> <span class="hljs-attribute">LineNumberTable</span>:<br> <span class="hljs-attribute">line</span> <span class="hljs-number">10</span>: <span class="hljs-number">0</span><br> <span class="hljs-attribute">line</span> <span class="hljs-number">11</span>: <span class="hljs-number">3</span><br> <span class="hljs-attribute">line</span> <span class="hljs-number">12</span>: <span class="hljs-number">6</span><br> <span class="hljs-attribute">LocalVariableTable</span>:<br> <span class="hljs-attribute">Start</span> Length Slot Name Signature<br> <span class="hljs-attribute">3</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> i I<br></code></pre></td></tr></table></figure><p><img src="/../JUC_pic/12.png"></p><h3 id="局部变量的引用"><a href="#局部变量的引用" class="headerlink" title="局部变量的引用"></a>局部变量的引用</h3><p>在类里，方法外的变量的成员变量。方法里的叫局部变量。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadUnsafe</span> &#123;<br><span class="hljs-comment">//这里的list是成员变量</span><br> ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> loopNumber</span>)</span> &#123;<br> <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br> <span class="hljs-comment">// &#123; 临界区, 会产生竞态条件</span><br> method2();<br> method3();<br>  <span class="hljs-comment">// &#125; 临界区</span><br> &#125;<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span>()</span> &#123;<br> list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;1&quot;</span>);<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span>()</span> &#123;<br> list.<span class="hljs-keyword">remove</span>(<span class="hljs-number">0</span>);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> THREAD_NUMBER = <span class="hljs-number">2</span>;<br><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> LOOP_NUMBER = <span class="hljs-number">200</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br> ThreadUnsafe test = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ThreadUnsafe</span>();<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;<br> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(() -&gt; &#123;<br> test.<span class="hljs-built_in">method1</span>(LOOP_NUMBER);<br> &#125;, <span class="hljs-string">&quot;Thread&quot;</span> + i).<span class="hljs-built_in">start</span>();<br> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中一种情况是，如果线程2 还未 add，线程1 remove 就会报错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;Thread1&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IndexOutOfBoundsException</span>: Index: <span class="hljs-number">0</span>, Size: <span class="hljs-number">0</span> <br> at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.rangeCheck</span>(ArrayList<span class="hljs-selector-class">.java</span>:<span class="hljs-number">657</span>) <br> at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.remove</span>(ArrayList<span class="hljs-selector-class">.java</span>:<span class="hljs-number">496</span>) <br> at cn<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.n6</span><span class="hljs-selector-class">.ThreadUnsafe</span><span class="hljs-selector-class">.method3</span>(TestThreadSafe<span class="hljs-selector-class">.java</span>:<span class="hljs-number">35</span>) <br> at cn<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.n6</span><span class="hljs-selector-class">.ThreadUnsafe</span><span class="hljs-selector-class">.method1</span>(TestThreadSafe<span class="hljs-selector-class">.java</span>:<span class="hljs-number">26</span>) <br> at cn<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.n6</span><span class="hljs-selector-class">.TestThreadSafe</span>.lambda<span class="hljs-variable">$main</span>$<span class="hljs-number">0</span>(TestThreadSafe<span class="hljs-selector-class">.java</span>:<span class="hljs-number">14</span>) <br> at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.run</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">748</span>) <br></code></pre></td></tr></table></figure><p>分析：</p><ul><li>无论哪个线程中的 method2 引用的都是同一个对象中的 list 成员变量 </li><li>method3 与 method2 分析相同</li></ul><p><img src="/../JUC_pic/13.png"></p><p>解决办法：将list修改为局部变量</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafe</span> &#123;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> </span>&#123;<br> <span class="hljs-comment">//这里的list就是局部变量</span><br> ArrayList&lt;<span class="hljs-type">String</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br> <span class="hljs-built_in">method2</span>(list);<br> <span class="hljs-built_in">method3</span>(list);<br> &#125;<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(ArrayList&lt;<span class="hljs-type">String</span>&gt; list)</span> </span>&#123;<br> list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;1&quot;</span>);<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(ArrayList&lt;<span class="hljs-type">String</span>&gt; list)</span> </span>&#123;<br> list.<span class="hljs-built_in">remove</span>(<span class="hljs-number">0</span>);<br> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>分析：</p><ul><li>list 是局部变量，每个线程调用时会创建其不同实例，没有共享 </li><li>而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象 </li><li>method3 的参数分析与 method2 相同</li></ul><p><img src="/../JUC_pic/14.png"></p><p>方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 public 会不会代理线程安全问题？</p><ul><li>情况1：有其它线程调用 method2 和 method3</li></ul><p>不会，因为method2 和 method3传进来的参数list只能是线程自己的。</p><ul><li>情况2：在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafe</span> &#123;<br> <span class="hljs-keyword">public</span> final <span class="hljs-built_in">void</span> <span class="hljs-title function_">method1</span>(<span class="hljs-params">int loopNumber</span>) &#123;<br> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-title class_">String</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br> <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br> <span class="hljs-title function_">method2</span>(list);<br> <span class="hljs-title function_">method3</span>(list);<br> &#125;<br> &#125;<br> <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method2</span>(<span class="hljs-params">ArrayList&lt;<span class="hljs-built_in">String</span>&gt; list</span>) &#123;<br> list.<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;1&quot;</span>);<br> &#125;<br> <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method3</span>(<span class="hljs-params">ArrayList&lt;<span class="hljs-built_in">String</span>&gt; list</span>) &#123;<br> list.<span class="hljs-title function_">remove</span>(<span class="hljs-number">0</span>);<br> &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafeSubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ThreadSafe</span>&#123;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method3</span>(<span class="hljs-params">ArrayList&lt;<span class="hljs-built_in">String</span>&gt; list</span>) &#123;<br> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br> list.<span class="hljs-title function_">remove</span>(<span class="hljs-number">0</span>);<br> &#125;).<span class="hljs-title function_">start</span>();<br> &#125;<br>&#125;<br>被子类继承的话，那么子类可以另外开启一个线程进行相应操作，可能会出现线程安全问题。所以做好开闭原则中的闭。<br></code></pre></td></tr></table></figure><p><strong>从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】</strong>加上private 或 final 不然子类继承</p><h2 id="常见的线程安全类"><a href="#常见的线程安全类" class="headerlink" title="常见的线程安全类"></a>常见的线程安全类</h2><ul><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable(线程安全的Map实现)</li><li>java.util.concurrent 包下的类</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs livescript">Hashtable table = <span class="hljs-keyword">new</span> Hashtable();<br><br><span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> table.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> table.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">打开<span class="hljs-title">Put</span>源码</span><br><span class="hljs-function"><span class="hljs-title">public</span> <span class="hljs-title">synchronized</span> <span class="hljs-title">V</span> <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> &#123;</span><br><span class="hljs-function">        // <span class="hljs-title">Make</span> <span class="hljs-title">sure</span> <span class="hljs-title">the</span> <span class="hljs-title">value</span> <span class="hljs-title">is</span> <span class="hljs-title">not</span> <span class="hljs-title">null</span></span><br><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-params">(value == <span class="hljs-literal">null</span>)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">throw</span> <span class="hljs-title">new</span> <span class="hljs-title">NullPointerException</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">可见<span class="hljs-title">synchronized</span></span><br></code></pre></td></tr></table></figure><p>ctrl+N查找类。</p><p>ctrl+F12查找类中的方法。</p><ul><li>它们的每个方法是原子的 </li><li>但注意它们多个方法的组合不是原子的，</li></ul><h3 id="线程安全类方法的组合"><a href="#线程安全类方法的组合" class="headerlink" title="线程安全类方法的组合"></a>线程安全类方法的组合</h3><p>分析下面代码是否线程安全？</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Hashtable table = <span class="hljs-built_in">new</span> Hashtable();<br>// 线程<span class="hljs-number">1</span>，线程<span class="hljs-number">2</span><br><span class="hljs-keyword">if</span>( <span class="hljs-keyword">table</span>.<span class="hljs-keyword">get</span>(&quot;key&quot;) == <span class="hljs-keyword">null</span>) &#123;<br> <span class="hljs-keyword">table</span>.put(&quot;key&quot;, <span class="hljs-keyword">value</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../JUC_pic/15.png"></p><h3 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h3><p>String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的 有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安 全的呢？</p><p>比如substring(),其实没有修改，而是创建了一个新的String对象</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">String s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;456&quot;</span><span class="hljs-comment">;</span><br>编译可以通过，看上去好像改变了字符串的值，实际上是创建了新的对象，可以使用hashcode()得出结论。<br></code></pre></td></tr></table></figure><h3 id="不可变性的好处"><a href="#不可变性的好处" class="headerlink" title="不可变性的好处"></a>不可变性的好处</h3><p>String类的不可变性带来的好处总结主要有两点：</p><ul><li><p>因为String类的不可变性，才能使得JVM可以实现字符串常量池；字符串常量池可以在程序运行时节约很多内存空间，因为不同的字符串变量指向相同的字面量时，都是指向字符串常量池中的同一个对象。这样一方面能够节约内存，另一方面也提升了性能。</p></li><li><p>因为String类的不可变性，从而保证了字符串对象在多线程环境下是线程安全的。如果String类是可变的，那么会引起很严重的安全问题。我们在很多情况下都是直接通过字符串传递数据，比如数据库的用户名密码、网络编程中的ip和端口，因为字符串是不可变的，所以它的值不能被修改，如果字符串是可变的，那么可以通过改变引用地址指向的值去修改字符串的值，从而导致安全漏洞。</p></li><li><p>同时也非常适合作为HashMap的key，因为HashMap的工作原理是hashcode，如果String作为key可变，那么hashcode会发送改变，那么就找不到之前存储的数据了。</p></li></ul><h2 id="Monitor概念"><a href="#Monitor概念" class="headerlink" title="Monitor概念"></a>Monitor概念</h2><p>一个对象主要由两部分组成：Java对象头+成员变量</p><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>以32位虚拟机为例：</p><p><strong>普通对象</strong></p><p><img src="/../JUC_pic/16.png"></p><p>一个类是什么对象靠的就是Klass Word(是一个指针)，通过Klass Word找到对象的类型。</p><p><strong>数组对象</strong></p><p><img src="/../JUC_pic/17.png"></p><p><strong>其中Mark Word结构为</strong></p><p><img src="/../JUC_pic/18.png"></p><p>其中先看Normal,hashcode懂得都懂，age是JVM中新生代到老年代晋升的那个年龄，biased_lock是偏向锁(后面学习)，01是加锁状态。</p><p><strong>64位虚拟机</strong></p><p><img src="/../JUC_pic/19.png"></p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="synchronized-底层原理-Monitor"><a href="#synchronized-底层原理-Monitor" class="headerlink" title="synchronized 底层原理(Monitor)"></a>synchronized 底层原理(Monitor)</h3><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong></p><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针</p><p><img src="/../JUC_pic/20.png"></p><ul><li>刚开始 Monitor 中 Owner 为 null</li><li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一 个 Owner</li><li>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 EntryList BLOCKED</li><li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的</li><li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 wait-notify 时会分析</li></ul><h3 id="synchronized-底层原理字节码分析"><a href="#synchronized-底层原理字节码分析" class="headerlink" title="synchronized 底层原理字节码分析"></a>synchronized 底层原理字节码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <span class="hljs-keyword">synchronized</span> (lock) &#123;<br> counter++;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs awk">public static void main(java.lang.String[]);<br> descriptor: ([Ljava<span class="hljs-regexp">/lang/</span>String;)V<br> flags: ACC_PUBLIC, ACC_STATIC<br>  Code:<br> stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br> <span class="hljs-number">0</span>: getstatic <span class="hljs-comment">#2 // &lt;- lock引用 （synchronized开始）</span><br> <span class="hljs-number">3</span>: dup<br> <span class="hljs-number">4</span>: astore_1 <span class="hljs-regexp">//</span> lock引用 -&gt; slot <span class="hljs-number">1</span><br> <span class="hljs-number">5</span>: monitorenter <span class="hljs-regexp">//</span> 将 lock对象 MarkWord 置为 Monitor 指针<br> <span class="hljs-number">6</span>: getstatic <span class="hljs-comment">#3 // &lt;- i</span><br> <span class="hljs-number">9</span>: iconst_1 <span class="hljs-regexp">//</span> 准备常数 <span class="hljs-number">1</span><br> <span class="hljs-number">10</span>: iadd <span class="hljs-regexp">//</span> +<span class="hljs-number">1</span><br> <span class="hljs-number">11</span>: putstatic <span class="hljs-comment">#3 // -&gt; i</span><br> <span class="hljs-number">14</span>: aload_1 <span class="hljs-regexp">//</span> &lt;- lock引用<br> <span class="hljs-number">15</span>: monitorexit <span class="hljs-regexp">//</span> 将 lock对象 MarkWord 重置, 唤醒 EntryList<br> <span class="hljs-number">16</span>: goto <span class="hljs-number">24</span><br> <span class="hljs-number">19</span>: astore_2 <span class="hljs-regexp">//</span> e -&gt; slot <span class="hljs-number">2</span> <br> <span class="hljs-number">20</span>: aload_1 <span class="hljs-regexp">//</span> &lt;- lock引用<br> <span class="hljs-number">21</span>: monitorexit <span class="hljs-regexp">//</span> 将 lock对象 MarkWord 重置, 唤醒 EntryList<br> <span class="hljs-number">22</span>: aload_2 <span class="hljs-regexp">//</span> &lt;- slot <span class="hljs-number">2</span> (e)<br> <span class="hljs-number">23</span>: athrow <span class="hljs-regexp">//</span> throw e<br> <span class="hljs-number">24</span>: return<br> Exception table:<br> from to target type<br> <span class="hljs-number">6</span>    <span class="hljs-number">16</span> <span class="hljs-number">19</span>     any<br> <span class="hljs-number">19</span>   <span class="hljs-number">22</span> <span class="hljs-number">19</span>     any<br> LineNumberTable:<br> line <span class="hljs-number">8</span>: <span class="hljs-number">0</span><br> line <span class="hljs-number">9</span>: <span class="hljs-number">6</span><br> line <span class="hljs-number">10</span>: <span class="hljs-number">14</span><br> line <span class="hljs-number">11</span>: <span class="hljs-number">24</span><br> LocalVariableTable:<br> Start Length Slot Name Signature<br>  <span class="hljs-number">0</span>     <span class="hljs-number">25</span>      <span class="hljs-number">0</span>   args [Ljava<span class="hljs-regexp">/lang/</span>String;<br> StackMapTable: number_of_entries = <span class="hljs-number">2</span><br> frame_type = <span class="hljs-number">255</span> <span class="hljs-regexp">/* full_frame */</span><br> offset_delta = <span class="hljs-number">19</span><br> locals = [ class <span class="hljs-string">&quot;[Ljava/lang/String;&quot;</span>, class java<span class="hljs-regexp">/lang/</span>Object ]<br> stack = [ class java<span class="hljs-regexp">/lang/</span>Throwable ]<br> frame_type = <span class="hljs-number">250</span> <span class="hljs-regexp">/* chop */</span><br> offset_delta = <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p><p>不过两者的本质都是对对象监视器 monitor 的获取。(Monitor是由操作系统提供的)。</p><h3 id="synchronized升级之小故事"><a href="#synchronized升级之小故事" class="headerlink" title="synchronized升级之小故事"></a>synchronized升级之小故事</h3><p>故事角色 </p><ul><li><p>老王 - JVM </p></li><li><p>小南 - 线程 </p></li><li><p>小女 - 线程 </p></li><li><p>房间 - 对象 </p></li><li><p>房间门上 - 防盗锁 - Monitor </p></li><li><p>房间门上 - 小南书包 - 轻量级锁 </p></li><li><p>房间门上 - 刻上小南大名 - 偏向锁 </p></li><li><p>批量重刻名 - 一个类的偏向锁撤销到达 20 阈值 </p></li><li><p>不能刻名字 - 批量撤销该类对象的偏向锁，设置该类不可偏向 </p><p>小南要使用房间保证计算不被其它人干扰（原子性），最初，他用的是防盗锁，当上下文切换时，锁住门。这样， 即使他离开了，别人也进不了门，他的工作就是安全的。</p><p>但是，很多情况下没人跟他来竞争房间的使用权。小女是要用房间，但使用的时间上是错开的，小南白天用，小女 晚上用。每次上锁太麻烦了，有没有更简单的办法呢？ </p><p>小南和小女商量了一下，约定不锁门了，而是谁用房间，谁把自己的书包挂在门口，但他们的书包样式都一样，因 此每次进门前得翻翻书包(查看对象头的线程ID)，看课本是谁的，如果是自己的，那么就可以进门，这样省的上锁解锁了。万一书包不是 自己的，那么就在门外等，并通知对方下次用锁门的方式(因为有了竞争，所以升级为重量级锁)。 </p><p>后来，小女回老家了，很长一段时间都不会用这个房间。小南每次还是挂书包，翻书包，虽然比锁门省事了，但仍 然觉得麻烦。 </p><p>于是，小南干脆在门上刻上了自己的名字：【小南专属房间，其它人勿用】，下次来用房间时，只要名字还在，那 么说明没人打扰，还是可以安全地使用房间。如果这期间有其它人要用这个房间，那么由使用者将小南刻的名字擦 掉，升级为挂书包的方式。</p><p> 同学们都放假回老家了，小南就膨胀了，在 20 个房间刻上了自己的名字，想进哪个进哪个。后来他自己放假回老 家了，这时小女回来了（她也要用这些房间），结果就是得一个个地擦掉小南刻的名字，升级为挂书包的方式。老 王觉得这成本有点高，提出了一种批量重刻名的方法，他让小女不用挂书包了，可以直接在门上刻上自己的名字 </p><p>后来，刻名的现象越来越频繁，老王受不了了：算了，这些房间都不能刻名了，只能挂书包</p></li></ul><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以 使用轻量级锁来优化。 轻量级锁对使用者是透明的，即语法仍然是 synchronized </p><p>假设有两个方法同步块，利用同一个对象加锁</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">static</span> final <span class="hljs-title class_">Object</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method1</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;<br> <span class="hljs-comment">// 同步块 A</span><br> <span class="hljs-title function_">method2</span>();<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method2</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;<br> <span class="hljs-comment">// 同步块 B</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建锁记录（Lock Record）对象，每个线程都的每个栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word</li></ul><p><img src="/../JUC_pic/21.png"></p><ul><li>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将对象的 Mark Word 的值存 入锁记录</li></ul><p><img src="/../JUC_pic/22.png"></p><ul><li>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</li></ul><p><img src="/../JUC_pic/23.png"></p><ul><li><p>如果 cas 失败，有两种情况 </p><ul><li><p>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 </p></li><li><p>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</p></li></ul></li></ul><p><img src="/../JUC_pic/24.png"></p><ul><li>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重 入计数减一</li></ul><p><img src="/../JUC_pic/25.png"></p><ul><li>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象 头 <ul><li>成功，则解锁成功 </li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul></li></ul><h3 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有 竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">static</span> <span class="hljs-title class_">Object</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method1</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;<br> <span class="hljs-comment">// 同步块</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li></ul><p><img src="/../JUC_pic/26.png"></p><ul><li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程 <ul><li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址 </li><li>然后自己进入 Monitor 的 EntryList BLOCKED</li></ul></li></ul><p><img src="/../JUC_pic/27.png"></p><ul><li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁 流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li></ul><h3 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h3><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步 块，释放了锁），这时当前线程就可以避免阻塞。(阻塞会发生上下文切换，上下文切换影响性能)。</p><p><strong>自旋重试成功的情况</strong></p><p><img src="/../JUC_pic/28.png"></p><p><strong>自旋重试失败的情况</strong></p><p><img src="/../JUC_pic/29.png"></p><ul><li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 </li><li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会 高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</li><li>Java 7 之后不能控制是否开启自旋功能</li></ul><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS（Compare And Swap） 操作。</p><p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现 这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">static</span> final <span class="hljs-title class_">Object</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">m1</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;<br> <span class="hljs-comment">// 同步块 A</span><br> <span class="hljs-title function_">m2</span>();<br> &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">m2</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;<br> <span class="hljs-comment">// 同步块 B</span><br> <span class="hljs-title function_">m3</span>();<br> &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">m3</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;<br> <span class="hljs-comment">// 同步块 C</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../JUC_pic/30.png"></p><p><img src="/../JUC_pic/36.png"></p><h3 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h3><p>回忆一下对象头格式</p><p><img src="/../JUC_pic/37.png"></p><p>分别是：无锁，偏向锁，轻量级锁，重量级锁，已被GC回收</p><p>一个对象创建时：</p><ul><li>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的 thread、epoch、age 都为 0。</li><li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 - XX:BiasedLockingStartupDelay&#x3D;0 来禁用延迟。(偏向锁的延迟性)</li><li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、 age 都为 0，第一次用到 hashcode 时才会赋值。</li></ul><p>1） 测试偏向锁的延迟特性</p><p>2） 测试偏向锁</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Dog</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>利用 jol 第三方工具来查看对象头信息（注意这里我扩展了 jol 让它输出更为简洁）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// 添加虚拟机参数 -XX:BiasedLockingStartupDelay=<span class="hljs-number">0</span> <br><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) throws IOException &#123;<br> Dog d = <span class="hljs-built_in">new</span> Dog();<br> ClassLayout classLayout = ClassLayout.parseInstance(d);<br> <br> <span class="hljs-built_in">new</span> Thread(() -&gt; &#123;<br> <span class="hljs-keyword">log</span>.<span class="hljs-keyword">debug</span>(&quot;synchronized 前&quot;);<br> <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(classLayout.toPrintableSimple(<span class="hljs-keyword">true</span>));<br> synchronized (d) &#123;<br> <span class="hljs-keyword">log</span>.<span class="hljs-keyword">debug</span>(&quot;synchronized 中&quot;);<br> <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(classLayout.toPrintableSimple(<span class="hljs-keyword">true</span>));<br> &#125;<br> <span class="hljs-keyword">log</span>.<span class="hljs-keyword">debug</span>(&quot;synchronized 后&quot;);<br> <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(classLayout.toPrintableSimple(<span class="hljs-keyword">true</span>));<br> &#125;, &quot;t1&quot;).<span class="hljs-keyword">start</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">11:08:58.117 c.TestBiased [t1] - synchronized 前<br>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000101 <br>11:08:58.121 c.TestBiased [t1] - synchronized 中<br>00000000 00000000 00000000 00000000 00011111 11101011 11010000 00000101 <br>11:08:58.121 c.TestBiased [t1] - synchronized 后<br>00000000 00000000 00000000 00000000 00011111 11101011 11010000 00000101<br></code></pre></td></tr></table></figure><p><strong>注意 处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</strong></p><p>3）测试禁用 </p><p>在上面测试代码运行时在添加 VM 参数 -XX:-UseBiasedLocking 禁用偏向锁</p><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">11</span>:<span class="hljs-number">13</span>:<span class="hljs-number">10.018</span> c.TestBiased [t1] - synchronized 前<br><span class="hljs-symbol">00000000 </span><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br><span class="hljs-number">11</span>:<span class="hljs-number">13</span>:<span class="hljs-number">10.021</span> c.TestBiased [t1] - synchronized 中<br><span class="hljs-symbol">00000000 </span><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">00010100</span> <span class="hljs-number">11110011</span> <span class="hljs-number">10001000</span> <br><span class="hljs-number">11</span>:<span class="hljs-number">13</span>:<span class="hljs-number">10.021</span> c.TestBiased [t1] - synchronized 后<br><span class="hljs-symbol">00000000 </span><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span><br></code></pre></td></tr></table></figure><ol start="4"><li><p>测试 hashCode </p><p>正常状态对象一开始是没有 hashCode 的，第一次调用才生成,注意。调用Hashcode()方法会使偏向锁失效</p><p><img src="/../JUC_pic/37.png"></p></li></ol><p>调用Hashcode()后生成31位hashCode ，这时候没有空间再存储thread(操作系统方面的线程ID)，所以偏向锁失效，但是为什么轻量级锁和重量级锁不失效呢？</p><p><img src="/../JUC_pic/26.png"></p><p><img src="/../JUC_pic/27.png"></p><p>因为对象在使用轻量级锁时把hashcode存储在线程栈帧的Lock Record(所记录)中。</p><p>而对象在使用重量级锁时把hashcode存储在Monitor对象中，释放锁时再还原给对象头中。</p><h3 id="撤销-调用对象-hashCode"><a href="#撤销-调用对象-hashCode" class="headerlink" title="撤销 - 调用对象 hashCode"></a>撤销 - 调用对象 hashCode</h3><p>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被 撤销</p><ul><li>轻量级锁会在锁记录中记录 hashCode</li><li>重量级锁会在 Monitor 中记录 hashCode</li></ul><p>在调用 hashCode 后使用偏向锁，记得去掉 -XX:-UseBiasedLocking</p><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">11</span>:<span class="hljs-number">22</span>:<span class="hljs-number">10.386</span> c.TestBiased [main] - 调用 hashCode:<span class="hljs-number">1778535015</span> <br><span class="hljs-number">11</span>:<span class="hljs-number">22</span>:<span class="hljs-number">10.391</span> c.TestBiased [t1] - synchronized 前<br><span class="hljs-symbol">00000000 </span><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">01101010</span> <span class="hljs-number">00000010</span> <span class="hljs-number">01001010</span> <span class="hljs-number">01100111</span> <span class="hljs-number">00000001</span> <br><span class="hljs-number">11</span>:<span class="hljs-number">22</span>:<span class="hljs-number">10.393</span> c.TestBiased [t1] - synchronized 中<br><span class="hljs-symbol">00000000 </span><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">11000011</span> <span class="hljs-number">11110011</span> <span class="hljs-number">01101000</span> <br><span class="hljs-number">11</span>:<span class="hljs-number">22</span>:<span class="hljs-number">10.393</span> c.TestBiased [t1] - synchronized 后<br><span class="hljs-symbol">00000000 </span><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">01101010</span> <span class="hljs-number">00000010</span> <span class="hljs-number">01001010</span> <span class="hljs-number">01100111</span> <span class="hljs-number">00000001</span><br></code></pre></td></tr></table></figure><h3 id="撤销-其它线程使用对象"><a href="#撤销-其它线程使用对象" class="headerlink" title="撤销 - 其它线程使用对象"></a>撤销 - 其它线程使用对象</h3><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs livescript">private <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> test2() throws InterruptedException &#123;<br> Dog d = <span class="hljs-keyword">new</span> Dog();<br> Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (d) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (TestBiased.<span class="hljs-keyword">class</span>) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> TestBiased.<span class="hljs-keyword">class</span>.notify();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-regexp">// 如果不用 wait/notify 使用 join 必须打开下面的注释</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function"> //</span> 因为：t1 线程不能结束，否则底层线程可能被 jvm 重用作为 t2 线程，底层线程 id 是一样的</span></span><br><span class="hljs-params"><span class="hljs-function"> /*<span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> System.<span class="hljs-keyword">in</span>.read();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;*/</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> </span><br><span class="hljs-function"> <span class="hljs-title">Thread</span> <span class="hljs-title">t2</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (TestBiased.<span class="hljs-keyword">class</span>) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> TestBiased.<span class="hljs-keyword">class</span>.wait();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (d) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t2&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">[t1] - <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">01000001</span> <span class="hljs-number">00010000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">01000001</span> <span class="hljs-number">00010000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">10110101</span> <span class="hljs-number">11110000</span> <span class="hljs-number">01000000</span> <br>[t2] - <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br></code></pre></td></tr></table></figure><h3 id="撤销-调用-wait-x2F-notify"><a href="#撤销-调用-wait-x2F-notify" class="headerlink" title="撤销 - 调用 wait&#x2F;notify"></a>撤销 - 调用 wait&#x2F;notify</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br> Dog d = <span class="hljs-keyword">new</span> Dog();<br> Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (d) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> d.wait();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> </span><br><span class="hljs-function"> <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> Thread.sleep(<span class="hljs-number">6000</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (d) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;notify&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> d.notify();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t2&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">[t1] - <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">10110011</span> <span class="hljs-number">11111000</span> <span class="hljs-number">00000101</span> <br>[t2] - notify <br>[t1] - <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011100</span> <span class="hljs-number">11010100</span> <span class="hljs-number">00001101</span> <span class="hljs-number">11001010</span> <br></code></pre></td></tr></table></figure><p>因为wait&#x2F;notify只有在重量锁(两个线程存在竞争)的情况下才能使用。</p><p><strong>wait&#x2F;notify方法的调用必须处在该对象的锁（Monitor）中，也即，在调用这些方法时首先需要获得该对象的锁。</strong>否则会抛出IllegalMonitorStateException异常。</p><h3 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h3><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象 的 Thread ID</p><p>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至 加锁线程,并且这些对象在synchronized同步代码块之外的状态依然处于偏向T2的状态，而在20次之前这些对象被撤销锁处于不可偏向状态(normal).</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs livescript">private <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> test3() throws InterruptedException &#123;<br> Vector&lt;Dog&gt; <span class="hljs-keyword">list</span> = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br> Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> Dog d = <span class="hljs-keyword">new</span> Dog();</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">list</span>.add(d);</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (d) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (<span class="hljs-keyword">list</span>) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">list</span>.notify();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125; </span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> </span><br><span class="hljs-function"> <span class="hljs-title">Thread</span> <span class="hljs-title">t2</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (<span class="hljs-keyword">list</span>) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">list</span>.wait();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;===============&gt; &quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> Dog d = <span class="hljs-keyword">list</span>.get(i);</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (d) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t2&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs dns">[t1] - <span class="hljs-number">0 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">1 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">2 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">3 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">4 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">5 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">6 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">7 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">8 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">9 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">10 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">11 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">12 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">13 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">14 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">15 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">16 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">17 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">18 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">19 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">20 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">21 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">22 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">23 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">24 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">25 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">26 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">27 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">28 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">29 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - ===============&gt; <br>[t2] - <span class="hljs-number">0 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">0 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">0 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">1 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">1 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">1 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">2 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">2 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">2 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">3 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">3 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">3 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">4 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">4 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">4 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">5 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">5 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">5 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">6 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">6 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">6 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">7 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">7 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">7 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">8 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">8 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">8 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">9 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">9 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">9 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">10 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">10 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">10 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">11 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">11 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">11 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">12 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">12 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">12 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">13 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">13 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">13 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">14 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">14 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">14 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">15 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">15 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">15 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">16 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">16 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">16 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">17 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">17 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">17 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">18 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">18 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">18 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">19 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">19 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">19 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">20 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">20 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">20 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">21 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">21 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">21 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">22 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">22 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">22 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">23 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">23 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">23 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">24 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">24 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">24 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">25 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">25 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">25 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">26 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">26 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">26 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">27 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">27 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">27 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">28 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">28 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">28 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">29 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">29 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">29 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br><br></code></pre></td></tr></table></figure><h3 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h3><p>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象 都会变为不可偏向的，新建的对象也是不可偏向的。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">static</span> Thread t1,t2,t3;<br>   private <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> test4() throws InterruptedException &#123;<br> Vector&lt;Dog&gt; <span class="hljs-keyword">list</span> = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br>  int loopNumber = <span class="hljs-number">39</span>;<br> t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> Dog d = <span class="hljs-keyword">new</span> Dog();</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">list</span>.add(d);</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (d) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> LockSupport.unpark(t2);</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">   <span class="hljs-title">t2</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> LockSupport.park();</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;===============&gt; &quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> Dog d = <span class="hljs-keyword">list</span>.get(i);</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (d) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> LockSupport.unpark(t3);</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t2&quot;</span>)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">5. 锁消除</span><br><span class="hljs-function">锁消除</span><br><span class="hljs-function"> <span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    <span class="hljs-title">t3</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> LockSupport.park();</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;===============&gt; &quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> Dog d = <span class="hljs-keyword">list</span>.get(i);</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (d) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t3&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t3</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t3</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(ClassLayout.parseInstance(<span class="hljs-keyword">new</span> Dog()).toPrintableSimple(<span class="hljs-literal">true</span>))</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="Wait-notify原理"><a href="#Wait-notify原理" class="headerlink" title="Wait notify原理"></a>Wait notify原理</h2><p><img src="/../JUC_pic/41.png"></p><ul><li><p>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 </p></li><li><p>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 </p></li><li><p>BLOCKED 线程会在 Owner 线程释放锁时唤醒</p></li><li><p>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争</p></li></ul><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul><li>obj.wait() 让进入 object 监视器的线程到 waitSet 等待</li><li>obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒</li><li>obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒</li></ul><p>它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法,比如</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss">new <span class="hljs-built_in">Thread</span>(() -&gt; &#123;<br> synchronized (obj) &#123;<br> log<span class="hljs-selector-class">.debug</span>(&quot;执行....&quot;);<br> try &#123;<br> obj<span class="hljs-selector-class">.wait</span>(); <span class="hljs-comment">// 让线程在obj上一直等待下去</span><br> &#125; catch (InterruptedException e) &#123;<br> e<span class="hljs-selector-class">.printStackTrace</span>();<br> &#125;<br> log<span class="hljs-selector-class">.debug</span>(&quot;其它代码....&quot;);<br> &#125;<br> &#125;)<span class="hljs-selector-class">.start</span>();<br></code></pre></td></tr></table></figure><h3 id="sleep-long-n-和-wait-long-n-的区别"><a href="#sleep-long-n-和-wait-long-n-的区别" class="headerlink" title="sleep(long n) 和 wait(long n) 的区别"></a>sleep(long n) 和 wait(long n) 的区别</h3><ul><li>sleep 是 Thread 方法，而 wait 是 Object 的方法</li><li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要 和 synchronized 一起用</li><li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁</li><li>它们 状态都是 TIMED_WAITING(共同点)</li></ul><h2 id="Park-amp-Unpark"><a href="#Park-amp-Unpark" class="headerlink" title="Park &amp; Unpark"></a>Park &amp; Unpark</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>调用park的线程处于wait状态</p><p>它们是 LockSupport 类中的方法</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 暂停当前线程<br>LockSupport.park(); <br><span class="hljs-regexp">//</span> 恢复某个线程的运行<br>LockSupport.unpark(暂停线程对象)<br></code></pre></td></tr></table></figure><p>先 park 再 unpark</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript">Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;start...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> sleep(<span class="hljs-number">1</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;park...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> LockSupport.park();</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;resume...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;,<span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;unpark...&quot;</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">LockSupport</span>.<span class="hljs-title">unpark</span><span class="hljs-params">(t1)</span>;</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">52.585</span> c<span class="hljs-selector-class">.TestParkUnpark</span> <span class="hljs-selector-attr">[t1]</span> - start... <br><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">53.589</span> c<span class="hljs-selector-class">.TestParkUnpark</span> <span class="hljs-selector-attr">[t1]</span> - park... <br><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">54.583</span> c<span class="hljs-selector-class">.TestParkUnpark</span> <span class="hljs-selector-attr">[main]</span> - unpark... <br><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">54.583</span> c<span class="hljs-selector-class">.TestParkUnpark</span> <span class="hljs-selector-attr">[t1]</span> - resume... <br></code></pre></td></tr></table></figure><p>先 unpark 再 park</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript">Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;start...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> sleep(<span class="hljs-number">2</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;park...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> LockSupport.park();</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;resume...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;unpark...&quot;</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">LockSupport</span>.<span class="hljs-title">unpark</span><span class="hljs-params">(t1)</span>;</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">50.765</span> c<span class="hljs-selector-class">.TestParkUnpark</span> <span class="hljs-selector-attr">[t1]</span> - start... <br><span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">51.764</span> c<span class="hljs-selector-class">.TestParkUnpark</span> <span class="hljs-selector-attr">[main]</span> - unpark... <br><span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">52.769</span> c<span class="hljs-selector-class">.TestParkUnpark</span> <span class="hljs-selector-attr">[t1]</span> - park... <br><span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">52.769</span> c<span class="hljs-selector-class">.TestParkUnpark</span> <span class="hljs-selector-attr">[t1]</span> - resume... <br></code></pre></td></tr></table></figure><p>可以看到不管unpark在park之前还是之后都可以成功唤醒park所在线程</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>与 Object 的 wait &amp; notify 相比</p><ul><li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li><li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll  是唤醒所有等待线程，就不那么【精确】</li><li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li></ul><h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2><p><img src="/../JUC_pic/42.png"></p><p>(待详细分析)</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>相对于 synchronized 它具备如下特点</p><ul><li>可打断(synchonized不可打断)，减少死锁发生的 可能性</li><li>可以设置超时时间</li><li>可以设置为公平锁</li><li>支持多个条件变量</li></ul><p>与 synchronized 一样，都支持可重入</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 获取锁<br>reentrantLock.lock();<br>try &#123;<br> <span class="hljs-regexp">//</span> 临界区<br>&#125; finally &#123;<br> <span class="hljs-regexp">//</span> 释放锁<br> reentrantLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁 如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp">@Slf4j<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLockTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;entry main&quot;</span>);<br>            m1();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">lock</span>.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span>()</span>&#123;<br>        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;entry m1&quot;</span>);<br>            m2();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">lock</span>.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span>()</span>&#123;<br>        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;entry m2&quot;</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">lock</span>.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">16</span>:<span class="hljs-number">01</span>:<span class="hljs-number">24.390</span> <span class="hljs-selector-attr">[main]</span> DEBUG lock<span class="hljs-selector-class">.ReentrantLockTest</span> - entry <span class="hljs-selector-tag">main</span><br><span class="hljs-number">16</span>:<span class="hljs-number">01</span>:<span class="hljs-number">24.392</span> <span class="hljs-selector-attr">[main]</span> DEBUG lock<span class="hljs-selector-class">.ReentrantLockTest</span> - entry m1<br><span class="hljs-number">16</span>:<span class="hljs-number">01</span>:<span class="hljs-number">24.392</span> <span class="hljs-selector-attr">[main]</span> DEBUG lock<span class="hljs-selector-class">.ReentrantLockTest</span> - entry m2<br></code></pre></td></tr></table></figure><h3 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-built_in">new</span> ReentrantLock();<br>        Thread t1 = <span class="hljs-built_in">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">log</span>.<span class="hljs-keyword">debug</span>(&quot;启动...&quot;);<br>            try &#123;<br>                //如果没有竞争那么将获得<span class="hljs-keyword">lock</span>对象锁<br>                //如果有竞争就进入阻塞队列,可以被其他线程用interrupt()打断<br>                //主线程已经获取锁了，t1线程阻塞并在阻塞队列等待，主线程执行t1.interrupt()将t1等待打断<br>                <span class="hljs-keyword">lock</span>.lockInterruptibly();<br>            &#125; catch (InterruptedException e) &#123;<br>                e.printStackTrace();<br>                <span class="hljs-keyword">log</span>.<span class="hljs-keyword">debug</span>(&quot;等锁的过程中被打断&quot;);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            try &#123;<br>                <span class="hljs-keyword">log</span>.<span class="hljs-keyword">debug</span>(&quot;获得了锁&quot;);<br>            &#125; finally &#123;<br>                <span class="hljs-keyword">lock</span>.unlock();<br>            &#125;<br>        &#125;,&quot;t1&quot;);<br>        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br>        <span class="hljs-keyword">log</span>.<span class="hljs-keyword">debug</span>(&quot;获得了锁&quot;);<br>        t1.<span class="hljs-keyword">start</span>();<br>        try &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            t1.interrupt();<br>            <span class="hljs-keyword">log</span>.<span class="hljs-keyword">debug</span>(&quot;执行打断&quot;);<br>        &#125; finally &#123;<br>            <span class="hljs-keyword">lock</span>.unlock();<br>        &#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">6</span>:<span class="hljs-number">47</span>:<span class="hljs-number">34.169</span> <span class="hljs-selector-attr">[main]</span> DEBUG lock<span class="hljs-selector-class">.ReentrantLockTest2</span> - 获得了锁<br><span class="hljs-number">16</span>:<span class="hljs-number">47</span>:<span class="hljs-number">34.172</span> <span class="hljs-selector-attr">[Thread-0]</span> DEBUG lock<span class="hljs-selector-class">.ReentrantLockTest2</span> - 启动...<br><span class="hljs-number">16</span>:<span class="hljs-number">47</span>:<span class="hljs-number">35.183</span> <span class="hljs-selector-attr">[main]</span> DEBUG lock<span class="hljs-selector-class">.ReentrantLockTest2</span> - 执行打断<br><span class="hljs-number">16</span>:<span class="hljs-number">47</span>:<span class="hljs-number">35.183</span> <span class="hljs-selector-attr">[Thread-0]</span> DEBUG lock<span class="hljs-selector-class">.ReentrantLockTest2</span> - 等锁的过程中被打断<br>java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.InterruptedException</span><br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.doAcquireInterruptibly</span>(AbstractQueuedSynchronizer<span class="hljs-selector-class">.java</span>:<span class="hljs-number">898</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.acquireInterruptibly</span>(AbstractQueuedSynchronizer<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1222</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.ReentrantLock</span><span class="hljs-selector-class">.lockInterruptibly</span>(ReentrantLock<span class="hljs-selector-class">.java</span>:<span class="hljs-number">335</span>)<br>at lock<span class="hljs-selector-class">.ReentrantLockTest2</span>.lambda<span class="hljs-variable">$main</span>$<span class="hljs-number">0</span>(ReentrantLockTest2<span class="hljs-selector-class">.java</span>:<span class="hljs-number">20</span>)<br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.run</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">750</span>)<br></code></pre></td></tr></table></figure><p>注意如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs livescript">@Slf4j<br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLockTest2</span> &#123;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br>        ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            lock.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125; <span class="hljs-keyword">finally</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                lock.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">lock</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;获得了锁&quot;</span>)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">t1</span>.<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;执行打断&quot;</span>)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>;</span><br><span class="hljs-function">        &#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;释放了锁&quot;</span>)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">lock</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">18</span>:<span class="hljs-number">06</span>:<span class="hljs-number">56.261</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 获得了锁<br><span class="hljs-number">18</span>:<span class="hljs-number">06</span>:<span class="hljs-number">56.265</span> <span class="hljs-selector-attr">[t1]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 启动... <br><span class="hljs-number">18</span>:<span class="hljs-number">06</span>:<span class="hljs-number">57.266</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 执行打断 <span class="hljs-comment">// 这时 t1 并没有被真正打断, 而是仍继续等待锁</span><br><span class="hljs-number">18</span>:<span class="hljs-number">06</span>:<span class="hljs-number">58.267</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 释放了锁<br><span class="hljs-number">18</span>:<span class="hljs-number">06</span>:<span class="hljs-number">58.267</span> <span class="hljs-selector-attr">[t1]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 获得了锁<br></code></pre></td></tr></table></figure><p>这是一种被动打断，也就是被别的线程打断，所以接下来介绍主动打断-&gt;锁超时。</p><h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p>立刻失败</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs livescript">ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">if</span> (!lock.tryLock()) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        log.debug(<span class="hljs-string">&quot;获取立刻失败，返回&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">return</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125; <span class="hljs-keyword">finally</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        lock.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function">//主线程获得到<span class="hljs-title">lock</span>锁</span><br><span class="hljs-function"><span class="hljs-title">lock</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;获得了锁&quot;</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>;</span><br><span class="hljs-function">&#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">lock</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">17:05:08.957 [main] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest3 - 获得了锁<br>17:05:08.960 [t1] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest3 - 启动<span class="hljs-built_in">..</span>.<br>17:05:08.960 [t1] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest3 - 获取立刻失败，返回<br></code></pre></td></tr></table></figure><p>超时失败</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs livescript">ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">if</span> (!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            log.debug(<span class="hljs-string">&quot;获取等待 1s 后失败，返回&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">return</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125; <span class="hljs-keyword">finally</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        lock.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">lock</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;获得了锁&quot;</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>;</span><br><span class="hljs-function">&#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">lock</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">17:07:37.062 [main] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest3 - 获得了锁<br>17:07:37.064 [t1] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest3 - 启动<span class="hljs-built_in">..</span>.<br>17:07:38.075 [t1] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest3 - 获取等待 1s 后失败，返回<br></code></pre></td></tr></table></figure><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>ReentrantLock 默认是不公平的，什么是公平和不公平？在获取不到锁对象时，线程会进入阻塞队列，当执行线程完毕后，阻塞队列里的线程会一窝蜂来争抢锁对象，谁抢到就是谁的，而不是按进入队列的顺序先来后到。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待。</p><p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比</p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li><li>await 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul><p>例子：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">static</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-keyword">static</span> Condition waitCigaretteQueue = lock.newCondition();<br><span class="hljs-keyword">static</span> Condition waitbreakfastQueue = lock.newCondition();<br><span class="hljs-keyword">static</span> volatile boolean hasCigrette = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">static</span> volatile boolean hasBreakfast = <span class="hljs-literal">false</span>;<br><br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br>    <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            lock.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">while</span> (!hasCigrette) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    log.debug(<span class="hljs-string">&quot;没烟抽，先等一会&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">                    waitCigaretteQueue.<span class="hljs-keyword">await</span>();</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">            log.debug(<span class="hljs-string">&quot;等到了它的烟&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125; <span class="hljs-keyword">finally</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            lock.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            lock.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">while</span> (!hasBreakfast) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    log.debug(<span class="hljs-string">&quot;没饭吃，先等一会&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">                    waitbreakfastQueue.<span class="hljs-keyword">await</span>();</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">            log.debug(<span class="hljs-string">&quot;等到了它的早餐&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125; <span class="hljs-keyword">finally</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            lock.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1000</span>)</span>;</span><br><span class="hljs-function">    <span class="hljs-title">sendBreakfast</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1000</span>)</span>;</span><br><span class="hljs-function">    <span class="hljs-title">sendCigarette</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"><span class="hljs-title">private</span> <span class="hljs-title">static</span> <span class="hljs-title">void</span> <span class="hljs-title">sendCigarette</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">    //先获取锁才能使用</span><br><span class="hljs-function">    <span class="hljs-title">lock</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;送烟来了&quot;</span>)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">hasCigrette</span> = <span class="hljs-title">true</span>;</span><br><span class="hljs-function">        <span class="hljs-title">waitCigaretteQueue</span>.<span class="hljs-title">signal</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">lock</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">private</span> <span class="hljs-title">static</span> <span class="hljs-title">void</span> <span class="hljs-title">sendBreakfast</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">lock</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;送早餐来了&quot;</span>)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">hasBreakfast</span> = <span class="hljs-title">true</span>;</span><br><span class="hljs-function">        <span class="hljs-title">waitbreakfastQueue</span>.<span class="hljs-title">signal</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">lock</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">19:12:46.838 [Thread-0] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest4 - 没烟抽，先等一会<br>19:12:46.840 [Thread-1] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest4 - 没饭吃，先等一会<br>19:12:47.838 [main] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest4 - 送早餐来了<br>19:12:47.838 [Thread-1] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest4 - 等到了它的早餐<br>19:12:48.852 [main] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest4 - 送烟来了<br>19:12:48.852 [Thread-0] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest4 - 等到了它的烟<br></code></pre></td></tr></table></figure><h2 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h2><h3 id="固定运行顺序打印"><a href="#固定运行顺序打印" class="headerlink" title="固定运行顺序打印"></a>固定运行顺序打印</h3><h4 id="wait-notify-版"><a href="#wait-notify-版" class="headerlink" title="wait notify 版"></a>wait notify 版</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">static</span> final <span class="hljs-built_in">Object</span> lock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-keyword">static</span> volatile boolean  t2runed = <span class="hljs-literal">false</span>;<br><br>Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            synchronized (lock)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">while</span>(t2runed)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                        lock.wait();</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                        e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">                    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                System.out.println(<span class="hljs-string">&quot;1&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">Thread</span> <span class="hljs-title">t2</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            System.out.println(<span class="hljs-string">&quot;2&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            synchronized (lock)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                t2runed = <span class="hljs-literal">true</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">                lock.notify();</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;, <span class="hljs-string">&quot;t2&quot;</span>)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>1<br></code></pre></td></tr></table></figure><h4 id="Park-Unpark-版"><a href="#Park-Unpark-版" class="headerlink" title="Park Unpark 版"></a>Park Unpark 版</h4><p>可以看到，实现上很麻烦：</p><ul><li>首先，需要保证先 wait 再 notify，否则 wait 线程永远得不到唤醒。因此使用了『运行标记』来判断该不该 wait，比如先notify再wait就出问题了。</li><li>第二，如果有些干扰线程错误地 notify 了 wait 线程，条件不满足时还要重新等待，使用了 while 循环来解决 此问题</li><li>最后，唤醒对象上的 wait 线程需要使用 notifyAll，因为『同步对象』上的等待线程可能不止一个</li></ul><p>可以使用 LockSupport 类的 park 和 unpark 来简化上面的题目：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs livescript">Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">1000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-regexp">// 当没有『许可』时，当前线程暂停运行；有『许可』时，用掉这个『许可』，当前线程恢复运行</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function"> LockSupport.park();</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function"> System.out.println(&quot;1&quot;);</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">&#125;);</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">Thread t2 = new Thread(() -&gt; &#123;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function"> System.out.println(&quot;2&quot;);</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function"> //</span> 给线程 t1 发放『许可』（多次连续调用 unpark 只会发放一个『许可』）</span></span><br><span class="hljs-params"><span class="hljs-function"> LockSupport.unpark(t1);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br></code></pre></td></tr></table></figure><p>park 和 unpark 方法比较灵活，他俩谁先调用，谁后调用无所谓。并且是以线程为单位进行『暂停』和『恢复』， 不需要『同步对象』和『运行标记』</p><h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><p>线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现</p><h4 id="wait-notify-版-1"><a href="#wait-notify-版-1" class="headerlink" title="wait notify 版"></a>wait notify 版</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutPutTest3</span> &#123;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        SyncWaitNotify syncWaitNotify = <span class="hljs-keyword">new</span> SyncWaitNotify(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br><br>        <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            syncWaitNotify.<span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;a&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            syncWaitNotify.<span class="hljs-built_in">print</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;b&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            syncWaitNotify.<span class="hljs-built_in">print</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;c&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">SyncWaitNotify</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">private</span> <span class="hljs-title">int</span> <span class="hljs-title">flag</span>;</span><br><span class="hljs-function">    <span class="hljs-title">private</span> <span class="hljs-title">int</span> <span class="hljs-title">loopNumber</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">SyncWaitNotify</span><span class="hljs-params">(int flag, int loopNumber)</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">this</span>.<span class="hljs-title">flag</span> = <span class="hljs-title">flag</span>;</span><br><span class="hljs-function">        <span class="hljs-title">this</span>.<span class="hljs-title">loopNumber</span> = <span class="hljs-title">loopNumber</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">print</span><span class="hljs-params">(int waitFlag, int nextFlag, <span class="hljs-built_in">String</span> str)</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">synchronized</span> <span class="hljs-params">(this)</span>&#123;</span><br><span class="hljs-function">                <span class="hljs-title">while</span><span class="hljs-params">(flag != waitFlag)</span>&#123;</span><br><span class="hljs-function">                    <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">                        <span class="hljs-title">this</span>.<span class="hljs-title">wait</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">                    &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function">                        <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">                    &#125;</span><br><span class="hljs-function">                &#125;</span><br><span class="hljs-function">                <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(str)</span>;</span><br><span class="hljs-function">                <span class="hljs-title">flag</span> = <span class="hljs-title">nextFlag</span>;</span><br><span class="hljs-function">                <span class="hljs-title">this</span>.<span class="hljs-title">notifyAll</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            &#125;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="ReentrantLock版"><a href="#ReentrantLock版" class="headerlink" title="ReentrantLock版"></a>ReentrantLock版</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs livescript">package output;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @description: TODO(一句话描述该做什么)</span><br><span class="hljs-comment"> * @Author : </span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutPutTest4</span> &#123;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br>        AwaitSignal awaitSignal = <span class="hljs-keyword">new</span> AwaitSignal(<span class="hljs-number">5</span>);<br>        Condition a = awaitSignal.newCondition();<br>        Condition b = awaitSignal.newCondition();<br>        Condition c = awaitSignal.newCondition();<br><br>        <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            awaitSignal.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a&quot;</span>,a,b);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;,<span class="hljs-string">&quot;t1&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            awaitSignal.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;b&quot;</span>,b,c);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;,<span class="hljs-string">&quot;t1&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            awaitSignal.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;c&quot;</span>,c,a);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;,<span class="hljs-string">&quot;t1&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">Thread</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">awaitSignal</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">a</span>.<span class="hljs-title">signal</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125;<span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">awaitSignal</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">AwaitSignal</span> <span class="hljs-title">extends</span> <span class="hljs-title">ReentrantLock</span>&#123;</span><br><span class="hljs-function">    <span class="hljs-title">private</span> <span class="hljs-title">int</span> <span class="hljs-title">loopNumber</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">AwaitSignal</span><span class="hljs-params">(int loopNumber)</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">this</span>.<span class="hljs-title">loopNumber</span> = <span class="hljs-title">loopNumber</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">print</span><span class="hljs-params">( <span class="hljs-built_in">String</span> str,Condition cur,Condition next)</span>&#123;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">                <span class="hljs-title">cur</span>.<span class="hljs-title">await</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">                <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(str)</span>;</span><br><span class="hljs-function">                <span class="hljs-title">next</span>.<span class="hljs-title">signal</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function">                <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            &#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function">                <span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            &#125;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="park-x2F-unpark"><a href="#park-x2F-unpark" class="headerlink" title="park&#x2F;unpark"></a>park&#x2F;unpark</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs livescript">package output;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @description: TODO(一句话描述该做什么)</span><br><span class="hljs-comment"> * @Author : 彭建飞</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutPutTest5</span> &#123;<br>    <span class="hljs-keyword">static</span> Thread a;<br>    <span class="hljs-keyword">static</span> Thread b;<br>    <span class="hljs-keyword">static</span> Thread c;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br>        SyncPark syncPark = <span class="hljs-keyword">new</span> SyncPark(<span class="hljs-number">5</span>);<br>        a = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            syncPark.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a&quot;</span>,b);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">b</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            syncPark.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;b&quot;</span>,c);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">c</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            syncPark.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;c&quot;</span>,a);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">a</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">b</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">c</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">Thread</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">LockSupport</span>.<span class="hljs-title">unpark</span><span class="hljs-params">(a)</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">SyncPark</span>&#123;</span><br><span class="hljs-function">    <span class="hljs-title">private</span> <span class="hljs-title">int</span> <span class="hljs-title">loopNumber</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">SyncPark</span><span class="hljs-params">(int loopNumber)</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">this</span>.<span class="hljs-title">loopNumber</span> = <span class="hljs-title">loopNumber</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-built_in">String</span> str , Thread next)</span>&#123;</span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">LockSupport</span>.<span class="hljs-title">park</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(str)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">LockSupport</span>.<span class="hljs-title">unpark</span><span class="hljs-params">(next)</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Jvm</title>
    <link href="/2023/02/22/Jvm/"/>
    <url>/2023/02/22/Jvm/</url>
    
    <content type="html"><![CDATA[<p>一、JVM 内存区域<br>Java虚拟机在运行时，会把内存空间分为若干个区域，根据《Java虚拟机规范（Java SE 7 版）》的规定，Java虚拟机所管理的内存区域分为如下部分：<em><strong>方法区、堆内存、虚拟机栈、本地方法栈、程序计数器</strong></em>。</p><p><img src="/../Jvm_pic/1.png" alt="Jvm"></p><p>参考：<a href="https://cloud.tencent.com/developer/article/1698363">内存篇：JVM内存结构 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p>1、<em><strong>方法区</strong></em></p><p>方法区主要用于存储虚拟机加载的<em><strong>类信息、常量、静态变量，以及编译器编译后的代码</strong></em>等数据。在<em><strong>jdk1.7</strong></em>及<em><strong>其之前</strong></em>，方法区是堆的一个“<em><strong>逻辑部分</strong></em>”（一片连续的堆空间），但为了与堆做区分，方法区还有个名字叫“非堆”，也有人用“永久代”（<em><strong>HotSpot</strong></em>对方法区的实现方法）来表示方法区。（<em><strong>永久代&#x3D;&#x3D;方法区</strong></em>）</p><p>从<em><strong>jdk1.7</strong></em>已经开始准备“去永久代”的规划，jdk1.7的HotSpot中，已经把原本放在方法区中的<em><strong>静态变量</strong></em>、<em><strong>字符串常量池</strong></em>等<em><strong>移到堆内存</strong></em>中，（常量池除字符串常量池还有class常量池等），这里只是把字符串常量池移到堆内存中；在<em><strong>jdk1.8</strong></em>中，方法区已经不存在，原方法区中存储的类信息、编译后的代码数据等已经移动到了<em><strong>元空间</strong></em>（MetaSpace）中，<em><strong>元空间并没有处于堆内存上</strong></em>，而是直接占用的<em><strong>本地内存</strong></em>（NativeMemory）。根据网上的资料结合自己的理解对jdk1.3~1.6、jdk1.7、jdk1.8中方法区的变迁画了张图如下（如有不合理的地方希望读者指出）：</p><p><img src="/../Jvm_pic/Jvm%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81.png"></p><p>去永久代的原因有：</p><p>（1）字符串存在永久代中，容易出现性能问题和内存溢出。</p><p>（2）类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</p><p>（3）永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p><p>2、<em><strong>堆内存</strong></em></p><p>堆内存主要用于存放<strong>对象和数组</strong>，它是JVM管理的内存中最大的一块区域，<strong>堆内存和方法区都被所有线程共享</strong>，在虚拟机启动时创建。在垃圾收集的层面上来看，由于现在收集器基本上都采用分代收集算法，因此堆还可以分为<strong>新生代（YoungGeneration）和老年代（OldGeneration）</strong>，<strong>新生代还可以分为 Eden、From Survivor、To Survivor</strong>。</p><p>堆具有以下特点：</p><ul><li>堆内存最大</li><li>堆是被线程共享，</li><li>堆的目的就是存放对象，几乎所有的对象实例都在此分配。当然，随着优化技术的更新，某些数据也会被放在栈上等。</li></ul><p>因为堆占用内存空间最大，堆也是Java垃圾回收的主要区域（重点对象），因此也称作“GC堆”（Garbage Collected Heap）</p><p><img src="/../Jvm_pic/2.png"></p><p> 同样，对上图呈现内容汇总分析：</p><ul><li>堆的GC操作采用分代收集算法。</li><li>堆区分了新生代和老年代。</li><li>新生代又分为：Eden空间、From Survivor（S0）空间、To Survivor（S1）空间。</li></ul><p>Java虚拟机规范规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。也就是说堆的内存是一块块拼凑起来的。要增加堆空间时，往上“拼凑”（可扩展性）即可，但当堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><p>3、<em><strong>程序计数器</strong></em></p><p>程序计数器是一块非常小的内存空间，可以看做是当前线程执行字节码的行号指示器，<strong>每个线程都有一个独立的程序计数器，因此程序计数器是线程私有的一块空间</strong>，此外，<strong>程序计数器是Java虚拟机规定的唯一不会发生内存溢出的区域</strong>。</p><p>4、<em><strong>虚拟机栈</strong></em></p><p><strong>虚拟机栈也是每个线程私有的一块内存空间</strong>，它描述的是方法的内存模型，直接看下图所示：</p><p><img src="/../Jvm_pic/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png"></p><p>虚拟机会为<strong>每个线程</strong>分配一个虚拟机栈，每个虚拟机栈中都有若干个栈帧，每个栈帧中<strong>存储了局部变量表、操作数栈、动态链接、返回地址等</strong>。一个栈帧就对应 Java 代码中的一个方法，当线程执行到一个方法时，就代表这个方法对应的栈帧已经进入虚拟机栈并且处于栈顶的位置，每一个 Java 方法从被调用到执行结束，就对应了一个栈帧从入栈到出栈的过程。</p><ul><li>局部变量表(Local Variable Table)是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。包括8种基本数据类型（int、short、byte、char、double、float、long、boolean）、对象引用（reference类型）和returnAddress类型（指向一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<strong>StackOverflowError</strong>异常；如果虚拟机栈动态扩展时无法申请到足够的内存时会抛出<strong>OutOfMemoryError</strong>异常。</li><li>操作数栈(Operand Stack)也称作操作栈，是一个后入先出栈(LIFO)。随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈&#x2F;入栈操作。</li><li>动态链接：Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态链接(Dynamic Linking)。</li><li>方法返回：无论方法是否正常完成，都需要返回到方法被调用的位置，程序才能继续进行。</li></ul><p>5、<em><strong>本地方法栈</strong></em></p><p>本地方法栈与虚拟机栈的区别是，虚拟机栈执行的是 Java 方法，本地方法栈执行的是本地方法（Native Method）,其他基本上一致，在 HotSpot 中直接把本地方法栈和虚拟机栈合二为一，这里暂时不做过多叙述。</p><p>6、<em><strong>元空间</strong></em></p><p>上面说到，jdk1.8 中，已经不存在永久代（方法区），替代它的一块空间叫做 “ 元空间 ”，和永久代类似，都是 JVM 规范对方法区的实现，但是<strong>元空间并不在虚拟机中，而是使用本地内存</strong>，元空间的大小仅受本地内存限制，但可以通过 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 来指定元空间的大小。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2023/02/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1，设计模式概述"><a href="#1，设计模式概述" class="headerlink" title="1，设计模式概述"></a>1，设计模式概述</h1><h2 id="1-1-软件设计模式的产生背景"><a href="#1-1-软件设计模式的产生背景" class="headerlink" title="1.1 软件设计模式的产生背景"></a>1.1 软件设计模式的产生背景</h2><p>“设计模式”最初并不是出现在软件设计中，而是被用于建筑领域的设计中。</p><p>1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任<code>克里斯托夫·亚历山大（Christopher Alexander）</code>在他的著作《建筑模式语言：城镇、建筑、构造》中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。</p><p>1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）著称。  </p><h2 id="1-2-软件设计模式的概念"><a href="#1-2-软件设计模式的概念" class="headerlink" title="1.2 软件设计模式的概念"></a>1.2 软件设计模式的概念</h2><p>软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。</p><h2 id="1-3-学习设计模式的必要性"><a href="#1-3-学习设计模式的必要性" class="headerlink" title="1.3 学习设计模式的必要性"></a>1.3 学习设计模式的必要性</h2><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。</p><p>正确使用设计模式具有以下优点。</p><ul><li>可以提高程序员的思维能力、编程能力和设计能力。</li><li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li></ul><h2 id="1-4-设计模式分类"><a href="#1-4-设计模式分类" class="headerlink" title="1.4 设计模式分类"></a>1.4 设计模式分类</h2><ul><li><p><strong>创建型模式</strong></p><p>用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</p></li><li><p><strong>结构型模式</strong></p><p>用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</p></li><li><p><strong>行为型模式</strong></p><p>用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</p></li></ul><h1 id="2，UML图"><a href="#2，UML图" class="headerlink" title="2，UML图"></a>2，UML图</h1><p>统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</p><p>UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。</p><h2 id="2-1-类图概述"><a href="#2-1-类图概述" class="headerlink" title="2.1 类图概述"></a>2.1 类图概述</h2><p>类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。</p><h2 id="2-2-类图的作用"><a href="#2-2-类图的作用" class="headerlink" title="2.2 类图的作用"></a>2.2 类图的作用</h2><ul><li>在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解；</li><li>类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。</li></ul><h2 id="2-3-类图表示法"><a href="#2-3-类图表示法" class="headerlink" title="2.3 类图表示法"></a>2.3 类图表示法</h2><h3 id="2-3-1-类的表示方式"><a href="#2-3-1-类的表示方式" class="headerlink" title="2.3.1 类的表示方式"></a>2.3.1 类的表示方式</h3><p>在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。 </p><p><img src="/../img/Employee.jpg" alt="img"></p><p>属性&#x2F;方法名称前加的加号和减号表示了这个属性&#x2F;方法的可见性，UML类图中表示可见性的符号有三种：</p><ul><li><p>+：表示public</p></li><li><p>-：表示private</p></li><li><p>#：表示protected</p></li></ul><p>属性的完整表示方式是： <strong>可见性  名称 ：类型 [ &#x3D; 缺省值]</strong>  </p><p>方法的完整表示方式是： <strong>可见性  名称(参数列表) [ ： 返回类型]</strong></p><blockquote><p>注意：</p><p>​1，中括号中的内容表示是可选的</p><p>​2，也有将类型放在变量名前面，返回值类型放在方法名前面</p></blockquote><p><strong>举个栗子：</strong></p><p><img src="/../img/demo.png" alt="img"></p><p>上图Demo类定义了三个方法：</p><ul><li>method()方法：修饰符为public，没有参数，没有返回值。</li><li>method1()方法：修饰符为private，没有参数，返回值类型为String。</li><li>method2()方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为String，返回值类型是int。</li></ul><h3 id="2-3-2-类与类之间关系的表示方式"><a href="#2-3-2-类与类之间关系的表示方式" class="headerlink" title="2.3.2 类与类之间关系的表示方式"></a>2.3.2 类与类之间关系的表示方式</h3><h4 id="2-3-2-1-关联关系"><a href="#2-3-2-1-关联关系" class="headerlink" title="2.3.2.1 关联关系"></a>2.3.2.1 关联关系</h4><p>关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。</p><p>关联又可以分为单向关联，双向关联，自关联。</p><p><strong>1，单向关联</strong></p><p><img src="/../img/customer_address.png" alt="img"></p><p>在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。</p><p><strong>2，双向关联</strong></p><p><img src="/img/customer_product.png" alt="img"></p><p>从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。</p><p>在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List&lt;Product&gt;，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。</p><p><strong>3，自关联</strong></p><p><img src="/../img/node.png" alt="img"></p><p>自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。</p><h4 id="2-3-2-2-聚合关系"><a href="#2-3-2-2-聚合关系" class="headerlink" title="2.3.2.2 聚合关系"></a>2.3.2.2 聚合关系</h4><p>聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。</p><p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p><p>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：</p><p><img src="/../img/image-20191229173422328.png" alt="img"></p><h4 id="2-3-2-3-组合关系"><a href="#2-3-2-3-组合关系" class="headerlink" title="2.3.2.3 组合关系"></a>2.3.2.3 组合关系</h4><p>组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。</p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p><p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：</p><p><img src="/../img/image-20191229173455149.png" alt="img"></p><h4 id="2-3-2-4-依赖关系"><a href="#2-3-2-4-依赖关系" class="headerlink" title="2.3.2.4 依赖关系"></a>2.3.2.4 依赖关系</h4><p>依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p><p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：</p><p><img src="/../img/image-20191229173518926.png" alt="img"></p><h4 id="2-3-2-5-继承关系"><a href="#2-3-2-5-继承关系" class="headerlink" title="2.3.2.5 继承关系"></a>2.3.2.5 继承关系</h4><p>继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。</p><p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示：</p><p><img src="/../img/image-20191229173539838.png" alt="img"></p><h4 id="2-3-2-6-实现关系"><a href="#2-3-2-6-实现关系" class="headerlink" title="2.3.2.6 实现关系"></a>2.3.2.6 实现关系</h4><p>实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p><p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。</p><p><img src="/../img/image-20191229173554296.png" alt="img"></p><h1 id="3，软件设计原则"><a href="#3，软件设计原则" class="headerlink" title="3，软件设计原则"></a>3，软件设计原则</h1><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p><h2 id="3-1-开闭原则"><a href="#3-1-开闭原则" class="headerlink" title="3.1 开闭原则"></a>3.1 开闭原则</h2><p><strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p><p>想要达到这样的效果，我们需要使用接口和抽象类。</p><p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p><p>下面以 <code>搜狗输入法</code> 的皮肤为例介绍开闭原则的应用。</p><p>【例】<code>搜狗输入法</code> 的皮肤设计。</p><p>分析：<code>搜狗输入法</code> 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。</p><p><img src="/../img/open-close.png" alt="img"></p><h2 id="3-2-里氏代换原则"><a href="#3-2-里氏代换原则" class="headerlink" title="3.2 里氏代换原则"></a>3.2 里氏代换原则</h2><p>里氏代换原则是面向对象设计的基本原则之一。</p><p>里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p><p>下面看一个里氏替换原则中经典的一个例子</p><p>【例】正方形不是长方形。</p><p>在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。</p><p><img src="/../img/%E6%AD%A3%E6%96%B9%E5%BD%A2%E4%B8%8D%E6%98%AF%E9%95%BF%E6%96%B9%E5%BD%A2.png" alt="img"></p><p>代码如下：</p><p><strong>长方形类（Rectangle）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> length;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> width;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getLength</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLength</span><span class="hljs-params">(<span class="hljs-type">double</span> length)</span> &#123;<br>        <span class="hljs-built_in">this</span>.length = length;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getWidth</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> width;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWidth</span><span class="hljs-params">(<span class="hljs-type">double</span> width)</span> &#123;<br>        <span class="hljs-built_in">this</span>.width = width;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>正方形（Square）：</strong></p><p>由于正方形的长和宽相同，所以在方法setLength和setWidth中，对长度和宽度都需要赋相同值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWidth</span><span class="hljs-params">(<span class="hljs-type">double</span> width)</span> &#123;<br>        <span class="hljs-built_in">super</span>.setLength(width);<br>        <span class="hljs-built_in">super</span>.setWidth(width);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLength</span><span class="hljs-params">(<span class="hljs-type">double</span> length)</span> &#123;<br>        <span class="hljs-built_in">super</span>.setLength(length);<br>        <span class="hljs-built_in">super</span>.setWidth(length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类RectangleDemo是我们的软件系统中的一个组件，它有一个resize方法依赖基类Rectangle，resize方法是RectandleDemo类中的一个方法，用来实现宽度逐渐增长的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RectangleDemo</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(Rectangle rectangle)</span> &#123;<br>        <span class="hljs-keyword">while</span> (rectangle.getWidth() &lt;= rectangle.getLength()) &#123;<br>            rectangle.setWidth(rectangle.getWidth() + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//打印长方形的长和宽</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLengthAndWidth</span><span class="hljs-params">(Rectangle rectangle)</span> &#123;<br>        System.out.println(rectangle.getLength());<br>        System.out.println(rectangle.getWidth());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Rectangle</span> <span class="hljs-variable">rectangle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>();<br>        rectangle.setLength(<span class="hljs-number">20</span>);<br>        rectangle.setWidth(<span class="hljs-number">10</span>);<br>        resize(rectangle);<br>        printLengthAndWidth(rectangle);<br><br>        System.out.println(<span class="hljs-string">&quot;============&quot;</span>);<br><br>        <span class="hljs-type">Rectangle</span> <span class="hljs-variable">rectangle1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Square</span>();<br>        rectangle1.setLength(<span class="hljs-number">10</span>);<br>        resize(rectangle1);<br>        printLengthAndWidth(rectangle1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们运行一下这段代码就会发现，假如我们把一个普通长方形作为参数传入resize方法，就会看到长方形宽度逐渐增长的效果，当宽度大于长度,代码就会停止，这种行为的结果符合我们的预期；假如我们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度都在不断增长，代码会一直运行下去，直至系统产生溢出错误。所以，普通的长方形是适合这段代码的，正方形不适合。<br>我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。</p><p>如何改进呢？此时我们需要重新设计他们之间的关系。抽象出来一个四边形接口(Quadrilateral)，让Rectangle类和Square类实现Quadrilateral接口</p><p><img src="/../img/%E6%AD%A3%E6%96%B9%E5%BD%A2%E4%B8%8D%E6%98%AF%E9%95%BF%E6%96%B9%E5%BD%A2%E6%94%B9%E8%BF%9B.png" alt="img"></p><h2 id="3-3-依赖倒转原则"><a href="#3-3-依赖倒转原则" class="headerlink" title="3.3 依赖倒转原则"></a>3.3 依赖倒转原则</h2><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p><p>下面看一个例子来理解依赖倒转原则</p><p>【例】组装电脑</p><p>现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。</p><p><strong>类图如下：</strong></p><p><img src="/../img/%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99.png" alt="img"></p><p>代码如下：</p><p><strong>希捷硬盘类（XiJieHardDisk）:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XiJieHardDisk</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HardDisk</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(String data)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;使用希捷硬盘存储数据&quot;</span> + data);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;使用希捷希捷硬盘取数据&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;数据&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Intel处理器（IntelCpu）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelCpu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cpu</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;使用Intel处理器&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>金士顿内存条（KingstonMemory）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KingstonMemory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Memory</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;使用金士顿作为内存条&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>电脑（Computer）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> XiJieHardDisk hardDisk;<br>    <span class="hljs-keyword">private</span> IntelCpu cpu;<br>    <span class="hljs-keyword">private</span> KingstonMemory memory;<br><br>    <span class="hljs-keyword">public</span> IntelCpu <span class="hljs-title function_">getCpu</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cpu;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCpu</span><span class="hljs-params">(IntelCpu cpu)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cpu = cpu;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> KingstonMemory <span class="hljs-title function_">getMemory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> memory;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMemory</span><span class="hljs-params">(KingstonMemory memory)</span> &#123;<br>        <span class="hljs-built_in">this</span>.memory = memory;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> XiJieHardDisk <span class="hljs-title function_">getHardDisk</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> hardDisk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHardDisk</span><span class="hljs-params">(XiJieHardDisk hardDisk)</span> &#123;<br>        <span class="hljs-built_in">this</span>.hardDisk = hardDisk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;计算机工作&quot;</span>);<br>        cpu.run();<br>        memory.save();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> hardDisk.get();<br>        System.out.println(<span class="hljs-string">&quot;从硬盘中获取的数据为：&quot;</span> + data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试类（TestComputer）：</strong></p><p>测试类用来组装电脑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestComputer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Computer</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>();<br>        computer.setHardDisk(<span class="hljs-keyword">new</span> <span class="hljs-title class_">XiJieHardDisk</span>());<br>        computer.setCpu(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IntelCpu</span>());<br>        computer.setMemory(<span class="hljs-keyword">new</span> <span class="hljs-title class_">KingstonMemory</span>());<br><br>        computer.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码可以看到已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件。</p><p>根据依赖倒转原则进行改进：</p><p>代码我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类。</p><p><strong>类图如下：</strong></p><p><img src="/../img/%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99%E6%94%B9%E8%BF%9B.png" alt="img"></p><p><strong>电脑（Computer）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> HardDisk hardDisk;<br>    <span class="hljs-keyword">private</span> Cpu cpu;<br>    <span class="hljs-keyword">private</span> Memory memory;<br><br>    <span class="hljs-keyword">public</span> HardDisk <span class="hljs-title function_">getHardDisk</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> hardDisk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHardDisk</span><span class="hljs-params">(HardDisk hardDisk)</span> &#123;<br>        <span class="hljs-built_in">this</span>.hardDisk = hardDisk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Cpu <span class="hljs-title function_">getCpu</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cpu;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCpu</span><span class="hljs-params">(Cpu cpu)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cpu = cpu;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Memory <span class="hljs-title function_">getMemory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> memory;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMemory</span><span class="hljs-params">(Memory memory)</span> &#123;<br>        <span class="hljs-built_in">this</span>.memory = memory;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;计算机工作&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。</p><h2 id="3-4-接口隔离原则"><a href="#3-4-接口隔离原则" class="headerlink" title="3.4 接口隔离原则"></a>3.4 接口隔离原则</h2><p>客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。</p><p>下面看一个例子来理解接口隔离原则</p><p>【例】安全门案例</p><p>我们需要创建一个<code>黑马</code>品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下：</p><p><img src="/../img/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99.png" alt="img"></p><p>上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图：</p><p><img src="/../img/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%991.png" alt="img"></p><p>代码如下：</p><p><strong>AntiTheft（接口）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AntiTheft</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">antiTheft</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Fireproof（接口）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fireproof</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fireproof</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Waterproof（接口）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Waterproof</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">waterproof</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>HeiMaSafetyDoor（类）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeiMaSafetyDoor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AntiTheft</span>,Fireproof,Waterproof &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">antiTheft</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;防盗&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fireproof</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;防火&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waterproof</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;防水&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ItcastSafetyDoor（类）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItcastSafetyDoor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AntiTheft</span>,Fireproof &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">antiTheft</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;防盗&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fireproof</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;防火&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-5-迪米特法则"><a href="#3-5-迪米特法则" class="headerlink" title="3.5 迪米特法则"></a>3.5 迪米特法则</h2><p>迪米特法则又叫最少知识原则。</p><p>只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。</p><p>其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><p>下面看一个例子来理解迪米特法则</p><p>【例】明星与经纪人的关系实例</p><p>明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。</p><p>类图如下：</p><img src="../img/迪米特法则.png" alt="image-20191229173554296" style="zoom:80%;" /><p>代码如下：</p><p><strong>明星类（Star）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Star</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Star</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>粉丝类（Fans）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fans</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Fans</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>媒体公司类（Company）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Company</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Company</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>经纪人类（Agent）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Agent</span> &#123;<br>    <span class="hljs-keyword">private</span> Star star;<br>    <span class="hljs-keyword">private</span> Fans fans;<br>    <span class="hljs-keyword">private</span> Company company;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStar</span><span class="hljs-params">(Star star)</span> &#123;<br>        <span class="hljs-built_in">this</span>.star = star;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFans</span><span class="hljs-params">(Fans fans)</span> &#123;<br>        <span class="hljs-built_in">this</span>.fans = fans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCompany</span><span class="hljs-params">(Company company)</span> &#123;<br>        <span class="hljs-built_in">this</span>.company = company;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meeting</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(fans.getName() + <span class="hljs-string">&quot;与明星&quot;</span> + star.getName() + <span class="hljs-string">&quot;见面了。&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">business</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(company.getName() + <span class="hljs-string">&quot;与明星&quot;</span> + star.getName() + <span class="hljs-string">&quot;洽淡业务。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-6-合成复用原则"><a href="#3-6-合成复用原则" class="headerlink" title="3.6 合成复用原则"></a>3.6 合成复用原则</h2><p>合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p><p>通常类的复用分为继承复用和合成复用两种。</p><p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：</p><ol><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>对象间的耦合度低。可以在类的成员位置声明抽象。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ol><p>下面看一个例子来理解合成复用原则</p><p>【例】汽车分类管理程序</p><p>汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下： </p><img src="../img/合成复用原则.png" alt="image-20191229173554296" style="zoom:80%;" /><p>从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。</p><img src="../img/合成复用原则1.png" alt="image-20191229173554296" style="zoom:80%;" /><h1 id="4，创建者模式"><a href="#4，创建者模式" class="headerlink" title="4，创建者模式"></a>4，创建者模式</h1><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。</p><p>这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。</p><p>创建型模式分为：</p><ul><li>单例模式</li><li>工厂方法模式</li><li>抽象工程模式</li><li>原型模式</li><li>建造者模式</li></ul><h2 id="4-1-单例设计模式"><a href="#4-1-单例设计模式" class="headerlink" title="4.1 单例设计模式"></a>4.1 单例设计模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><h3 id="4-1-1-单例模式的结构"><a href="#4-1-1-单例模式的结构" class="headerlink" title="4.1.1 单例模式的结构"></a>4.1.1 单例模式的结构</h3><p>单例模式的主要有以下角色：</p><ul><li><strong>单例类</strong>。只能创建一个实例的类</li><li><strong>访问类</strong>。使用单例类</li></ul><h3 id="4-1-2-单例模式的实现"><a href="#4-1-2-单例模式的实现" class="headerlink" title="4.1.2 单例模式的实现"></a>4.1.2 单例模式的实现</h3><blockquote><p>单例设计模式分类两种：</p><p>​<strong>饿汉式</strong>：类加载就会导致该单实例对象被创建</p><p>​<strong>懒汉式</strong>：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p></blockquote><ol><li><p>饿汉式-方式1（静态变量方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 饿汉式</span><br><span class="hljs-comment"> *      静态变量创建类的对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。</p></li><li><p>饿汉式-方式2（静态代码块方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 恶汉式</span><br><span class="hljs-comment"> *      在静态代码块中创建该类对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。</p></li><li><p>懒汉式-方式1（线程不安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 懒汉式</span><br><span class="hljs-comment"> *  线程不安全</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。</p></li><li><p>懒汉式-方式2（线程安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 懒汉式</span><br><span class="hljs-comment"> *  线程安全</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。</p></li><li><p>懒汉式-方式3（双重检查锁）</p><p>再来讨论一下懒汉模式中加锁的问题，对于 <code>getInstance()</code> 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：<em><strong>双重检查锁模式</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双重检查方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123; <br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>   <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">//抢到锁之后再次判断是否为null</span><br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。</p><p>要解决双重检查锁模式带来空指针异常的问题，只需要使用 <code>volatile</code> 关键字, <code>volatile</code> 关键字可以保证可见性和有序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双重检查方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>   <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">//抢到锁之后再次判断是否为空</span><br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">小结：</font></p><p>添加 <code>volatile</code> 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。</p></li><li><p>懒汉式-方式4（静态内部类方式）</p><p>静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性&#x2F;方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 静态内部类方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder</p><p>并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。</p><p><font color="red">小结：</font></p><p>​静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p></li><li><p>枚举方式</p><p>枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 枚举方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​枚举方式属于恶汉式方式。</p></li></ol><h3 id="4-1-3-存在的问题"><a href="#4-1-3-存在的问题" class="headerlink" title="4.1.3 存在的问题"></a>4.1.3 存在的问题</h3><h4 id="4-1-3-1-问题演示"><a href="#4-1-3-1-问题演示" class="headerlink" title="4.1.3.1 问题演示"></a>4.1.3.1 问题演示</h4><p>破坏单例模式：</p><p>使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。</p><ul><li><p>序列化反序列化</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Test类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//往文件中写对象</span><br>        <span class="hljs-comment">//writeObject2File();</span><br>        <span class="hljs-comment">//从文件中读取对象</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> readObjectFromFile();<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> readObjectFromFile();<br><br>        <span class="hljs-comment">//判断两个反序列化后的对象是否是同一个对象</span><br>        System.out.println(s1 == s2);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">readObjectFromFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//创建对象输入流对象</span><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));<br>        <span class="hljs-comment">//第一个读取Singleton对象</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> (Singleton) ois.readObject();<br><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeObject2File</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//获取Singleton类的对象</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br>        <span class="hljs-comment">//创建对象输出流</span><br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));<br>        <span class="hljs-comment">//将instance对象写出到文件中</span><br>        oos.writeObject(instance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面代码运行结果是<code>false</code>，表明序列化和反序列化已经破坏了单例设计模式。</p></blockquote></li><li><p>反射</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> instance;<br>            &#125;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Test类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//获取Singleton类的字节码对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Singleton.class;<br>        <span class="hljs-comment">//获取Singleton类的私有无参构造方法对象</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor();<br>        <span class="hljs-comment">//取消访问检查</span><br>        constructor.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">//创建Singleton类的对象s1</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> (Singleton) constructor.newInstance();<br>        <span class="hljs-comment">//创建Singleton类的对象s2</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> (Singleton) constructor.newInstance();<br><br>        <span class="hljs-comment">//判断通过反射创建的两个Singleton对象是否是同一个对象</span><br>        System.out.println(s1 == s2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面代码运行结果是<code>false</code>，表明序列化和反序列化已经破坏了单例设计模式</p></blockquote></li></ul><blockquote><p><font color="red">注意：</font>枚举方式不会出现这两个问题。</p></blockquote><h4 id="4-1-3-2-问题的解决"><a href="#4-1-3-2-问题的解决" class="headerlink" title="4.1.3.2 问题的解决"></a>4.1.3.2 问题的解决</h4><ul><li><p>序列化、反序列方式破坏单例模式的解决方法</p><p>在Singleton类中添加<code>readResolve()</code>方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 下面是为了解决序列化反序列化破解单例模式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>源码解析：</strong></p><p>ObjectInputStream类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">readObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException&#123;<br>    ...<br>    <span class="hljs-comment">// if nested read, passHandle contains handle of enclosing object</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">outerHandle</span> <span class="hljs-operator">=</span> passHandle;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> readObject0(<span class="hljs-literal">false</span>);<span class="hljs-comment">//重点查看readObject0方法</span><br>    .....<br>&#125;<br>    <br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readObject0</span><span class="hljs-params">(<span class="hljs-type">boolean</span> unshared)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>...<br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">switch</span> (tc) &#123;<br>...<br><span class="hljs-keyword">case</span> TC_OBJECT:<br><span class="hljs-keyword">return</span> checkResolve(readOrdinaryObject(unshared));<span class="hljs-comment">//重点查看readOrdinaryObject方法</span><br>...<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        depth--;<br>        bin.setBlockDataMode(oldMode);<br>    &#125;    <br>&#125;<br>    <br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readOrdinaryObject</span><span class="hljs-params">(<span class="hljs-type">boolean</span> unshared)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>...<br><span class="hljs-comment">//isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类，</span><br>    obj = desc.isInstantiable() ? desc.newInstance() : <span class="hljs-literal">null</span>; <br>    ...<br>    <span class="hljs-comment">// 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true</span><br>    <span class="hljs-keyword">if</span> (obj != <span class="hljs-literal">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="hljs-literal">null</span> &amp;&amp; desc.hasReadResolveMethod()) &#123;<br>    <span class="hljs-comment">// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量</span><br>    <span class="hljs-comment">// 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">rep</span> <span class="hljs-operator">=</span> desc.invokeReadResolve(obj);<br>     ...<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>反射方式破解单例的解决方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           反射破解单例模式需要添加的代码</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> instance;<br>            &#125;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">说明:</font></p><p>​这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操作。</p></li></ul><h3 id="JDK源码解析-Runtime类"><a href="#JDK源码解析-Runtime类" class="headerlink" title="JDK源码解析-Runtime类"></a>JDK源码解析-Runtime类</h3><p>Runtime类就是使用的单例设计模式。</p><ol><li><p>通过源代码查看使用的是哪儿种单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Runtime</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Runtime</span> <span class="hljs-variable">currentRuntime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runtime</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the runtime object associated with the current Java application.</span><br><span class="hljs-comment">     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance</span><br><span class="hljs-comment">     * methods and must be invoked with respect to the current runtime object.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</span><br><span class="hljs-comment">     *          Java application.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runtime <span class="hljs-title function_">getRuntime</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> currentRuntime;<br>    &#125;<br><br>    <span class="hljs-comment">/** Don&#x27;t let anyone else instantiate this class */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Runtime</span><span class="hljs-params">()</span> &#123;&#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面源代码中可以看出Runtime类使用的是恶汉式（静态属性）方式来实现单例模式的。</p></li><li><p>使用Runtime类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuntimeDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//获取Runtime类对象</span><br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br><br>        <span class="hljs-comment">//返回 Java 虚拟机中的内存总量。</span><br>        System.out.println(runtime.totalMemory());<br>        <span class="hljs-comment">//返回 Java 虚拟机试图使用的最大内存量。</span><br>        System.out.println(runtime.maxMemory());<br><br>        <span class="hljs-comment">//创建一个新的进程执行指定的字符串命令，返回进程对象</span><br>        <span class="hljs-type">Process</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> runtime.exec(<span class="hljs-string">&quot;ipconfig&quot;</span>);<br>        <span class="hljs-comment">//获取命令执行后的结果，通过输入流获取</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> process.getInputStream();<br>        <span class="hljs-type">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>* <span class="hljs-number">100</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> inputStream.read(arr);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(arr,<span class="hljs-number">0</span>,b,<span class="hljs-string">&quot;gbk&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
