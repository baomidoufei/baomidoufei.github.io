<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python协程和猴子补丁</title>
    <link href="/2024/07/13/Python%E5%8D%8F%E7%A8%8B%E4%B8%8E%E7%8C%B4%E5%AD%90%E8%A1%A5%E4%B8%81/"/>
    <url>/2024/07/13/Python%E5%8D%8F%E7%A8%8B%E4%B8%8E%E7%8C%B4%E5%AD%90%E8%A1%A5%E4%B8%81/</url>
    
    <content type="html"><![CDATA[<h2 id="协程基础"><a href="#协程基础" class="headerlink" title="协程基础"></a>协程基础</h2><h3 id="协程概念"><a href="#协程概念" class="headerlink" title="协程概念"></a>协程概念</h3><p>协程（Coroutines）是一种特殊的软件构造，是一种用户态的轻量级线程。它<strong>允许程序在执行过程中暂停并恢复执行，而不会丢失当前的执行上下文</strong>。与线程和进程不同，<strong>协程在单个线程中运行</strong>，通过<strong>调度机制</strong>实现并发，降低了上下文切换的开销，提高了程序的执行效率。协程通常用于处理I&#x2F;O密集型任务，如网络请求、文件读写等。在 Python 中协程就是一个可以暂停执行的函数，听起来和生成器的概念一样。</p><h3 id="生成器与yield的原理"><a href="#生成器与yield的原理" class="headerlink" title="生成器与yield的原理"></a><strong>生成器与yield的原理</strong></h3><p>生成器（Generators）是Python中实现协程的一种方式，它通过内置的<code>yield</code>关键字来暂停和恢复执行。当函数遇到<code>yield</code>时，会暂停执行并返回一个值，下次调用时会从上次暂停的地方继续执行。<code>yield</code>实际上是一个特殊的return语句，它会保存当前的状态（包括局部变量和执行上下文），当再次调用时，这些状态会被恢复。</p><h3 id="协程与多线程-x2F-多进程的区别"><a href="#协程与多线程-x2F-多进程的区别" class="headerlink" title="协程与多线程&#x2F;多进程的区别"></a><strong>协程与多线程&#x2F;多进程的区别</strong></h3><ul><li><strong>多线程</strong>：线程是操作系统层面的并行执行单位，线程间通信需要锁等同步机制，上下文切换开销大，适合CPU密集型任务。</li><li><strong>多进程</strong>：进程是独立的执行环境，拥有自己的内存空间，适合I&#x2F;O密集型任务，但创建和销毁进程开销大。</li><li><strong>协程</strong>：协程在单线程中通过控制流切换实现并发，没有线程切换开销，但资源占用相对较少，适合I&#x2F;O等待任务。</li></ul><h3 id="协程的生命周期与状态转换"><a href="#协程的生命周期与状态转换" class="headerlink" title="协程的生命周期与状态转换"></a><strong>协程的生命周期与状态转换</strong></h3><ul><li><strong>创建</strong>：函数定义为生成器，使用<code>yield</code>关键字。</li><li><strong>启动</strong>：通过调用生成器实例的<code>next()</code>或<code>send()</code>方法开始执行，直到遇到<code>yield</code>。</li><li><strong>暂停</strong>：遇到<code>yield</code>时，函数暂停，保存当前状态。</li><li><strong>恢复</strong>：通过<code>send()</code>方法传入值，函数从上次暂停的地方继续执行。</li><li><strong>结束</strong>：当没有更多<code>yield</code>可执行，或遇到<code>return</code>语句时，协程结束</li></ul><p>实例1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">coroutine_work</span>():<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;-&gt;start work&#x27;</span>)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        rc = (<span class="hljs-keyword">yield</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&gt;work&#x27;</span>, rc)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">coroutine_eat</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&gt;start eat&#x27;</span>)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        rc = (<span class="hljs-keyword">yield</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&gt;eat&#x27;</span>, rc)<br><br><br>cw = coroutine_work()<br>ce = coroutine_eat()<br><span class="hljs-built_in">next</span>(cw)  <span class="hljs-comment"># next启动work协程</span><br><span class="hljs-built_in">next</span>(ce)  <span class="hljs-comment"># next启动eat协程</span><br>cw.send(<span class="hljs-string">&#x27;1&#x27;</span>)<br>ce.send(<span class="hljs-string">&#x27;1&#x27;</span>)<br>cw.send(<span class="hljs-string">&#x27;2&#x27;</span>)<br>ce.send(<span class="hljs-string">&#x27;2&#x27;</span>)<br>ce.close()<br>cw.close()<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean">-&gt;start work<br>-&gt;start eat<br>-&gt;work <span class="hljs-number">1</span>                                   <br>-&gt;eat <span class="hljs-number">1</span>                                    <br>-&gt;work <span class="hljs-number">2</span><br>-&gt;eat <span class="hljs-number">2</span> <br></code></pre></td></tr></table></figure><p>实例2：使用协程计算移动平均值</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs axapta">def averager():<br>    total = <span class="hljs-number">0.0</span><br>    <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">avg</span> = None<br><br>    <span class="hljs-keyword">while</span> True:<br>        num = yield <span class="hljs-keyword">avg</span><br>        total += num<br>        <span class="hljs-keyword">count</span> += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">avg</span> = total/<span class="hljs-keyword">count</span><br><br><span class="hljs-meta"># run</span><br>ag = averager()<br><span class="hljs-meta"># 预激协程</span><br><span class="hljs-keyword">print</span>(<span class="hljs-keyword">next</span>(ag))     <span class="hljs-meta"># None</span><br><br><span class="hljs-keyword">print</span>(ag.send(<span class="hljs-number">10</span>))  <span class="hljs-meta"># 10</span><br><span class="hljs-keyword">print</span>(ag.send(<span class="hljs-number">20</span>))  <span class="hljs-meta"># 15</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">None</span><br><span class="hljs-attribute">10</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">15</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>解释：</p><ol><li>调用 next(ag) 函数后，协程会向前执行到 yield 表达式，产出 average 变量的初始值——None。</li><li>此时，协程在 yield 表达式处暂停。</li><li>使用 send() 激活协程，把发送的值赋给 num，并计算出 avg 的值，avd算完之后会被返回。</li><li>使用 print 打印出 yield 返回的数据。</li></ol><p>实例3：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">producer</span>():<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++++ 1个包子&quot;</span>, time.strftime(<span class="hljs-string">&quot;%X&quot;</span>))<br>        <span class="hljs-keyword">yield</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">consumer</span>():<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">next</span>(prd)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----- 1个包子&quot;</span>, time.strftime(<span class="hljs-string">&quot;%X&quot;</span>))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    prd = producer()<br>    consumer()<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++++</span> <span class="hljs-comment">1个包子 17:34:05</span><br><span class="hljs-comment">​</span><span class="hljs-literal">-----</span> <span class="hljs-comment">1个包子 17:34:05</span><br><span class="hljs-literal">+++++</span> <span class="hljs-comment">1个包子 17:34:06</span><br><span class="hljs-comment">​</span><span class="hljs-literal">-----</span> <span class="hljs-comment">1个包子 17:34:06</span><br><span class="hljs-literal">+++++</span> <span class="hljs-comment">1个包子 17:34:07</span><br><span class="hljs-comment">​</span><span class="hljs-literal">-----</span> <span class="hljs-comment">1个包子 17:34:07</span><br><span class="hljs-literal">+++++</span> <span class="hljs-comment">1个包子 17:34:08</span><br><span class="hljs-comment">​</span><span class="hljs-literal">-----</span> <span class="hljs-comment">1个包子 17:34:08</span><br><span class="hljs-literal">+++++</span> <span class="hljs-comment">1个包子 17:34:09</span><br><span class="hljs-comment">​</span><span class="hljs-literal">-----</span> <span class="hljs-comment">1个包子 17:34:09</span><br></code></pre></td></tr></table></figure><p>解释：上述代码中定义了两个生成器函数，<code>producer</code> 函数用于生产包子，<code>consumer</code> 函数用于消费包子。在 <code>consumer</code> 函数中，使用 <code>next</code> 函数来获取 <code>producer</code> 函数中 <code>yield</code> 语句产出的值，从而实现了两个函数的交替执行。</p><h3 id="yield-from获取协程的返回值"><a href="#yield-from获取协程的返回值" class="headerlink" title="yield from获取协程的返回值"></a>yield from获取协程的返回值</h3><p>为了得到返回值，协程必须正常终止；然后生成器对象会抛出<strong>StopIteration</strong> 异常，<strong>异常对象的 value 属性保存着返回的值</strong>。</p><p><strong>yield from 结构会在内部自动捕获 StopIteration 异常</strong>。对 yield from 结构来说，解释器不仅会捕获 StopIteration 异常，还会把value 属性的值变成 yield from 表达式的值。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">gen</span>():</span><br><span class="hljs-function">    <span class="hljs-variable">for</span> <span class="hljs-variable">c</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-string">&#x27;AB&#x27;</span>:</span><br><span class="hljs-function">        <span class="hljs-variable">yield</span> <span class="hljs-variable">c</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-title">list</span>(<span class="hljs-title">gen</span>()))</span><br><br><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">gen_new</span>():</span><br><span class="hljs-function">    <span class="hljs-variable">yield</span> <span class="hljs-variable">from</span> <span class="hljs-string">&#x27;AB&#x27;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-title">list</span>(<span class="hljs-title">gen_new</span>()))</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[<span class="hljs-symbol">&#x27;A</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;]<br>[<span class="hljs-symbol">&#x27;A</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;]<br></code></pre></td></tr></table></figure><p>yield from x 表达式对 x 对象所做的第一件事是，调用 iter(x)，从中获取<strong>迭代器</strong>，因此，x 可以是任何可迭代的对象，这只是 yield from 最基础的用法,感觉yield可以看作一个return。</p><h3 id="使用yield完成协程任务"><a href="#使用yield完成协程任务" class="headerlink" title="使用yield完成协程任务"></a>使用yield完成协程任务</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在函数中有yield，函数就变成了生成器，就可以使用next()方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">task1</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-built_in">str</span>(i))<br>        <span class="hljs-keyword">yield</span><br>        time.sleep(<span class="hljs-number">1</span>)<br> <br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">task2</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;B&#x27;</span> + <span class="hljs-built_in">str</span>(i))<br>        <span class="hljs-keyword">yield</span><br>        time.sleep(<span class="hljs-number">2</span>)<br> <br> <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    g1 = task1()<br>    g2 = task2()<br> <br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-built_in">next</span>(g1)<br>            <span class="hljs-built_in">next</span>(g2)<br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">A0</span><br><span class="hljs-keyword">B0</span><br><span class="hljs-keyword"></span><span class="hljs-built_in">A1</span><br><span class="hljs-keyword">B1</span><br><span class="hljs-keyword"></span><span class="hljs-built_in">A2</span><br><span class="hljs-keyword">B2</span><br></code></pre></td></tr></table></figure><h3 id="使用greenlet完成协程任务"><a href="#使用greenlet完成协程任务" class="headerlink" title="使用greenlet完成协程任务"></a>使用greenlet完成协程任务</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs css"># 使用greenlet完成协程任务<br>import <span class="hljs-selector-tag">time</span><br><span class="hljs-selector-tag">from</span> greenlet import greenlet<br> <br> <br>def <span class="hljs-selector-tag">a</span>():  # 任务A<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-built_in">str</span>(i))<br>        gb.<span class="hljs-built_in">switch</span>()<br>        time.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">0.1</span>)<br> <br> <br>def <span class="hljs-built_in">b</span>():  # 任务B<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;B&#x27;</span> + <span class="hljs-built_in">str</span>(i))<br>        gc.<span class="hljs-built_in">switch</span>()<br>        time.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">0.1</span>)<br> <br> <br>def <span class="hljs-built_in">c</span>():  # 任务C<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;C&#x27;</span> + <span class="hljs-built_in">str</span>(i))<br>        ga.<span class="hljs-built_in">switch</span>()<br>        time.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">0.1</span>)<br> <br> <br>if __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    ga = <span class="hljs-built_in">greenlet</span>(a)<br>    gb = <span class="hljs-built_in">greenlet</span>(b)<br>    gc = <span class="hljs-built_in">greenlet</span>(c)<br> <br>    ga.<span class="hljs-built_in">switch</span>()<br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">A0</span><br><span class="hljs-keyword">B0</span><br><span class="hljs-keyword"></span>C0<br><span class="hljs-built_in">A1</span><br><span class="hljs-keyword">B1</span><br><span class="hljs-keyword"></span>C1<br><span class="hljs-built_in">A2</span><br><span class="hljs-keyword">B2</span><br><span class="hljs-keyword"></span>C2<br><span class="hljs-built_in">A3</span><br><span class="hljs-keyword">B3</span><br><span class="hljs-keyword"></span>C3<br><span class="hljs-built_in">A4</span><br><span class="hljs-keyword">B4</span><br><span class="hljs-keyword"></span>C4<br></code></pre></td></tr></table></figure><h2 id="猴子补丁"><a href="#猴子补丁" class="headerlink" title="猴子补丁"></a>猴子补丁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>猴子补丁是一种在运行时动态修改模块、类、函数或对象行为的编程技术。它通常通过替换或扩展原有代码中的函数、方法或属性来实现。由于这种修改是在运行时进行的，因此无需修改原始代码或重新编译。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Python的动态类型系统和解释执行的特性使得猴子补丁成为可能。在Python中，几乎所有的东西都是对象，包括函数、方法、类等。这些对象都存储在模块的全局命名空间中，我们可以通过修改这些命名空间中的对象来改变程序的行为。</p><p>举个例子很容易懂</p><p>third_party:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">step1</span>():</span><br><span class="hljs-function">    <span class="hljs-title">print</span>(<span class="hljs-string">&quot;step1&quot;</span>)</span><br><br><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">step2</span>():</span><br><span class="hljs-function">    <span class="hljs-title">print</span>(<span class="hljs-string">&quot;step2&quot;</span>)</span><br><br><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">run</span>():</span><br><span class="hljs-function">    <span class="hljs-title">step1</span>()</span><br>    <span class="hljs-function"><span class="hljs-title">step2</span>()</span><br></code></pre></td></tr></table></figure><p>my_code:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># my_code.py</span><br>import mock<br>import third_party<br><br><br>def step3():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;step3&#x27;</span>)<br><br><br>def my_run():<br>    third_party.step1()<br>    step3()<br>    third_party.step2()<br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;invoke3 ...&#x27;</span>)<br>third_party.<span class="hljs-built_in">run</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;============&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;invoke1 ...&#x27;</span>)<br>with mock.patch.object(third_party, <span class="hljs-string">&#x27;run&#x27;</span>, my_run):<br>    third_party.<span class="hljs-built_in">run</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;============&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;invoke2 ...&#x27;</span>)<br>third_party.<span class="hljs-built_in">run</span>()<br><br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs abnf">invoke3 ...<br>step1       <br><span class="hljs-attribute">step2</span>       <br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br>invoke1 ... <br>step1       <br>step3       <br><span class="hljs-attribute">step2</span>       <br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br>invoke2 ... <br>step1       <br>step2 <br></code></pre></td></tr></table></figure><h3 id="gevent和猴子补丁"><a href="#gevent和猴子补丁" class="headerlink" title="gevent和猴子补丁"></a>gevent和猴子补丁</h3><p>greenlet已经实现了协程，但是这个人工切换，是不是觉得太麻烦了，不要着急，python还有一个比greenlet更强大的并且能够自动切换任务的模块<code>gevent</code></p><p><code>gevent</code> 是 <code>Python</code> 的一个并发框架，基于 <code>greenlet</code> 实现，使用了 <code>epoll</code> 事件监听机制以及诸多其他优化而变得高效。其基本思想就是一个 <code>greenlet</code> 就是一个协程，当 <code>greenlet</code> 遇到 <code>IO</code> 操作时，比如访问网络，就会自动切换到其他的 <code>greenlet</code>，等待 <code>IO</code> 完成再切换回来继续执行。<code>gevent</code> 可以帮我们自动实现这个协程切换的过程。</p><p>由于IO操作非常耗时，经常使程序处于等待状态，有了gevent我们自动切换协程，就保证总有greenlet在运行，而不是等待IO</p><p><strong>猴子补丁，将程序中用到的耗时操作的代码，换为gevent中自己实现的模块，如time.sleep(0.1)，gevent中也有sleep()方法</strong></p><p>一种在运行时候动态修改类，函数的功能的属性编程技巧</p><ol><li><p>在运行时候替换方法，属性</p></li><li><p>在不修改第三方代码情况下，增加原来不支持对象</p></li><li><p>运行时为内存中对象增加PATCH，不是在源代码磁盘中增加</p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs css">import <span class="hljs-selector-tag">time</span><br>import gevent<br><span class="hljs-selector-tag">from</span> gevent import monkey<br><br># 有耗时操作时需要<br>monkey<span class="hljs-selector-class">.patch_all</span>()  # 打补丁，将程序中用到的耗时操作的代码，换为gevent中自己实现的模块<br><br><br>def <span class="hljs-selector-tag">a</span>():  # 任务A<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-built_in">str</span>(i))<br>        time.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">0.1</span>)<br><br><br>def <span class="hljs-built_in">b</span>():  # 任务B<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;B&#x27;</span> + <span class="hljs-built_in">str</span>(i))<br>        time.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">0.1</span>)<br><br><br>def <span class="hljs-built_in">c</span>():  # 任务C<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;C&#x27;</span> + <span class="hljs-built_in">str</span>(i))<br>        time.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">0.1</span>)<br><br><br>if __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    g1 = gevent.<span class="hljs-built_in">spawn</span>(a)<br>    g2 = gevent.<span class="hljs-built_in">spawn</span>(b)<br>    g3 = gevent.<span class="hljs-built_in">spawn</span>(c)<br><br>    g1.<span class="hljs-built_in">join</span>()<br>    g2.<span class="hljs-built_in">join</span>()<br>    g3.<span class="hljs-built_in">join</span>()<br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">A0</span><br><span class="hljs-keyword">B0</span><br><span class="hljs-keyword"></span>C0<br><span class="hljs-built_in">A1</span><br><span class="hljs-keyword">B1</span><br><span class="hljs-keyword"></span>C1<br><span class="hljs-built_in">A2</span><br><span class="hljs-keyword">B2</span><br><span class="hljs-keyword"></span>C2<br><span class="hljs-built_in">A3</span><br><span class="hljs-keyword">B3</span><br><span class="hljs-keyword"></span>C3<br><span class="hljs-built_in">A4</span><br><span class="hljs-keyword">B4</span><br><span class="hljs-keyword"></span>C4<br></code></pre></td></tr></table></figure><p>由于使用了 <code>monkey.patch_all</code> 对耗时操作进行了替换，<code>gevent</code> 能够在这三个协程之间自动切换执行，而不是按照顺序依次等待每个耗时操作完成。这样可以实现并发效果，提高程序的执行效率。</p><p>例如，可能的输出顺序不是严格按照 <code>A0</code>、<code>A1</code>、<code>A2</code> ….. <code>B0</code>、<code>B1</code> ….. <code>C0</code>、<code>C1</code> ….. ，而是 <code>A0</code>、<code>B0</code>、<code>C0</code>、<code>A1</code> 等交错进行，具体的输出顺序取决于 <code>gevent</code> 的调度。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs scss">import requests<br>import gevent<br>from gevent import monkey<br><br>monkey<span class="hljs-selector-class">.patch_all</span>()<br><br><br>def <span class="hljs-built_in">download</span>(url):<br>    response = requests.<span class="hljs-built_in">get</span>(url)  # 耗时操作<br>    content = response.text<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;下载了&#123;&#125;的数据，长度：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(url, <span class="hljs-built_in">len</span>(content)))<br><br><br>if __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    urls = [<span class="hljs-string">&#x27;http://www.163.com&#x27;</span>, <span class="hljs-string">&#x27;http://www.qq.com&#x27;</span>, <span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>]<br>    g1 = gevent.<span class="hljs-built_in">spawn</span>(download, urls[<span class="hljs-number">0</span>])<br>    g2 = gevent.<span class="hljs-built_in">spawn</span>(download, urls[<span class="hljs-number">1</span>])<br>    g3 = gevent.<span class="hljs-built_in">spawn</span>(download, urls[<span class="hljs-number">2</span>])<br><br>    g1.<span class="hljs-built_in">join</span>()<br>    g2.<span class="hljs-built_in">join</span>()<br>    g3.<span class="hljs-built_in">join</span>()<br>     <br>    # gevent.<span class="hljs-built_in">joinall</span>(g1, g2, g3)<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">下载了http:<span class="hljs-regexp">//</span>www.qq.com的数据，长度：<span class="hljs-number">2382</span><br>下载了http:<span class="hljs-regexp">//</span>www.<span class="hljs-number">163</span>.com的数据，长度：<span class="hljs-number">2388</span><br>下载了http:<span class="hljs-regexp">//</span>www.baidu.com的数据，长度：<span class="hljs-number">2381</span><br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs scss">import gevent,<span class="hljs-selector-tag">time</span><br><br>def <span class="hljs-built_in">f1</span>():<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;function:@@@f1 | NUM: @@@&#x27;</span>,i)<br><br>        # 此处阻塞，gevent会帮我们切换到其他协程去↓<br>        gevent.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">0</span>)<br><br>def <span class="hljs-built_in">f2</span>():<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;function:@@@f2 | NUM: @@@&#x27;</span>,i)<br><br>        # 此处阻塞，gevent会帮我们切换到其他协程去↑<br>        gevent.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">0</span>)<br><br># 创建两个协程对象，分别去执行两个函数<br>xc1=gevent.<span class="hljs-built_in">spawn</span>(f1)<br>xc2=gevent.<span class="hljs-built_in">spawn</span>(f2)<br><br># 将协程们交给gevent去执行<br>gevent.<span class="hljs-built_in">joinall</span>([xc1,xc2])<br></code></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gauss">function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f1 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">0</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f2 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">0</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f1 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">1</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f2 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">1</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f1 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">2</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f2 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">2</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f1 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">3</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f2 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">3</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f1 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">4</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f2 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>如上，当 <code>gevent</code> 帮我们执行两个协程的时候，首先 <code>xc1</code> 执行到 <code>gevent.sleep(0)</code>时发生阻塞，此时，<code>gevent</code> 帮我们将切换到 <code>xc2</code>，<code>xc2</code> 执行到 <code>gevent.sleep(0)</code>时又发生了阻塞，此时，<code>gevent</code> 又帮我们将切换到 <code>xc1</code> 去执行。</p><h3 id="gevent-无法捕获的耗时"><a href="#gevent-无法捕获的耗时" class="headerlink" title="gevent 无法捕获的耗时"></a>gevent 无法捕获的耗时</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs scss">import gevent,<span class="hljs-selector-tag">time</span><br><br>def <span class="hljs-built_in">f1</span>():<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;function:@@@f1 | NUM: @@@&#x27;</span>,i)<br><br>        # 注意这里<br>        time.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">0.1</span>)<br><br>def <span class="hljs-built_in">f2</span>():<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;function:@@@f2 | NUM: @@@&#x27;</span>,i)<br><br>        # 注意这里<br>        time.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">0.1</span>)<br><br># 创建两个协程对象，分别去执行两个函数<br>xc1=gevent.<span class="hljs-built_in">spawn</span>(f1)<br>xc2=gevent.<span class="hljs-built_in">spawn</span>(f2)<br><br># 将协程们交给gevent去执行<br>gevent.<span class="hljs-built_in">joinall</span>([xc1,xc2])<br></code></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gauss">function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f1 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">0</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f1 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">1</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f1 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">2</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f1 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">3</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f1 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">4</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f2 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">0</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f2 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">1</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f2 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">2</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f2 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">3</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f2 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>如上，你会发现，<code>time.sleep(0.1)</code>耗费的时间，<code>gevent</code> 无法捕捉，导致代码是串行的，虽然我们创建了协程，但是并没有起到异步的作用。</p><p>怎么办呢？猴子补丁。</p><p>对于无法捕获的耗时，<code>gevent</code> 为我们提供了猴子补丁，当我们为我们的程序打了猴子补丁，那么当我们的程序遇到任何耗时的操作，<code>gevent</code> 都会帮我们去自动切换协程，从而实现异步高并发。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gevent,time<br><span class="hljs-keyword">from</span> gevent <span class="hljs-keyword">import</span> monkey;<br><br>monkey.patch_all()<span class="hljs-comment">#这里很重要</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f1</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;function:@@@f1 | NUM: @@@&#x27;</span>,i)<br><br>        <span class="hljs-comment"># 注意这里</span><br>        time.sleep(<span class="hljs-number">0.1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f2</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;function:@@@f2 | NUM: @@@&#x27;</span>,i)<br><br>        <span class="hljs-comment"># 注意这里</span><br>        time.sleep(<span class="hljs-number">0.1</span>)<br><br><span class="hljs-comment"># 创建两个协程对象，分别去执行两个函数</span><br>xc1=gevent.spawn(f1)<br>xc2=gevent.spawn(f2)<br><br><span class="hljs-comment"># 将协程们交给gevent去执行</span><br>gevent.joinall([xc1,xc2])<br></code></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gauss">function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f1 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">0</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f2 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">0</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f1 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">1</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f2 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">1</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f1 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">2</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f2 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">2</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f1 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">3</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f2 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">3</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f1 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">4</span><br>function:<span class="hljs-comment">@@</span><span class="hljs-comment">@f2 | NUM: @</span><span class="hljs-comment">@@</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL深分页优化</title>
    <link href="/2024/01/19/MySQL%E6%B7%B1%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96/"/>
    <url>/2024/01/19/MySQL%E6%B7%B1%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="深分页介绍"><a href="#深分页介绍" class="headerlink" title="深分页介绍"></a>深分页介绍</h2><p>查询<strong>偏移量过大</strong>的场景我们称为深度分页，这会导致查询性能较低</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># MySQL 在无法利用索引的情况下跳过1000000条记录后，再获取10条记录<br>SELECT * FROM t_order ORDER BY id LIMIT 1000000, 10<br></code></pre></td></tr></table></figure><h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><p>当可以保证<strong>ID的连续性</strong>时，根据ID范围进行分页是比较好的解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查询指定 ID 范围的数据<br>SELECT * FROM t_order WHERE id &gt; 100000 AND id &lt;= 100010 ORDER BY id<br># 也可以通过记录上次查询结果的最后一条记录的ID进行下一页的查询：<br>SELECT * FROM t_order WHERE id &gt; 100000 LIMIT 10<br></code></pre></td></tr></table></figure><p>这种优化限制比较大，且一般项目的ID也没办法保证完全连续。</p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>我们先查询出limit第一个参数对应的主键值，再根据这个主键值再去过滤并limit，这样效率会更快一些</p><p>阿里巴巴《Java 开发手册》中也有对应的描述：</p><p>利用延迟关联或者子查询优化超多分页场景。</p><p><img src="/../MySQL%E6%B7%B1%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96/1.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 通过子查询来获取 id 的起始值，把 limit 1000000 的条件转移到子查询<br>SELECT * FROM t_order WHERE id &gt;= (SELECT id FROM t_order limit 1000000, 1) LIMIT 10;<br></code></pre></td></tr></table></figure><p>不过，子查询的结果会产生一张新表，会影响性能，应该尽量避免大量使用子查询。并且这种方法<strong>只适用于ID是正序的</strong>。在复杂分页场景，往往需要通过过滤条件，筛选到符合条件的ID，此时的ID是离散且不连续的。</p><h2 id="inner-join延迟关联"><a href="#inner-join延迟关联" class="headerlink" title="inner join延迟关联"></a>inner join延迟关联</h2><p>延迟关联的优化思路，跟子查询的优化思路其实是一样的：都是把条件转移到主键索引树，然后减少回表。不同点是，延迟关联使用了 INNER JOIN 代替子查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT t1.* FROM t_order t1<br>INNER JOIN (SELECT id FROM t_order limit 1000000, 1) t2<br>ON t1.id &gt;= t2.id<br>LIMIT 10;<br></code></pre></td></tr></table></figure><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>索引中已经包含了所有需要获取的字段的查询方式称为覆盖索引。</p><p><strong>覆盖索引的好处：</strong></p><ul><li><p><strong>避免 InnoDB 表进行索引的二次查询，也就是回表操作:</strong> InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</p></li><li><p><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</p></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># 如果只需要查询 id, code, <span class="hljs-keyword">type</span> 这三列，可建立 code 和 <span class="hljs-keyword">type</span> 的覆盖索引<br><span class="hljs-keyword">SELECT</span> id, code, <span class="hljs-keyword">type</span> <span class="hljs-keyword">FROM</span> t_order<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> code<br><span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1000000</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>不过，当查询的结果集占表的总行数的很大一部分时，可能就不会走索引了，自动转换为全表扫描。当然了，也可以通过 <code>FORCE INDEX</code> 来强制查询优化器走索引，但这种提升效果一般不明显。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><img src="/../MySQL%E6%B7%B1%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96/2.png"></p><p>MySQL 深分页优化 - 得物技术：</p><p><a href="https://juejin.cn/post/6985478936683610149">https://juejin.cn/post/6985478936683610149</a></p><p>数据库深分页介绍及优化方案 - 京东零售技术：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUyMDAxMjQ3Ng==&mid=2247502730&idx=1&sn=dbefc3ecbad76c360f7a58269d44ad31&scene=21#wechat_redirect">https://mp.weixin.qq.com/s/ZEwGKvRCyvAgGlmeseAS7g</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL一条行记录的存储细节</title>
    <link href="/2024/01/18/MySQL%E4%B8%80%E6%9D%A1%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8/"/>
    <url>/2024/01/18/MySQL%E4%B8%80%E6%9D%A1%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<p>知道MySQL一条行记录的存储细节后还能解锁以下问题</p><ul><li>MySQL 的 NULL 值会占用空间吗？</li><li>MySQL 怎么知道 varchar(n) 实际占用数据的大小？</li><li>MySQL 怎么知道 varchar(n) 实际占用数据的大小？</li></ul><h2 id="MySQL-的数据存放在哪个文件？"><a href="#MySQL-的数据存放在哪个文件？" class="headerlink" title="MySQL 的数据存放在哪个文件？"></a>MySQL 的数据存放在哪个文件？</h2><p>MySQL的存储行为是由存储引擎实现的，不同的存储引擎保存的文件自然也不同，这里就以默认的InnoDB存储引擎为例</p><p>先来看看 MySQL 数据库的文件存放在哪个目录？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW VARIABLES LIKE &#x27;datadir&#x27;;<br>+---------------+-----------------+<br>| Variable_name | Value           |<br>+---------------+-----------------+<br>| datadir       | /var/lib/mysql/ |<br>+---------------+-----------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>我们每创建一个 database（数据库） 都会在 <strong>&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;</strong> 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。</p><p>比如，我这里有一个名为 my_test 的 database，该 database 里有一张名为 t_order 数据库表。</p><p><img src="/../MySQL%E4%B8%80%E6%9D%A1%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%86%E8%8A%82/1.png"></p><p>然后，我们进入 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;my_test 目录，看看里面有什么文件？</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[root@xiaolin ~]#ls <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/mysql/my</span>_test<br>db.opt  <br>t_order.frm  <br>t_order.ibd<br></code></pre></td></tr></table></figure><ul><li>db.opt,用来存储当前数据库的默认字符集和字符校验规则</li><li>t_order.frm, t_order 的<strong>表结构</strong>会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</li><li>t_order.ibd，t_order 的<strong>表数据</strong>会保存在这个文件。</li></ul><h2 id="InnoDB行格式有哪些？"><a href="#InnoDB行格式有哪些？" class="headerlink" title="InnoDB行格式有哪些？"></a>InnoDB行格式有哪些？</h2><p>行格式（row_format），就是一条记录的存储结构。</p><p>InnoDB 提供了 4 种行格式，分别是 Redundant、<strong>Compact</strong>、Dynamic和 Compressed 行格式。</p><p>Redundant 行格式我这里就不讲了，因为现在基本没人用了，这次<strong>重点介绍 Compact</strong> 行格式，因为 Dynamic 和 Compressed 这两个行格式跟 Compact 非常像。</p><h2 id="COMPACT-行格式长什么样？"><a href="#COMPACT-行格式长什么样？" class="headerlink" title="COMPACT 行格式长什么样？"></a>COMPACT 行格式长什么样？</h2><p><img src="/../MySQL%E4%B8%80%E6%9D%A1%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%86%E8%8A%82/2.png"></p><p>可以看到，一条完整的记录分为「<strong>记录的额外信息</strong>」和「<strong>记录的真实数据</strong>」两个部分。</p><h3 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h3><ul><li>变长字段长度列表</li></ul><p>varchar是变长的，变长字段实际存储的数据的长度(大小)不固定的。</p><p>所以，在存储数据的时候，也要把数据占用的大小存起来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据。其他 TEXT、BLOB 等变长字段也是这么实现的。</p><p>为了展示「变长字段长度列表」具体是怎么保存「变长字段的真实数据占用的字节数」，我们先创建这样一张表，字符集是 ascii（所以每一个字符占用的 1 字节），行格式是 Compact，t_user 表中 name 和 phone 字段都是变长字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t_user` (<br>  `id` int(11) NOT NULL,<br>  `name` VARCHAR(20) DEFAULT NULL,<br>  `phone` VARCHAR(20) DEFAULT NULL,<br>  `age` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`) USING BTREE<br>) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT;<br></code></pre></td></tr></table></figure><p>现在 t_user 表里有这三条记录：</p><p><img src="/../MySQL%E4%B8%80%E6%9D%A1%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%86%E8%8A%82/3.png"></p><p>先来看第一条记录：</p><ul><li>name 列的值为 a，真实数据占用的字节数是 1 字节，十六进制 0x01；</li><li>phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03；</li><li>age 列和 id 列不是变长字段，所以这里不用管。</li></ul><p>这些变长字段的真实数据占用的字节数会按照列的顺序<strong>逆序存放</strong>，</p><p>所以「变长字段长度列表」里的内容是「 03 01」，而不是 「01 03」。</p><p><img src="/../MySQL%E4%B8%80%E6%9D%A1%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%86%E8%8A%82/4.png"></p><p>同样的道理，我们也可以得出<strong>第二条记录</strong>的行格式中，「变长字段长度列表」里的内容是「 04 02」，如下图：</p><p><img src="/../MySQL%E4%B8%80%E6%9D%A1%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%86%E8%8A%82/5.png"></p><p><strong>第三条记录</strong>中 phone 列的值是 NULL，<strong>NULL 是不会存放在行格式中记录的真实数据部分里的</strong>，所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度。</p><p><img src="/../MySQL%E4%B8%80%E6%9D%A1%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%86%E8%8A%82/6.png"></p><h3 id="NULL值列表"><a href="#NULL值列表" class="headerlink" title="NULL值列表"></a>NULL值列表</h3><p>表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列<strong>存储到 NULL值列表</strong>中。</p><p>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。</p><ul><li>二进制位的值为<code>1</code>时，代表该列的值为NULL。</li><li>二进制位的值为<code>0</code>时，代表该列的值不为NULL。</li></ul><p>另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 <code>0</code>。</p><p>还是以 t_user 表的这三条记录作为例子：</p><p><img src="/../MySQL%E4%B8%80%E6%9D%A1%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%86%E8%8A%82/7.png"></p><p>先来看<strong>第一条记录</strong>，第一条记录所有列都有值，不存在 NULL 值，所以用二进制来表示是酱紫的：</p><p><img src="/../MySQL%E4%B8%80%E6%9D%A1%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%86%E8%8A%82/8.png"></p><p>所以，对于第一条数据，NULL 值列表用十六进制表示是 0x00。</p><p>下来看<strong>第二条记录</strong>，第二条记录 age 列是 NULL 值，所以，对于第二条数据，NULL值列表用十六进制表示是 0x04。</p><p><img src="/../MySQL%E4%B8%80%E6%9D%A1%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%86%E8%8A%82/9.png"></p><p>最后<strong>第三条记录</strong>，第三条记录 phone 列 和 age 列是 NULL 值，所以，对于第三条数据，NULL 值列表用十六进制表示是 0x06。</p><p><img src="/../MySQL%E4%B8%80%E6%9D%A1%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%86%E8%8A%82/10.png"></p><p>我们把三条记录的 NULL 值列表都填充完毕后，它们的行格式是这样的：</p><p><img src="/../MySQL%E4%B8%80%E6%9D%A1%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%86%E8%8A%82/11.png"></p><p>每个数据库表的行格式都有「NULL 值列表」吗？</p><p>NULL 值列表也不是必须的。</p><p><strong>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了</strong>。</p><h3 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h3><p>记录头信息中包含的内容很多，我就不一一列举了，这里说几个比较重要的：</p><p><img src="/../MySQL%E4%B8%80%E6%9D%A1%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%86%E8%8A%82/12.png"></p><ul><li>delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</li><li>next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li><li>record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li></ul><h2 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h2><ul><li>row_id</li></ul><p>如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。</p><ul><li>trx_id</li></ul><p>事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。</p><ul><li>roll_pointer</li></ul><p>这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。</p><h2 id="varchar-n-中-n-最大取值为多少？"><a href="#varchar-n-中-n-最大取值为多少？" class="headerlink" title="varchar(n) 中 n 最大取值为多少？"></a>varchar(n) 中 n 最大取值为多少？</h2><p>我们要清楚一点，<strong>MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节</strong>。</p><p>也就是说，一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 <strong>字节</strong>，注意是一行的总长度，不是一列。</p><p>知道了这个前提之后，我们再来看看这个问题：「varchar(n) 中 n 最大取值为多少？」</p><p><strong>varchar(n) 字段类型的 n 代表的是最多存储的字符数量，并不是字节大小哦。</strong></p><p>要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节，比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。</p><h3 id="单字段情况"><a href="#单字段情况" class="headerlink" title="单字段情况"></a>单字段情况</h3><p>前面我们知道了，一行记录最大只能存储 65535 字节的数据。</p><p>那假设数据库表只有一个 varchar(n) 类型的列且字符集是 ascii，在这种情况下， varchar(n) 中 n 最大取值是 65535 吗？</p><p>不着急说结论，我们先来做个实验验证一下。</p><p>我们定义一个 varchar(65535) 类型的字段，字符集为 ascii 的数据库表。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> test ( <br>`<span class="hljs-type">name</span>` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">65535</span>)  <span class="hljs-keyword">NULL</span><br>) ENGINE = InnoDB <span class="hljs-keyword">DEFAULT</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> = ascii ROW_FORMAT = COMPACT;<br></code></pre></td></tr></table></figure><p>看能不能成功创建一张表：</p><p><img src="/../MySQL%E4%B8%80%E6%9D%A1%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%86%E8%8A%82/13.png"></p><p>创建失败了</p><p>从报错信息就可以知道<strong>一行数据的最大字节数是 65535（不包含 TEXT、BLOBs 这种大对象类型），其中包含了 storage overhead</strong>。</p><p>问题来了，这个 storage overhead 是什么呢？其实就是「变长字段长度列表」和 「NULL 值列表」，也就是说<strong>一行数据的最大字节数 65535，其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数的</strong>。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去 storage overhead 占用的字节数。</p><p>所以，<strong>在数据库表只有一个 varchar(n) 字段且字符集是 ascii 的情况下，varchar(n) 中 n 最大值 &#x3D; 65535 - 2 - 1 &#x3D; 65532</strong>。</p><p>在 UTF-8 字符集下，一个字符最多需要三个字节，varchar(n) 的 n 最大取值就是 65532&#x2F;3 &#x3D; 21844。</p><p>上面所说的只是针对于一个字段的计算方式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>MySQL 的 NULL 值是怎么存放的？</li></ul><p>MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，<strong>NULL 值并不会存储在行格式中的真实数据部分</strong>。</p><p>NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。</p><ul><li>MySQL 怎么知道 varchar(n) 实际占用数据的大小？</li></ul><p>MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。</p><p><img src="/../MySQL%E4%B8%80%E6%9D%A1%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%86%E8%8A%82/5.png"></p><ul><li>varchar(n) 中 n 最大取值为多少？</li></ul><p>一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。</p><p>如果一张表只有一个 varchar(n) 字段，且允许为 NULL，字符集为 ascii。varchar(n) 中 n 最大取值为 65532。</p><p>计算公式：65535 - 变长字段字节数列表所占用的字节数 - NULL值列表所占用的字节数 &#x3D; 65535 - 2 - 1 &#x3D; 65532。</p><p>如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;&#x3D; 65535。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper</title>
    <link href="/2024/01/02/Zookeeper/"/>
    <url>/2024/01/02/Zookeeper/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Zookeeper介绍"><a href="#一、Zookeeper介绍" class="headerlink" title="一、Zookeeper介绍"></a>一、Zookeeper介绍</h2><h3 id="1、什么是Zookeeper"><a href="#1、什么是Zookeeper" class="headerlink" title="1、什么是Zookeeper"></a>1、什么是Zookeeper</h3><p>​Zookeeper 是一种分布式协调服务，用于管理大型主机。在分布式环境中协调和管理服务是一个复杂的过程，ZooKeeper通过其简单的架构和API解决了这个问题。ZooKeeper 能让开发人员专注于核心应用程序逻辑，而不必担心应用程序的分布式特性。</p><h3 id="2、Zookeeper的应用场景"><a href="#2、Zookeeper的应用场景" class="headerlink" title="2、Zookeeper的应用场景"></a>2、Zookeeper的应用场景</h3><ul><li>分布式协调组件</li></ul><p><img src="/../Zookeeper/1.png"></p><p>在分布式系统中，需要有zookeeper作为分布式协调组件，协调分布式系统中的状态</p><ul><li>分布式锁</li></ul><p>zk在实现分布式锁上，可以做到强一致性，关于分布式锁的相关知识，会在之后的ZAB协议中介绍</p><ul><li>无状态化的实现</li></ul><p><img src="/../Zookeeper/2.png"></p><h2 id="二、搭建ZooKeeper服务器"><a href="#二、搭建ZooKeeper服务器" class="headerlink" title="二、搭建ZooKeeper服务器"></a>二、搭建ZooKeeper服务器</h2><h3 id="1、zoo-conf配置文件说明"><a href="#1、zoo-conf配置文件说明" class="headerlink" title="1、zoo.conf配置文件说明"></a>1、zoo.conf配置文件说明</h3><p><img src="/../Zookeeper/3.png"></p><h3 id="2、Zookeeper服务器的操作命令"><a href="#2、Zookeeper服务器的操作命令" class="headerlink" title="2、Zookeeper服务器的操作命令"></a>2、Zookeeper服务器的操作命令</h3><p>重命名conf中的文件zoo_sample.cfg-&gt;zoo.cfg</p><p>重启zk服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mark">./bin/zkServer.sh start ../conf/zoo.cfg<br></code></pre></td></tr></table></figure><p>查看zk服务器的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mark">./bin/zkServer.sh status ../conf/zoo.cfg<br></code></pre></td></tr></table></figure><p>停止服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mark">./bin/zkServer.sh stop ../conf/zoo.cfgs<br></code></pre></td></tr></table></figure><h2 id="三、Zookeeper内部的数据模型"><a href="#三、Zookeeper内部的数据模型" class="headerlink" title="三、Zookeeper内部的数据模型"></a>三、Zookeeper内部的数据模型</h2><h3 id="1、zk是如何保存数据的"><a href="#1、zk是如何保存数据的" class="headerlink" title="1、zk是如何保存数据的"></a>1、zk是如何保存数据的</h3><p>zk中的数据是保存在节点上的，节点就是znode，多个znode之间构成一棵树的目录结构。</p><p>Zookeeper的数据模型是什么样子呢？类似于数据结构中的树，同时也很像文件系统的目录</p><p><img src="/../Zookeeper/4.png"></p><p>树是由节点所组成，Zookeeper的数据存储也同样是基于节点，这种节点叫做<strong>Znode</strong>，但是不同于树的节点，Znode的引用方式是路劲引用，类似于文件路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mark">/动物/猫<br>/汽车/宝马<br></code></pre></td></tr></table></figure><p>这样的层级结构，让每一个Znode的节点拥有唯一的路径，就像命名空间一样对不同信息做出清晰的隔离。</p><h3 id="2、zk中的znode是什么样的数据结构"><a href="#2、zk中的znode是什么样的数据结构" class="headerlink" title="2、zk中的znode是什么样的数据结构"></a>2、zk中的znode是什么样的数据结构</h3><p>zk中的znode包含了四个部分</p><p> data：保存数据</p><p> acl：权限：</p><p>​c：create 创建权限，允许在该节点下创建子节点</p><p>​w：write 更新权限，允许更新该节点的数据</p><p>​r：read 读取权限，允许读取该节点的内容以及子节点的列表信息</p><p>​d：delete 删除权限，允许删除该节点的子节点信息</p><p>​a：admin 管理者权限，允许对该节点进行acl权限设置</p><p>  stat：描述当前znode的元数据</p><p>  child：当前节点的子节点</p><h3 id="3、zk中节点znode的类型"><a href="#3、zk中节点znode的类型" class="headerlink" title="3、zk中节点znode的类型"></a>3、zk中节点znode的类型</h3><p>1、持久节点：创建出的节点，在会话结束后依然存在。保存数据</p><p>2、持久序号节点：创建出的节点，根据先后顺序，会在节点之后带上一个数值，越后执行数值越大，适用于分布式锁的应用场景-单调递增</p><p>3、临时节点：临时节点是在会话结束后，自动被删除的，通过这个特性，zk可以实现服务注册与发现的效果。</p><p><img src="/../Zookeeper/5.png"></p><p>临时序号节点：跟持久序号节点相同，适用于临时的分布式锁</p><p>Container节点（3.5.3版本新增）：Container容器节点，当容器中没有任何子节点，该容器节点会被zk定期删除</p><p>TTL节点：可以指定节点的到期时间，到期后被zk定时删除。只能通过系统配置zookeeper.extendedTypeEnablee&#x3D;true开启</p><h3 id="4、zk的数据持久化"><a href="#4、zk的数据持久化" class="headerlink" title="4、zk的数据持久化"></a>4、zk的数据持久化</h3><p>zk的数据是运行在内存中，zk提供了两种持久化机制：</p><p>​事务日志</p><p>​zk把执行的命令以日志形式保存在dataLogDir指定的路径中的文件中（如果没有指定dataLogDir，则按照 dataDir指定的路径）。</p><p>​数据快照</p><p>​zk会在一定的时间间隔内做一次内存数据快照，把时刻的内存数据保存在快照文件中。</p><p>zk通过两种形式的持久化，在恢复时先恢复快照文件中的数据到内存中，再用日志文件中的数据做增量恢复，这样恢复的速度更快。</p><h2 id="四、Zookeeper客户端（zkCli）的使用"><a href="#四、Zookeeper客户端（zkCli）的使用" class="headerlink" title="四、Zookeeper客户端（zkCli）的使用"></a>四、Zookeeper客户端（zkCli）的使用</h2><h3 id="1、多节点类型创建"><a href="#1、多节点类型创建" class="headerlink" title="1、多节点类型创建"></a>1、多节点类型创建</h3><ul><li><p>创建持久节点</p><p>create path [data] [acl]</p></li><li><p>创建持久序号节点</p><p>create -s path [data] [acl]</p></li><li><p>创建临时节点</p><p>create -e path [data] [acl]</p></li><li><p>创建临时序号节点</p><p>create -e -s path [data] [acl]</p></li><li><p>创建容器节点</p><p>create -c path [data] [acl]</p></li></ul><h3 id="2、查询节点"><a href="#2、查询节点" class="headerlink" title="2、查询节点"></a>2、查询节点</h3><ul><li><p>普通查询</p><ul><li><p>ls [-s -R] path</p><p>-s 详细信息</p><p>-R 当前目录和子目录中的所有信息</p></li></ul></li><li><p>查询节点相关信息</p><ul><li>cZxid：创建节点的事务ID</li><li>mZxid：修改节点的事务ID</li><li>pZxid：添加和删除子节点的事务ID</li><li>ctime：节点创建的时间</li><li>mtime：节点最近修改的时间</li><li>dataVersion：节点内数据的版本，每更新一次数据，版本会+1</li><li>aclVersion：此节点的权限版本</li><li>ephemeralOwner：如果当前节点是临时节点，该是是当前节点所有者的session id。如果节点不是临时节点，则该值为零</li><li>dataLength：节点内数据的长度</li><li>numChildren：该节点的子节点个数</li></ul></li><li><p>查询节点的内容</p><ul><li><p>get [-s] path</p><p>-s 详细信息</p></li></ul></li></ul><h3 id="3、删除节点"><a href="#3、删除节点" class="headerlink" title="3、删除节点"></a>3、删除节点</h3><ul><li><p>普通删除</p></li><li><p>乐观锁删除</p><ul><li><p>delete [-v] path</p><p>-v 版本</p></li><li><p>deleteall path [-b batch size]</p></li></ul></li></ul><h3 id="3、权限设置"><a href="#3、权限设置" class="headerlink" title="3、权限设置"></a>3、权限设置</h3><ul><li><p>注册当前会话的账号和密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mark">addauth digest xiaowang:123456<br></code></pre></td></tr></table></figure></li><li><p>创建节点并设置权限（指定该节点的用户，以及用户所拥有的权限s）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mark">create /test-node abcd auth:xiaowang:123456:cdwra<br></code></pre></td></tr></table></figure></li><li><p>在另一个会话中必须先使用账号密码，才能拥有操作节点的权限</p></li></ul><h2 id="五、Curator客户端的使用"><a href="#五、Curator客户端的使用" class="headerlink" title="五、Curator客户端的使用"></a>五、Curator客户端的使用</h2><h3 id="1、Curator介绍"><a href="#1、Curator介绍" class="headerlink" title="1、Curator介绍"></a>1、Curator介绍</h3><p>Curator是Netflix公司开源的一套zookeeper客户端框架，Curator是对Zookeeper支持最好的客户端框架。Curator封装了大部分Zookeeper的功能，比如Leader选举、分布式锁等，减少了技术人员在使用Zookeeper时的底层细节开发工作。</p><h3 id="2、引入依赖"><a href="#2、引入依赖" class="headerlink" title="2、引入依赖"></a>2、引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Curator--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--Zookeeper--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>配置curator基本连接信息<br>curator.retryCount=5<br>curator.elapsedTimeMs=5000<br>curator.connectionString=192.168.200.128:2181<br>curator.sessionTimeoutMs=60000<br>curator.connectionTimeoutMs=4000<br><br></code></pre></td></tr></table></figure><h3 id="3、编写配置curator配置类"><a href="#3、编写配置curator配置类" class="headerlink" title="3、编写配置curator配置类"></a>3、编写配置curator配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;curator&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WrapperZK</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> retryCount;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> elapsedTimeMs;<br><br>  <span class="hljs-keyword">private</span> String connectionString;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sessionTimeoutMs;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> connectionTimeoutMs;<br>&#125;<br><br><span class="hljs-comment">//引用配置类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CuratorConfig</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> WrapperZK wrapperZK;<br><br>    <span class="hljs-meta">@Bean(initMethod = &quot;start&quot;)</span><br>    <span class="hljs-keyword">public</span> CuratorFramework <span class="hljs-title function_">curatorFramework</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> CuratorFrameworkFactory.newClient(<br>            wrapperZK.getConnectionString(),<br>            wrapperZK.getSessionTimeoutMs(),<br>            wrapperZK.getConnectionTimeoutMs(),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">RetryNTimes</span>(wrapperZK.getRetryCount(), wrapperZK.getElapsedTimeMs())<br>        );<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、测试"><a href="#4、测试" class="headerlink" title="4、测试"></a>4、测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> CuratorFramework curatorFramework;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-comment">//添加节点</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createNode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-comment">//添加默认(持久)节点</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> curatorFramework.create().forPath(<span class="hljs-string">&quot;/curator-node&quot;</span>);<br>    <span class="hljs-comment">//添加临时序号节点</span><br>    <span class="hljs-comment">//String path2 = curatorFramework.create().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(&quot;/curator-nodes&quot;, &quot;messageDate&quot;.getBytes());</span><br>    System.out.println(String.format(<span class="hljs-string">&quot;curator create node :%s  successfully!&quot;</span>, path));<br>    <span class="hljs-comment">//System.in.read();</span><br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-comment">//获取节点值</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">getDate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">byte</span>[] bttes = curatorFramework.getData().forPath(<span class="hljs-string">&quot;/curator-node&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;bttes = &quot;</span> + bttes);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-comment">//设置节点值</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setDate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    curatorFramework.setData().forPath(<span class="hljs-string">&quot;/curator-node&quot;</span>, <span class="hljs-string">&quot;newMessage&quot;</span>.getBytes());<br>    <span class="hljs-type">byte</span>[] bytes = curatorFramework.getData().forPath(<span class="hljs-string">&quot;/curator-node&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;bytes = &quot;</span> + bytes);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-comment">//创建多级节点</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createWithParent</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">pathWithParent</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/node-parent/sub-node-1&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> curatorFramework.create().creatingParentContainersIfNeeded().forPath(pathWithParent);<br>    System.out.println(String.format(<span class="hljs-string">&quot;curator create node :%s success!&quot;</span>, path));<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-comment">//删除节点</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/node-parent&quot;</span>;<br>    <span class="hljs-comment">//删除节点的同时一并删除子节点</span><br>    curatorFramework.delete().guaranteed().deletingChildrenIfNeeded().forPath(path);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六、zk实现分布式锁"><a href="#六、zk实现分布式锁" class="headerlink" title="六、zk实现分布式锁"></a>六、zk实现分布式锁</h2><h3 id="1、zk中锁的种类："><a href="#1、zk中锁的种类：" class="headerlink" title="1、zk中锁的种类："></a>1、zk中锁的种类：</h3><ul><li>读锁（读锁共享）：大家都可以读。上锁前提：之前的锁没有写锁</li><li>写锁（写锁排他）：只有得到写锁的才能写。上锁前提：之前没有任何锁</li></ul><h3 id="2、zk如何上读锁"><a href="#2、zk如何上读锁" class="headerlink" title="2、zk如何上读锁"></a>2、zk如何上读锁</h3><ul><li><p>创建一个临时序号节点，节点的数据是read，表示是读锁</p></li><li><p>获取当前zk中序号比自己小的所有节点</p></li><li><p>判断最小节点是否是读锁</p><ul><li>如果不是读锁的话，则上锁失败，为最小节点设置监听。阻塞等待，zk的watch机制会当最小节点发生变化时通知当前节点，再执行第二步的流程</li><li>如果是读锁的话，则上锁成功。</li></ul></li></ul><p><img src="/../Zookeeper/6.png"></p><h3 id="3、zk如何上写锁"><a href="#3、zk如何上写锁" class="headerlink" title="3、zk如何上写锁"></a>3、zk如何上写锁</h3><ul><li>创建一个临时序号节点，节点的数据是write，表示写锁</li><li>获取zk中所有的子节点</li><li>判断自己是否是最小的节点：<ul><li>如果是，则上写锁成功</li><li>如果不是，说明前面还有锁，则上锁失败，监听最小节点，如果最小节点有变化，则再执行第二步。</li></ul></li></ul><p><img src="/../Zookeeper/7.png"></p><h3 id="4、羊群效应"><a href="#4、羊群效应" class="headerlink" title="4、羊群效应"></a>4、羊群效应</h3><p>如果用上述的上锁方式，只要有节点发生变化，就会触发其他节点的监听事件，这样对zk的压力非常大，而羊群效应，可以调整成链式监听。解决这个问题。</p><p><img src="/../Zookeeper/8.png"></p><h3 id="5、Curator实现读写锁"><a href="#5、Curator实现读写锁" class="headerlink" title="5、Curator实现读写锁"></a>5、Curator实现读写锁</h3><ul><li>获取读锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetReadLock</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-comment">//读写锁</span><br>    <span class="hljs-type">InterProcessReadWriteLock</span> <span class="hljs-variable">interProcessReadWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessReadWriteLock</span>(client, <span class="hljs-string">&quot;/lock1&quot;</span>);<br>    <span class="hljs-comment">//获取读锁对象</span><br>    <span class="hljs-type">InterProcessLock</span> <span class="hljs-variable">interProcessLock</span> <span class="hljs-operator">=</span> interProcessReadWriteLock.readLock();<br>    System.out.println(<span class="hljs-string">&quot;等待获取读锁对象中...&quot;</span>);<br>    <span class="hljs-comment">//获取锁</span><br>    interProcessLock.acquire();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i ++)&#123;<br>        Thread.sleep(<span class="hljs-number">3000</span>);<br>        System.out.println(i);<br>    &#125;<br>    <span class="hljs-comment">//释放锁</span><br>    interProcessLock.release();<br>    System.out.println(<span class="hljs-string">&quot;等待释放锁...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>获取写锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetWriteLock</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-comment">//读写锁</span><br>    <span class="hljs-type">InterProcessReadWriteLock</span> <span class="hljs-variable">interProcessReadWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessReadWriteLock</span>(client, <span class="hljs-string">&quot;/lock1&quot;</span>);<br>    <span class="hljs-comment">//获取写锁对象</span><br>    <span class="hljs-type">InterProcessLock</span> <span class="hljs-variable">interProcessLock</span> <span class="hljs-operator">=</span> interProcessReadWriteLock.writeLock();<br>    System.out.println(<span class="hljs-string">&quot;等待获取写锁对象中...&quot;</span>);<br>    <span class="hljs-comment">//获取锁</span><br>    interProcessLock.acquire();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i ++)&#123;<br>        Thread.sleep(<span class="hljs-number">3000</span>);<br>        System.out.println(i);<br>    &#125;<br>    <span class="hljs-comment">//释放锁</span><br>    interProcessLock.release();<br>    System.out.println(<span class="hljs-string">&quot;等待释放锁...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="七、zk的watch机制"><a href="#七、zk的watch机制" class="headerlink" title="七、zk的watch机制"></a>七、zk的watch机制</h2><h3 id="1、Watch机制介绍"><a href="#1、Watch机制介绍" class="headerlink" title="1、Watch机制介绍"></a>1、Watch机制介绍</h3><p>我们可以把Watch理解成是注册在特定Znode上的触发器。当这个Znode发生改变，也就是调用了create，delete，setData方法的时候，将会触发Znode上注册的对应事件，请求Watch的客户端会收到异步通知。</p><p>具体交互过程如下：</p><ul><li>客户端调用getData方法，watch参数是true。服务端接到请求，返回节点数据，并且在对应的哈希表里插入被Watch的Znode路径，以及Watcher列表。</li></ul><p><img src="/../Zookeeper/9.png"></p><ul><li>当被Watch的Znode已删除，服务端会查找哈希表，找到该Znode对应的所有Watcher，异步通知客户端，并且删除哈希表中对应的key-value。</li></ul><h3 id="2、zkCli客户端使用Watch"><a href="#2、zkCli客户端使用Watch" class="headerlink" title="2、zkCli客户端使用Watch"></a>2、zkCli客户端使用Watch</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">create /test date<br>get -w /test一次性监听节点<br>ls -w /test监听目录，创建和删除子节点会收到通知。但是子节点中新增节点不会被监听到<br>ls -R -w /test监听子节点中节点的变化，但内容的变化不会收到通知<br></code></pre></td></tr></table></figure><h3 id="3、Curator客户端使用Watch"><a href="#3、Curator客户端使用Watch" class="headerlink" title="3、Curator客户端使用Watch"></a>3、Curator客户端使用Watch</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNodeListener</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-type">NodeCache</span> <span class="hljs-variable">nodeCache</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NodeCache</span>(curatorFramework,<span class="hljs-string">&quot;/curator-node&quot;</span>);<br>    nodeCache.getListenable().addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NodeCacheListener</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nodeChanged</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>            log.info(<span class="hljs-string">&quot;&#123;&#125; path nodeChanged: &quot;</span>, <span class="hljs-string">&quot;/curator-node&quot;</span>);<br>            printNodeData();<br>        &#125;<br>    )&#125;;<br>    nodeCache.start();<br>    <span class="hljs-comment">//System.in.read();</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNodeData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-type">byte</span>[] bytes = curatorFramework.getData().forPath(<span class="hljs-string">&quot;/curator-node&quot;</span>);<br>    log.info(<span class="hljs-string">&quot;data: &#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="八、Zookeeper集群实战"><a href="#八、Zookeeper集群实战" class="headerlink" title="八、Zookeeper集群实战"></a>八、Zookeeper集群实战</h2><h3 id="1、Zookeeper集群角色"><a href="#1、Zookeeper集群角色" class="headerlink" title="1、Zookeeper集群角色"></a>1、Zookeeper集群角色</h3><p>zookeeper集群中的节点有三种角色</p><ul><li>Leader：处理集群的所有事务请求，集群中只有一个Leader</li><li>Follwoer：只能处理读请求，参与Leader选举</li><li>Observer：只能处理读请求，提升集群读的性能，但不能参与Leader选举</li></ul><p><img src="/../Zookeeper/10.png"></p><h3 id="2、集群搭建"><a href="#2、集群搭建" class="headerlink" title="2、集群搭建"></a>2、集群搭建</h3><p>搭建4个节点，其中一个节点为Observer</p><ul><li><p>创建4个节点的myid并设值</p><p>在usr&#x2F;local&#x2F;zookeeper中创建一下四个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">/usr/local/zookeeper/zkdata/zk1# </span><span class="language-bash"><span class="hljs-built_in">echo</span> 1 &gt; myid</span><br><span class="hljs-meta prompt_">/usr/local/zookeeper/zkdata/zk2# </span><span class="language-bash"><span class="hljs-built_in">echo</span> 2 &gt; myid</span><br><span class="hljs-meta prompt_">/usr/local/zookeeper/zkdata/zk3# </span><span class="language-bash"><span class="hljs-built_in">echo</span> 3 &gt; myid</span><br><span class="hljs-meta prompt_">/usr/local/zookeeper/zkdata/zk4# </span><span class="language-bash"><span class="hljs-built_in">echo</span> 4 &gt; myid</span><br></code></pre></td></tr></table></figure></li><li><p>编写4个zoo.cfg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">The number of milliseconds of each tick</span><br>tickTime=2000<br><span class="hljs-meta prompt_"># </span><span class="language-bash">The number of ticks that the initial</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">synchronization phase can take</span><br>initLimit=10<br><span class="hljs-meta prompt_"># </span><span class="language-bash">The number of ticks that can pass between</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">sending a request and getting an acknowledgement</span><br>syncLimit=5<br><span class="hljs-meta prompt_"># </span><span class="language-bash">the directory <span class="hljs-built_in">where</span> the snapshot is stored.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">do</span> not use /tmp <span class="hljs-keyword">for</span> storage, /tmp here is just</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">example sakes. 修改对应的zk1 zk2 zk3 zk4</span><br>dataDir=/usr/local/zookeeper/zkdata/zk1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">the port at <span class="hljs-built_in">which</span> the clients will connect</span><br>clientPort=2181<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">2001为集群通信端口，3001为集群选举端口，observer（观察者身份）</span><br>server.1=192.168.200.128:2001:3001<br>server.2=192.169.200.128:2002:3002<br>server.3=192.168.200.128:2003:3003<br>server.4=192.168.200.128:2004:3004:observer<br><br></code></pre></td></tr></table></figure><h3 id="3、连接Zookeeper集群"><a href="#3、连接Zookeeper集群" class="headerlink" title="3、连接Zookeeper集群"></a>3、连接Zookeeper集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./bin/zkCli.sh -server 192.168.200.128:2181,192.168.200.128:2182,192.168.200.128:2183<br></code></pre></td></tr></table></figure></li></ul><h2 id="九、ZAB协议"><a href="#九、ZAB协议" class="headerlink" title="九、ZAB协议"></a>九、ZAB协议</h2><h3 id="1、什么是ZAB协议"><a href="#1、什么是ZAB协议" class="headerlink" title="1、什么是ZAB协议"></a>1、什么是ZAB协议</h3><p>zookeeper作为非常重要的分布式协调组件，需要进行集群部署，集群中会以一主多从的形式进行部署。zookeeper为了保证数据的一致性，使用了ZAB（Zookeeper Atomic Broadcast）协议，这个协议解决了Zookeeper的崩溃恢复和主从数据同步的问题。</p><p><img src="/../Zookeeper/11.png"></p><h3 id="2、ZAB协议定义的四种节点状态"><a href="#2、ZAB协议定义的四种节点状态" class="headerlink" title="2、ZAB协议定义的四种节点状态"></a>2、ZAB协议定义的四种节点状态</h3><ul><li>Looking：选举状态</li><li>Following：Following节点（从节点）所处的状态</li><li>Leading：Leader节点（主节点）所处状态</li></ul><h3 id="3、集群上线Leader选举过程"><a href="#3、集群上线Leader选举过程" class="headerlink" title="3、集群上线Leader选举过程"></a>3、集群上线Leader选举过程</h3><p><img src="/../Zookeeper/12.png"></p><h3 id="4、崩溃恢复时的Leader选举"><a href="#4、崩溃恢复时的Leader选举" class="headerlink" title="4、崩溃恢复时的Leader选举"></a>4、崩溃恢复时的Leader选举</h3><p>Leader建立完后，Leader周期性地不断向Follower发送心跳（ping命令，没有内容的socket）。当Leader崩溃后，Follower发现socket通道已关闭，于是Follower开始进入到Looking状态，重新回到上一节中的Leader选举状态，此时集群不能对外提供服务。</p><p><img src="/../Zookeeper/14.png"></p><h3 id="5、主从服务器之间的数据同步"><a href="#5、主从服务器之间的数据同步" class="headerlink" title="5、主从服务器之间的数据同步"></a>5、主从服务器之间的数据同步</h3><p><img src="/../Zookeeper/13.png"></p><h3 id="6、Zookeeper中的NIO与BIO的应用"><a href="#6、Zookeeper中的NIO与BIO的应用" class="headerlink" title="6、Zookeeper中的NIO与BIO的应用"></a>6、Zookeeper中的NIO与BIO的应用</h3><ul><li>NIO<ul><li>用于被客户端连接的2181端口，使用的是NIO模式与客户端建立连接</li><li>客户端开启Watch时，也使用NIO，等待Zookeeper服务器的回调</li></ul></li><li>BIO<ul><li>集群在选举时，多个节点之间的投票通信端口，使用BIO进行通信</li></ul></li></ul><h2 id="十、CAP理论"><a href="#十、CAP理论" class="headerlink" title="十、CAP理论"></a>十、CAP理论</h2><p>2000年7月，加州大学伯克利分校的 Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和 Nancy Lynch 从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。</p><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>CAP理论为：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和区分容错性（Partition tolerance）这三项中的两项。</p><ul><li>—致性(Consistency)</li></ul><p>一致性指”all nodespsee the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。</p><ul><li>可用性(Availability)</li></ul><p>可用性指”Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。</p><ul><li>分区容错性(Partition tolerance)</li></ul><p>分区容错性指”the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。——避免单点故障，就要进行冗余部署，冗余部署相当于是服务的分区，这样的分区就具备了容错性。</p><p><img src="/../Zookeeper/15.png"></p><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p>eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性《Strong Consistency，CAP的一致性就是强一致性)，但应用可以采用适合的方式达到最终一致性(Eventual Consitency) 。</p><ul><li>基本可用(Basically Available)</li></ul><p>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。</p><p>电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。</p><ul><li>软状态(Soft State)</li></ul><p>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。</p><ul><li>最终一致性(Eventual Consistency)</li></ul><p>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的—种特殊情况。</p><h3 id="Zookeeper追求的一致性"><a href="#Zookeeper追求的一致性" class="headerlink" title="Zookeeper追求的一致性"></a>Zookeeper追求的一致性</h3><p>Zookeeper在数据同步时，追求的是强一致性，但实际上是顺序一致性（事务id的单调递增）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis大数据统计</title>
    <link href="/2023/12/29/Redis%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/"/>
    <url>/2023/12/29/Redis%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>先来一些常见问题</p><p><img src="/../Redis%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/1.png"></p><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p><img src="/../Redis%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/2.png"></p><p><img src="/../Redis%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/3.png"></p><p>基本命令：</p><p><img src="/../Redis%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/4.png"></p><p>基数统计：</p><p><img src="/../Redis%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/5.png"></p><p>统计百万级的用bitmap还算可以接受，但是如果是亿级那么占用的内存会很高，所以应该使用HyperLogLog</p><p><img src="/../Redis%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/6.png"></p><p>HyperLogLog是牺牲了一定的准确度来换取空间，在大数据的情况下，一点误差是可以接受的。</p><p><strong>HyperLogLog只是进行不重复的基数统计，不是集合也不保存数据，只纪录数量而不是具体内存</strong>，提供不精确的去重计数方案，<strong>误差率在0.81%左右</strong></p><p><img src="/../Redis%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/7.png"></p><h3 id="淘宝网站首页亿级UV的Redis统计方案"><a href="#淘宝网站首页亿级UV的Redis统计方案" class="headerlink" title="淘宝网站首页亿级UV的Redis统计方案"></a>淘宝网站首页亿级UV的Redis统计方案</h3><p>需求：</p><ul><li>UV的统计需要去重，一个用户一天内的多次访问只能算作一次</li><li>淘宝、天猫首页的UV，平均每天是1~1.5亿个左右</li><li>每天存1.5亿个IP，访问者来了后先去查是否存在，不存在加入</li></ul><p>service：</p><p><img src="/../Redis%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/8.png"></p><p>controller：</p><p><img src="/../Redis%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/9.png"></p><p>效果：</p><p><img src="/../Redis%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/10.png"></p><p>swagger点击一下：</p><p><img src="/../Redis%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/11.png"></p><p>还是很简单的</p><h2 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis的IO多路复用</title>
    <link href="/2023/12/28/Redis%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <url>/2023/12/28/Redis%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis的IO多路复用架构图"><a href="#Redis的IO多路复用架构图" class="headerlink" title="Redis的IO多路复用架构图"></a>Redis的IO多路复用架构图</h2><p><img src="/../Redis%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/1.png"></p><p><img src="/../Redis%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/2.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis与MySQL缓存双写一致性问题</title>
    <link href="/2023/12/26/Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <url>/2023/12/26/Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>先来看一些常见的面试题</p><p><img src="/../Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/1.png"></p><h2 id="读写缓存"><a href="#读写缓存" class="headerlink" title="读写缓存"></a>读写缓存</h2><p><img src="/../Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/2.png"></p><p>我们的读写缓存分为两种情况</p><ul><li>同步直写缓存策略：完成第二部<strong>立即</strong>回写Redis</li><li>异步缓写缓存策略：不急立即写回Redis<ul><li>正常业务运行中，MySQL数据变动了，但是可以在业务上容许出现一定时间后才作用于Redis，比如仓库、物流系统</li><li>异常情况出现了，不得不将失败的动作重新修补，有可能需要借助kafka或者RabbitMQ等消息中间件，实现重试重写</li></ul></li></ul><p>那么代码应该怎么写呢？下面是初级版本，<strong>业务逻辑并没有写错，对于小厂中厂(QPS&lt;&#x3D;1000)可以使用，但是大厂不行</strong></p><p><img src="/../Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/3.png"></p><p>但是以上代码有问题，如果大量请求进行第一个查询Redis为空，那么后续判断都会进行MySQL查询，打高MySQL的IO</p><h2 id="双检加锁策略"><a href="#双检加锁策略" class="headerlink" title="双检加锁策略"></a>双检加锁策略</h2><p>那么如何解决上述问题呢？</p><p>多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上<strong>使用一个互斥锁来锁住它</strong>。其他线程走到这一步就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存</p><p><img src="/../Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/4.png"></p><p><img src="/../Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/5.png"></p><p>和<strong>双重检查锁</strong>思路一样，值得借鉴</p><p><img src="/../Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/6.png"></p><h2 id="数据库和缓存一致性的几种更新策略"><a href="#数据库和缓存一致性的几种更新策略" class="headerlink" title="数据库和缓存一致性的几种更新策略"></a>数据库和缓存一致性的几种更新策略</h2><p><strong>给缓存设置过期时间，定期清理缓存并回写，是保证最终一致性的解决方案。</strong></p><p>我们可以对存入缓存的数据设置过期时间，所有的写操作<strong>以MySQL数据库为准</strong>，对缓存操作只是尽最大努力，如果数据库写入成功，缓存更新失败，那么只要达到过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存，达到一致性，切记，<strong>要以MySQL的数据库写入为准</strong></p><ul><li>先更新数据库，再更新缓存</li><li>先更新缓存，再更新数据库</li><li>先删除缓存，再更新数据库</li><li>先更新数据库，再删除缓存</li></ul><h3 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h3><p>异常情况1：</p><p><img src="/../Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/7.png"></p><p> 异常情况2：</p><p><img src="/../Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/8.png"></p><h3 id="先更新缓存，再更新数据库"><a href="#先更新缓存，再更新数据库" class="headerlink" title="先更新缓存，再更新数据库"></a>先更新缓存，再更新数据库</h3><p>不推荐，业务上一般把MySQL作为底单数据库，保证最后解释</p><p><img src="/../Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/9.png"></p><h3 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h3><p><img src="/../Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/10.png"></p><p><img src="/../Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/11.png"></p><p>为了解决这个问题，所有有了延时双删</p><h3 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h3><p><img src="/../Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/12.png"></p><p>优化版：</p><p><img src="/../Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/13.png"></p><h3 id="先更新数据库，再删除缓存-推荐"><a href="#先更新数据库，再删除缓存-推荐" class="headerlink" title="先更新数据库，再删除缓存(推荐)"></a>先更新数据库，再删除缓存(推荐)</h3><p>异常情况：</p><p><img src="/../Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/14.png"></p><p>虽然这个也有问题，但是是大厂比较推荐的方法</p><h3 id="canal结合binlog"><a href="#canal结合binlog" class="headerlink" title="canal结合binlog"></a>canal结合binlog</h3><p><img src="/../Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/15.png"></p><p><img src="/../Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/16.png"></p><h2 id="最终方案选择"><a href="#最终方案选择" class="headerlink" title="最终方案选择"></a>最终方案选择</h2><p><img src="/../Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/17.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/../Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/18.png"></p><h2 id="canal"><a href="#canal" class="headerlink" title="canal"></a>canal</h2><p><img src="/../Redis%E4%B8%8EMySQL%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/19.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis集群</title>
    <link href="/2023/12/23/Redis%E9%9B%86%E7%BE%A4/"/>
    <url>/2023/12/23/Redis%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>由于数据量过大，单个Master复制集</strong>难以承担，因此需要对多个复制集进行集群，形成水平扩展<strong>每个复制集只负责存储整个数据集的一部分</strong>，这就是Redis的集群，其作用是提供在多个Redis节点间共享数据的程序集</p><p><img src="/../Redis%E9%9B%86%E7%BE%A4/1.png"></p><p>架构图：</p><p><img src="/../Redis%E9%9B%86%E7%BE%A4/2.png"></p><p>特点：</p><ul><li>Redis集群支持多个Master，每个Master又可以挂载多个Slave</li><li>由于Cluster自带Sentinel的故障转移机制，内置了高可用的支持，<strong>无需再去使用哨兵功能</strong></li><li>客户端与Redis的节点连接，不再需要连接集群中的所有节点，只需要任意连接集群的一个可用节点</li><li><strong>槽位slot</strong>负责分配到各个物理服务节点，由对应的集群来负责维护节点</li></ul><h2 id="Redis集群的数据分片"><a href="#Redis集群的数据分片" class="headerlink" title="Redis集群的数据分片"></a>Redis集群的数据分片</h2><p>Redis集群<strong>没有使用一致性hash</strong>，而是引入了<strong>哈希槽</strong>的概念。</p><p>Redis集群有<strong>16384个</strong>哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽，举个例子，比如当前集群有3个节点</p><p><img src="/../Redis%E9%9B%86%E7%BE%A4/3.png"></p><p>分片：使用Redis集群时我们会将存储的数据分散到多台Redis机器上，这称为分片。简言之，集群中的每个Redis实例都被认为是整个数据的一个分片</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>优势：<strong>方便扩缩容和数据分派查找</strong></p><p>这种结构很容易添加或者删除节点，比如如果我们想添加个节点D，我需要从A、B、C中的部分槽到D上，如果我想移除节点A，需要将A中的槽移到B和C节点上，然后将没有任何槽的A节点从集群中移除即可，由于从一个节点将哈希槽移到另一个节点并不会停止服务，所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用状态</p><h2 id="哈希槽分区"><a href="#哈希槽分区" class="headerlink" title="哈希槽分区"></a>哈希槽分区</h2><p>这里可以看看小林coding的<strong>哈希取余分区</strong>、<strong>一致性哈希算法分区</strong>再来与<strong>哈希槽分区</strong>对比优劣势</p><p>为什么出现哈希槽分区？因为<strong>一致性哈希算法的数据倾斜问题</strong></p><p>哈希槽实质就是一个数组，数组[0，2^14-1]形成hash slot空间</p><p>解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为hash槽(slot)，用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里放的是数据。</p><p><img src="/../Redis%E9%9B%86%E7%BE%A4/4.png"></p><p>槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。哈希解决的是映射问题，使用key的哈希值来计算所在的槽，便于数据分配。</p><p>Redis集群内置了16384个哈希槽，redis会根据节点数量大致均等的将哈希槽映射到不同节点。当需要在Redis集群中放置一个key-value时，redis先对key使用CRC16算法算出一个结果然后用16384求余数[CRC16(key)%16384]，这样每个key都会对应一个编号在0-16383之间的哈希槽，也就是映射到某个节点上。</p><h2 id="为什么Redis集群最大槽数是16384个？"><a href="#为什么Redis集群最大槽数是16384个？" class="headerlink" title="为什么Redis集群最大槽数是16384个？"></a>为什么Redis集群最大槽数是16384个？</h2><p>先来看正常的心跳数据包结构</p><p><img src="/../Redis%E9%9B%86%E7%BE%A4/5.png"></p><p><img src="/../Redis%E9%9B%86%E7%BE%A4/6.png"></p><p>此外，<strong>Redis集群不保证强一致性</strong>，这意味这在特定条件下，Redis集群可能会丢掉一些被系统收到的写入请求命令(因为主从复制是异步的，即主节点收到一条最新命令，还没复制到从节点时，主节点就挂了)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>雪花算法</title>
    <link href="/2023/12/16/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/"/>
    <url>/2023/12/16/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>snowflake是Twitter开源的<strong>分布式ID</strong>生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。</p><p><img src="/../%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/1.png"></p><p>这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是409.6万个ID。</p><p>Java实现代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Twitter_Snowflake&lt;br&gt;</span><br><span class="hljs-comment"> * SnowFlake的结构如下(每部分用-分开):&lt;br&gt;</span><br><span class="hljs-comment"> * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;</span><br><span class="hljs-comment"> * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&lt;br&gt;</span><br><span class="hljs-comment"> * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截)</span><br><span class="hljs-comment"> * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&lt;br&gt;</span><br><span class="hljs-comment"> * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&lt;br&gt;</span><br><span class="hljs-comment"> * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;br&gt;</span><br><span class="hljs-comment"> * 加起来刚好64位，为一个Long型。&lt;br&gt;</span><br><span class="hljs-comment"> * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SnowflakeIdWorker</span> &#123;<br><br>    <span class="hljs-comment">// ==============================Fields===========================================</span><br>    <span class="hljs-comment">/** 开始时间截 (2015-01-01) */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> twepoch = <span class="hljs-number">1420041600000L</span>;<br><br>    <span class="hljs-comment">/** 机器id所占的位数 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> workerIdBits = <span class="hljs-number">5L</span>;<br><br>    <span class="hljs-comment">/** 数据标识id所占的位数 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> datacenterIdBits = <span class="hljs-number">5L</span>;<br><br>    <span class="hljs-comment">/** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> maxWorkerId = <span class="hljs-number">-1L</span> ^ (<span class="hljs-number">-1L</span> &lt;&lt; workerIdBits);<br><br>    <span class="hljs-comment">/** 支持的最大数据标识id，结果是31 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> maxDatacenterId = <span class="hljs-number">-1L</span> ^ (<span class="hljs-number">-1L</span> &lt;&lt; datacenterIdBits);<br><br>    <span class="hljs-comment">/** 序列在id中占的位数 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> sequenceBits = <span class="hljs-number">12L</span>;<br><br>    <span class="hljs-comment">/** 机器ID向左移12位 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> workerIdShift = sequenceBits;<br><br>    <span class="hljs-comment">/** 数据标识id向左移17位(12+5) */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> datacenterIdShift = sequenceBits + workerIdBits;<br><br>    <span class="hljs-comment">/** 时间截向左移22位(5+5+12) */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;<br><br>    <span class="hljs-comment">/** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> sequenceMask = <span class="hljs-number">-1L</span> ^ (<span class="hljs-number">-1L</span> &lt;&lt; sequenceBits);<br><br>    <span class="hljs-comment">/** 工作机器ID(0~31) */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> workerId;<br><br>    <span class="hljs-comment">/** 数据中心ID(0~31) */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> datacenterId;<br><br>    <span class="hljs-comment">/** 毫秒内序列(0~4095) */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> sequence = <span class="hljs-number">0L</span>;<br><br>    <span class="hljs-comment">/** 上次生成ID的时间截 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> lastTimestamp = <span class="hljs-number">-1L</span>;<br><br>    <span class="hljs-comment">//==============================Constructors=====================================</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数</span><br><span class="hljs-comment">     * @param workerId 工作ID (0~31)</span><br><span class="hljs-comment">     * @param datacenterId 数据中心ID (0~31)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SnowflakeIdWorker</span><span class="hljs-params">(<span class="hljs-type">long</span> workerId, <span class="hljs-type">long</span> datacenterId)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">IllegalArgumentException</span>(<span class="hljs-type">String</span>.format(<span class="hljs-string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">IllegalArgumentException</span>(<span class="hljs-type">String</span>.format(<span class="hljs-string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId));<br>        &#125;<br>        <span class="hljs-keyword">this</span>.workerId = workerId;<br>        <span class="hljs-keyword">this</span>.datacenterId = datacenterId;<br>    &#125;<br><br>    <span class="hljs-comment">// ==============================Methods==========================================</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获得下一个ID (该方法是线程安全的)</span><br><span class="hljs-comment">     * @return SnowflakeId</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">long</span> <span class="hljs-title">nextId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">long</span> timestamp = <span class="hljs-built_in">timeGen</span>();<br><br>        <span class="hljs-comment">//如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span><br>        <span class="hljs-keyword">if</span> (timestamp &lt; lastTimestamp) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RuntimeException</span>(<br>                    <span class="hljs-type">String</span>.format(<span class="hljs-string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>, lastTimestamp - timestamp));<br>        &#125;<br><br>        <span class="hljs-comment">//如果是同一时间生成的，则进行毫秒内序列</span><br>        <span class="hljs-keyword">if</span> (lastTimestamp == timestamp) &#123;<br>            sequence = (sequence + <span class="hljs-number">1</span>) &amp; sequenceMask;<br>            <span class="hljs-comment">//毫秒内序列溢出</span><br>            <span class="hljs-keyword">if</span> (sequence == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//阻塞到下一个毫秒,获得新的时间戳</span><br>                timestamp = <span class="hljs-built_in">tilNextMillis</span>(lastTimestamp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//时间戳改变，毫秒内序列重置</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            sequence = <span class="hljs-number">0L</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//上次生成ID的时间截</span><br>        lastTimestamp = timestamp;<br><br>        <span class="hljs-comment">//移位并通过或运算拼到一起组成64位的ID</span><br>        <span class="hljs-keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class="hljs-comment">//</span><br>                | (datacenterId &lt;&lt; datacenterIdShift) <span class="hljs-comment">//</span><br>                | (workerId &lt;&lt; workerIdShift) <span class="hljs-comment">//</span><br>                | sequence;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 阻塞到下一个毫秒，直到获得新的时间戳</span><br><span class="hljs-comment">     * @param lastTimestamp 上次生成ID的时间截</span><br><span class="hljs-comment">     * @return 当前时间戳</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-type">long</span> <span class="hljs-title">tilNextMillis</span><span class="hljs-params">(<span class="hljs-type">long</span> lastTimestamp)</span> </span>&#123;<br>        <span class="hljs-type">long</span> timestamp = <span class="hljs-built_in">timeGen</span>();<br>        <span class="hljs-keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;<br>            timestamp = <span class="hljs-built_in">timeGen</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> timestamp;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回以毫秒为单位的当前时间</span><br><span class="hljs-comment">     * @return 当前时间(毫秒)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-type">long</span> <span class="hljs-title">timeGen</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> System.<span class="hljs-built_in">currentTimeMillis</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//==============================Test=============================================</span><br>    <span class="hljs-comment">/** 测试 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        SnowflakeIdWorker idWorker = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SnowflakeIdWorker</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-type">long</span> id = idWorker.<span class="hljs-built_in">nextId</span>();<br>            System.out.<span class="hljs-built_in">println</span>(Long.<span class="hljs-built_in">toBinaryString</span>(id));<br>            System.out.<span class="hljs-built_in">println</span>(id);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>优点：</p><ul><li>快</li><li>无依赖，实现简单</li><li>方便灵活调整</li></ul><p>缺点：</p><ul><li>只能趋势递增。（有些也不叫缺点，网上有些如果绝对递增，竞争对手中午下单，第二天在下单即可大概判断该公司的订单量，危险！！！）</li><li>依赖机器时间，如果发生回拨会导致可能生成id重复(时间回拨)。</li></ul><h3 id="时钟回拨"><a href="#时钟回拨" class="headerlink" title="时钟回拨"></a>时钟回拨</h3><p>提到时钟回拨，回忆起来当初面试<strong>途虎养车</strong>面试官问过这个问题没回答上来。</p><h4 id="时间回拨问题思考"><a href="#时间回拨问题思考" class="headerlink" title="时间回拨问题思考"></a>时间回拨问题思考</h4><p>由于存在时间回拨问题，但是他又是那么快和简单，我们思考下是否可以解决呢？ <strong>在网上找了一圈没有发现具体的解决方案</strong>，但是找到了一篇美团不错的文章：Leaf——美团点评分布式ID生成系统（<a href="https://tech.meituan.com/MT_Leaf.html%EF%BC%89%E6%96%87%E7%AB%A0%E5%BE%88%E4%B8%8D%E9%94%99%EF%BC%8C%E5%8F%AF%E6%83%9C%E5%B9%B6%E6%B2%A1%E6%9C%89%E6%8F%90%E5%88%B0%E6%97%B6%E9%97%B4%E5%9B%9E%E6%8B%A8%E5%A6%82%E4%BD%95%E5%85%B7%E4%BD%93%E8%A7%A3%E5%86%B3%E3%80%82%E4%B8%8B%E9%9D%A2%E7%9C%8B%E7%9C%8B%E6%88%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%EF%BC%9A">https://tech.meituan.com/MT_Leaf.html）文章很不错，可惜并没有提到时间回拨如何具体解决。下面看看我的一些思考：</a></p><p>产生时钟回拨问题原因：</p><ul><li>人物操作，在真实环境一般不会有那个傻逼干这种事情，所以基本可以排除</li><li>由于有些业务等需要，机器需要同步时间服务器</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul><li>当回拨时间小于15ms时，那么就等时间追上来之后继续生产</li><li>当时间大于15ms时，我们通过<strong>更换woekId</strong>来产生之前都没有产生过的来解决</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DDIA</title>
    <link href="/2023/12/13/DDIA/"/>
    <url>/2023/12/13/DDIA/</url>
    
    <content type="html"><![CDATA[<h2 id="数据系统基础"><a href="#数据系统基础" class="headerlink" title="数据系统基础"></a>数据系统基础</h2><h3 id="可靠性、可扩展性、可维护性"><a href="#可靠性、可扩展性、可维护性" class="headerlink" title="可靠性、可扩展性、可维护性"></a>可靠性、可扩展性、可维护性</h3><p>现今很多应用程序都是<strong>数据密集型</strong>，CPU很少成为这类应用的瓶颈，更大的问题来自是<strong>数据量、数据复杂性以及数据的变更速度。</strong></p><p>数据密集型应用通常由标准组件构建而成，标准组件提供了很多通用的功能；例如，许多应 用程序都需要：</p><ul><li>数据库（database）</li></ul><p>存储数据，以便自己或其他应用程序之后能再次找到</p><ul><li>缓存（cache）</li></ul><p>记住开销昂贵操作的结果，加快读取速度</p><ul><li>搜索索引（search indexes）</li></ul><p>允许用户按关键字搜索数据，或以各种方式对数据进行过滤</p><ul><li>流处理（stream processing）</li></ul><p>向其他进程发送消息，进行异步处理</p><ul><li>批处理（batch processing）</li></ul><p>定期处理累积的大批量数据</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis缓存淘汰策略</title>
    <link href="/2023/10/25/Redis%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"/>
    <url>/2023/10/25/Redis%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p>先来看一些常见问题</p><p><img src="/../Redis%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/1.png"></p><h2 id="默认内存大小"><a href="#默认内存大小" class="headerlink" title="默认内存大小"></a>默认内存大小</h2><p>如果不设置最大内存大小或者设置最大内存大小为0，<strong>在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存</strong>，在64bit系统下，maxmemory设置为0表示不限制Redis内存使用，在生产中，推荐Redis设置内存为最大物理内存的四分之三</p><h2 id="三种不同的删除策略"><a href="#三种不同的删除策略" class="headerlink" title="三种不同的删除策略"></a>三种不同的删除策略</h2><ul><li>立即删除：对CPU不友好，用处理器性能换取存储空间</li></ul><p><img src="/../Redis%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/2.png"></p><ul><li>惰性删除：对memory不友好，用存储空间换取处理器性能</li></ul><p><img src="/../Redis%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/3.png"></p><ul><li>定期删除：总有漏网之鱼</li></ul><p><img src="/../Redis%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/4.png"></p><p>基于上述删除策略都有一定问题，下面我们引出了<strong>缓存淘汰策略</strong></p><h2 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h2><p>当我们的内存达到最大时，将会触发我们的缓存淘汰策略</p><p>常见的问题就是LRU和LFU的区别？</p><p><img src="/../Redis%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/5.png"></p><p>下图即是所有淘汰策略</p><p><img src="/../Redis%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/6.png"></p><p>总结：</p><p><img src="/../Redis%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/7.png"></p><p>选择</p><p><img src="/../Redis%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/8.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis五大类型源码及底层实现</title>
    <link href="/2023/10/25/Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/10/25/Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="涉及到的底层实现总览"><a href="#涉及到的底层实现总览" class="headerlink" title="涉及到的底层实现总览"></a>涉及到的底层实现总览</h2><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/1.png"></p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/2.png"></p><p>通过上图可知，key一般都是String类型的字符串对象，</p><p><strong>而value类型则为redis对象(redisObject)</strong></p><h2 id="10大类型说明-粗分"><a href="#10大类型说明-粗分" class="headerlink" title="10大类型说明(粗分)"></a>10大类型说明(粗分)</h2><p>传统的5大类型</p><ul><li>String</li><li>Hash</li><li>list</li><li>set</li><li>zset</li></ul><p>新介绍的5大类型</p><ul><li>bitmap —实质String </li><li>hyperLoglog — 实质String</li><li>GEO — 实质Zset</li><li>Stream — 实质Stream</li><li>BitField — 看具体key</li></ul><h2 id="从dictEntry到redisObject"><a href="#从dictEntry到redisObject" class="headerlink" title="从dictEntry到redisObject"></a>从dictEntry到redisObject</h2><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/5.png"></p><p>dictEntry表示哈希表结点的结构，存放了void* key和void* value指针</p><p>*key指向String对象，</p><p>*value既能指向String对象也能指向集合类型的对象(比如List+Hash+Set+Zset对象)23</p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/3.png"></p><p>redisObject</p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/6.png"></p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/4.png"></p><h2 id="五大基本数据类型及底层实现-熟记"><a href="#五大基本数据类型及底层实现-熟记" class="headerlink" title="五大基本数据类型及底层实现(熟记)"></a>五大基本数据类型及底层实现(熟记)</h2><p>但是Redis6与Redis7底层实现有所不同，所以两个版本都需要掌握</p><p>Redis6：</p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/8.png"></p><p>Redis7：</p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/7.png"></p><p>其中listpack代替了ziplist</p><h2 id="每个键值都会有一个dictEntry"><a href="#每个键值都会有一个dictEntry" class="headerlink" title="每个键值都会有一个dictEntry"></a>每个键值都会有一个dictEntry</h2><p>我们以set hello word为例，因为Redis是KV键值对，<strong>每个键值对都会有一个dictEntry(源码位置:dict.h)，</strong>里面指向了key和value的指针，next指向了下一个dictEntry。</p><p>key是字符串，但是Redis没有直接使用C的字符数组，而是存储在redis自定义的SDS中。</p><p><strong>value既不是直接作为字符串存储，也不是直接存储在SDS中，而是存储在redisObject中。实际上五种常用的数据类型的任何一种都是通过redisObject来存储的</strong></p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/9.png"></p><h2 id="RedisObject的作用"><a href="#RedisObject的作用" class="headerlink" title="RedisObject的作用"></a>RedisObject的作用</h2><p>为了便于操作，Redis采用redisObject结构来统一五种不同的数据类型，这样所有的数据类型就都可以以相同的形式在函数间传递而不用使用特定的类型结构。同时，为了redisObject中定义了type和encoding字段对不同的数据类型加以区别。简单地说，redisObject就是string、hash、list、set、zset地父类，可以在函数间传递时隐藏具体地类型信息，所以作者抽象了redisObject结构来达到同样的目的。</p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/10.png"></p><h2 id="RedisObject各字段的含义"><a href="#RedisObject各字段的含义" class="headerlink" title="RedisObject各字段的含义"></a>RedisObject各字段的含义</h2><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/11.png"></p><ul><li>4位的type表示具体的数据类型</li><li>4位的encoding表示该类型的物理编码方式见下表，同一种数据类型可能有不同的编码方式(比如String就提供了3种：int、embstr、raw)</li></ul><p>编码表：</p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/12.png"></p><ul><li>LRU字段表示当内存超限时采用LRU算法清楚内存中的对象</li><li>refcount表示对象的引用计数</li><li><strong>ptr指针指向真正的底层数据结构的指针</strong></li></ul><h2 id="物理编码-案例"><a href="#物理编码-案例" class="headerlink" title="物理编码-案例"></a>物理编码-案例</h2><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/13.png"></p><p>可以看到，hello和age同样是string类型，但是物理编码不同</p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/14.png"></p><h2 id="各个类型的数据结构的编码映射和定义"><a href="#各个类型的数据结构的编码映射和定义" class="headerlink" title="各个类型的数据结构的编码映射和定义"></a>各个类型的数据结构的编码映射和定义</h2><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/15.png"></p><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>string类型有三种物理编码方式</p><ul><li>int</li></ul><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/16.png"></p><ul><li>embstr</li></ul><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/17.png"></p><ul><li>raw</li></ul><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/18.png"></p><p>测试案例</p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/19.png"></p><h3 id="SDS-简单动态字符串"><a href="#SDS-简单动态字符串" class="headerlink" title="SDS(简单动态字符串)"></a>SDS(简单动态字符串)</h3><p>Redis是由C语言编写的，那么为什么不用原生C语言的字符串(char数组)？</p><p>下面参考Redis设计与实现的一段话</p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/24.png"></p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/25.png"></p><p>下面就一起来探究</p><p>打开Redis源码包，sds.h，<strong>注意Redis6的SDS与Redis7的SDS不一样</strong></p><p><strong>通过对 buf 分配一些额外的空间，并使用 free 记录未使用空间的大小，sdshdr 可 以让执行追加操作所需的内存重分配次数大大减少</strong></p><p>Redis3：</p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/26.png"></p><p>Redis7：</p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/20.png"></p><p>可以看到SDS有多种结构</p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/21.png"></p><p>都由<strong>len、alloc、flags、buf</strong>组成</p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/22.png"></p><p>好处：</p><ul><li>len表示SDS的长度，使我们在获取字符串长度的时候可以在O(1)的情况瞎拿到</li><li>alloc可以用来计算free就是字符串已经分配未使用的空间，有了这个值就可以引入预分配空间的算法了，而不用去考虑内存分配的问题</li></ul><p>综上所述</p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/23.png"></p><p>此外，在 Redis 中，客户端传入服务器的协议内容、aof 缓 存、返回给客户端的回复，等等，这些重要的内容都是由都是由 sds 类型来保存的。</p><h3 id="三种物理编码区别"><a href="#三种物理编码区别" class="headerlink" title="三种物理编码区别"></a>三种物理编码区别</h3><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/27.png"></p><p>结构图：</p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/28.png"></p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>两种编码格式，分为Redis6与Redis7</p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/29.png"></p><h3 id="在Redis6中"><a href="#在Redis6中" class="headerlink" title="在Redis6中"></a>在Redis6中</h3><p><strong>hash-max-zip-entries：使用压缩列表保存时哈希集合的最大元素个数</strong></p><p><strong>hash-max-zip-value：使用压缩列表保存时哈希集合中单个元素的最大长度</strong></p><p>Hash类型键的字段个数<strong>小于</strong> hash-max-zip-entries 并且每个字段名和字段值的长度<strong>小于</strong> hash-max-zip-value 时，Redis才会使用 OBJ_ENCODING_ZIPLIST来存储该键，前述条件任意一个不满足则会满足<strong>OBJ_ENCODING_HT</strong>的编码方式</p><h3 id="OBJ-ENCODING-HT编码分析"><a href="#OBJ-ENCODING-HT编码分析" class="headerlink" title="OBJ_ENCODING_HT编码分析"></a>OBJ_ENCODING_HT编码分析</h3><p>OBJ_ENCODING_HT 这种编码方式内部才是真正的哈希表结构，或称为字典结构，其可以实现O(1)复杂度的读写操作，因此在Redis内部，从OBJ_ENCODING_HT类型到底层真正的散列表数据结构是一层层嵌套下去的，组织关系见下图：</p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/30.png"></p><h3 id="Ziplist"><a href="#Ziplist" class="headerlink" title="Ziplist"></a>Ziplist</h3><p>Ziplist压缩列表是一种紧凑编码格式，总体思想是<strong>多花时间换取节约空间</strong>，即以部分读写性能为代价，来换取极高的内存空间利用率，因此<strong>只会用于字段个数少，且字段值也较小的场景</strong>。压缩列表内存利用率极高的原因与其连续内存的特性是分不开的。</p><p>它是由连续内存块组成的顺序型数据结构，有点类似于数组</p><p>ziplist是一个经过特殊编码的<strong>双向链表</strong>，<strong>它不存储指向前一个链表节点prev和指向下一个链表节点next</strong>而是<strong>存储上一个节点长度和当前节点长度</strong>，通过牺牲部分读写性能来换取高效的内存空间利用率，节约内存，是一种时间换空间的思想。只用在<strong>字段个数少，字段值小的场景里面</strong></p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/31.png"></p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/32.png"></p><h4 id="zlentry"><a href="#zlentry" class="headerlink" title="zlentry"></a>zlentry</h4><p>那么存储数据的都是由**zlentry(压缩列表节点)**结构封装的</p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/33.png"></p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/34.png"></p><h4 id="Ziplist存取情况"><a href="#Ziplist存取情况" class="headerlink" title="Ziplist存取情况"></a>Ziplist存取情况</h4><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/35.png"></p><ul><li>prevlen：记录了前一个节点的长度</li></ul><p>如果前一个节点的长度小于254字节，那么prelen属性需要用<strong>1字节空间</strong>保存这个长度值；</p><p>如果前一个节点的长度大于254字节，那么prelen属性需要用<strong>5字节空间</strong>保存这个长度值；</p><p>这就为<strong>连锁更新问题</strong>埋下了伏笔</p><ul><li>encoding：记录了当前节点实际数据以及长度</li><li>data：记录了当前节点的实际数据</li></ul><h4 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h4><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/40.png"></p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/41.png"></p><h3 id="明明有链表了为什么出来一个压缩列表"><a href="#明明有链表了为什么出来一个压缩列表" class="headerlink" title="明明有链表了为什么出来一个压缩列表"></a>明明有链表了为什么出来一个压缩列表</h3><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/36.png"></p><h3 id="Ziplist总结"><a href="#Ziplist总结" class="headerlink" title="Ziplist总结"></a>Ziplist总结</h3><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/37.png"></p><h3 id="Ziplist对比listpack"><a href="#Ziplist对比listpack" class="headerlink" title="Ziplist对比listpack"></a>Ziplist对比listpack</h3><p>ziplist：</p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/38.png"></p><p>和ziplist列表项类似，listpack列表项也包含了远数据信息和数据本身，不过，为了避免ziplist引起的<strong>连锁更新问题</strong>，listpack中的每个列表项不再像ziplist列表项那样保存其前一个列表项的长度</p><p>listpack：</p><p><img src="/../Redis%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/39.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis分布式锁进阶</title>
    <link href="/2023/10/23/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%BF%9B%E9%98%B6/"/>
    <url>/2023/10/23/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="条件与刚需"><a href="#条件与刚需" class="headerlink" title="条件与刚需"></a>条件与刚需</h2><p>一个靠谱的分布式锁需要具备的条件和刚需</p><ul><li>独占性</li><li>高可用</li><li>防死锁</li><li>不乱抢</li><li>重入性</li></ul><h2 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h2><p>在我们redis中，判断分布式锁的K-V中，K是业务相关的锁名称，可以随意，而V是跟线程有关的ID，因为我们del 删除K的时候要判断是不是当前线程加的，不能删除别的线程加的锁(不能误删)，所以我们在删除K的时候会判断V是不是当前线程自己的，而在高并发多线程的情况下，判断和删除不是原子性的，因为我们采用Lua脚本确保两个操作的原子性。</p><h2 id="Lua案例"><a href="#Lua案例" class="headerlink" title="Lua案例"></a>Lua案例</h2><p>在我们的Redis官网中，解决上述判断锁和删除锁的Lua脚本是这样的</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">if</span> redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;get&#x27;</span>,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;del&#x27;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><strong>传入参数是KEYS[]和ARGV[]</strong>,<strong>并且数组下标是以1开始的</strong></p><p>在我们redis中，调用脚本使用EVAL命令</p><p>案例：使用mset写入多个值，我们的Lua脚本是这样写的</p><p><img src="/../Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%8F%90%E5%8D%87%E7%82%B9/1.png"></p><p>但是这样写有个弊端：k1,v1,k2,v2写死了，不利于复用</p><p>改下如下:</p><p><img src="/../Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%8F%90%E5%8D%87%E7%82%B9/2.png"></p><p>分析：这里的KEYS[]是Key数组，call是调用的意思，ARGV[]是value数组，后面的2是numKeys的意思，代表是keys的数量，这里有两个key所以是2，k1,k2是key，连续传入，lua1，lua2是参数</p><h2 id="Lua条件判断"><a href="#Lua条件判断" class="headerlink" title="Lua条件判断"></a>Lua条件判断</h2><p>格式：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">if</span> 布尔条件 then<br>业务代码<br><span class="hljs-keyword">elseif</span> 布尔条件 then<br>业务代码<br><span class="hljs-keyword">else</span><br>业务代码<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>除了最后一个判断，每个条件判断后都需要加上then，并且有if最后一定得有end结尾，其他和Java差不多，条件判断内括号可加可不加</p><h2 id="解决上述误删所调用的Lua脚本编写"><a href="#解决上述误删所调用的Lua脚本编写" class="headerlink" title="解决上述误删所调用的Lua脚本编写"></a>解决上述误删所调用的Lua脚本编写</h2><p><img src="/../Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%8F%90%E5%8D%87%E7%82%B9/3.png"></p><h2 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h2><p>我们上面实现的分布式没有考虑可重入问题，容易导致死锁问题，</p><p>我们原来的分布式锁长这样： keyName   UUID+ThreadID,改进之后需要记录重入次数，所以改进之后的结果长这样</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">keyName</span> UUID+ThreadID <span class="hljs-number">0</span><br><span class="hljs-attribute">keyName</span> UUID+ThreadID <span class="hljs-number">1</span><br><span class="hljs-attribute">keyName</span> UUID+ThreadID <span class="hljs-number">2</span><br><span class="hljs-attribute">keyName</span> UUID+ThreadID <span class="hljs-number">1</span><br><span class="hljs-attribute">keyName</span> UUID+ThreadID <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>重入一次+1，当为0时表示已经可以释放锁了</p><p><strong>那么就需要采用hash结构</strong></p><h2 id="改为hash结构后lock-x2F-unlock的Lua脚本编写"><a href="#改为hash结构后lock-x2F-unlock的Lua脚本编写" class="headerlink" title="改为hash结构后lock&#x2F;unlock的Lua脚本编写"></a>改为hash结构后lock&#x2F;unlock的Lua脚本编写</h2><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><ul><li>加锁的Lua脚本，对标我们的lock方法(v1版)</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//1.首先判断我们的Key是否存在</span><br><span class="hljs-keyword">if</span> redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;exists&#x27;</span>,<span class="hljs-string">&#x27;key&#x27;</span>) == <span class="hljs-number">0</span> then <span class="hljs-comment">//不存在可以直接lock</span><br>redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;hset&#x27;</span>,<span class="hljs-string">&#x27;key&#x27;</span>,<span class="hljs-string">&#x27;uuid:threadID&#x27;</span>,<span class="hljs-number">1</span>)<br>redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;expire&#x27;</span>,<span class="hljs-string">&#x27;key&#x27;</span>,<span class="hljs-number">30</span>) <span class="hljs-comment">//加上过期时间</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br> <span class="hljs-comment">//2.key已经存在，判断是不是我们当前线程自己加的锁</span><br> <span class="hljs-comment">//2.1 是我们自己的锁的话，重入次数+1</span><br>elseif redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;hexists&#x27;</span>,<span class="hljs-string">&#x27;key&#x27;</span>,<span class="hljs-string">&#x27;uuid:threadID&#x27;</span>) == <span class="hljs-number">1</span> then<br>redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;hincrby&#x27;</span>,<span class="hljs-string">&#x27;key&#x27;</span>,<span class="hljs-string">&#x27;uuid:threadID&#x27;</span>,<span class="hljs-number">1</span>)<br>redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;expire&#x27;</span>,<span class="hljs-number">30</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>end<br><br></code></pre></td></tr></table></figure><p>但是上述的代码前两个逻辑几乎一致，所以是否可以合并简洁？经过测试，</p><p>hincrby可以代替hset的作用，也能创建key，所以v1版本可以改进</p><ul><li>v2</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">if</span> redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;exists&#x27;</span>,<span class="hljs-string">&#x27;key&#x27;</span>) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;hexists&#x27;</span>,<span class="hljs-string">&#x27;key&#x27;</span>,<span class="hljs-string">&#x27;uuid:threadID&#x27;</span>) == <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> <br>redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;hincrby&#x27;</span>,<span class="hljs-string">&#x27;key&#x27;</span>,<span class="hljs-string">&#x27;uuid:threadID&#x27;</span>,<span class="hljs-number">1</span>)<br>redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;expire&#x27;</span>,<span class="hljs-number">30</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><ul><li>v3,换上我们的参数</li></ul><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">if</span> redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;exists&#x27;</span>,<span class="hljs-keyword">KEY</span>[1]) == 0 <span class="hljs-keyword">or</span> redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;hexists&#x27;</span>,<span class="hljs-keyword">KEY</span>[1],ARGV[1]) == 1 <span class="hljs-keyword">then</span> <br>redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;hincrby&#x27;</span>,<span class="hljs-keyword">KEY</span>[1],ARGV[1],1)<br>redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;expire&#x27;</span>,ARGV[2])<br><span class="hljs-keyword">return</span> 1<br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">return</span> 0<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h3><p>流程：首先判断是否有锁，没有直接返回nil，如果有且是自己的，调用incrby -1直到为0时删除锁</p><ul><li>v1</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//1.首先判断是否有锁</span><br><span class="hljs-comment">//1.1,不存在 直接返回nil</span><br><span class="hljs-keyword">if</span> redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;hexists&#x27;</span>,<span class="hljs-string">&#x27;key&#x27;</span>,<span class="hljs-string">&#x27;uuid:threadID&#x27;</span>) == <span class="hljs-number">0</span> then <br><span class="hljs-keyword">return</span> nil<br><span class="hljs-comment">//1.2 ,存在的话重入次数-1，当为0时del key</span><br>elseif redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;hincrby&#x27;</span>,<span class="hljs-string">&#x27;key&#x27;</span>,<span class="hljs-string">&#x27;uuid:threadID&#x27;</span>,-<span class="hljs-number">1</span>) == <span class="hljs-number">0</span> then<br><span class="hljs-keyword">return</span> redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;del&#x27;</span>,key)<br><span class="hljs-keyword">else</span> <span class="hljs-comment">//有锁，但是还没减为0</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>end<br></code></pre></td></tr></table></figure><ul><li>v2，将我们的参数替换上去</li></ul><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">if</span> redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;hexists&#x27;</span>,KEYS[1],ARGV[1]) == 0 <span class="hljs-keyword">then</span> <br><span class="hljs-keyword">return</span> nil<br>//1.2 ,存在的话重入次数-1，当为0时del <span class="hljs-keyword">key</span><br>elseif redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;hincrby&#x27;</span>,KEYS[1],ARGV[1],-1) == 0 <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;del&#x27;</span>,<span class="hljs-keyword">key</span>)<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> 0<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="分布式锁在Java中的应用"><a href="#分布式锁在Java中的应用" class="headerlink" title="分布式锁在Java中的应用"></a>分布式锁在Java中的应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisDistributedLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>    <span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br>    <span class="hljs-keyword">private</span> String lockName; <span class="hljs-comment">//keys[1]</span><br>    <span class="hljs-keyword">private</span> String field; <span class="hljs-comment">//ARGV[1]</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> EXPIRE; <span class="hljs-comment">//ARGV[2]</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisDistributedLock</span><span class="hljs-params">(StringRedisTemplate redisTemplate, String lockName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>        <span class="hljs-built_in">this</span>.lockName = lockName;<br>        <span class="hljs-built_in">this</span>.field = <span class="hljs-string">&quot;UUID&quot;</span>+Thread.currentThread().getId();<br>        <span class="hljs-built_in">this</span>.EXPIRE = <span class="hljs-number">25</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        tryLock();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            tryLock(-<span class="hljs-number">1</span>,TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span>(time == -<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span><br>                    <span class="hljs-string">&quot;if redis.call(&#x27;exists&#x27;,KEY[1]) == 0 or redis.call(&#x27;hexists&#x27;,KEY[1],ARGV[1]) == 1 then &quot;</span> +<br>                            <span class="hljs-string">&quot;redis.call(&#x27;hincrby&#x27;,KEY[1],ARGV[1],1)&quot;</span> +<br>                            <span class="hljs-string">&quot;redis.call(&#x27;expire&#x27;,ARGV[2])&quot;</span> +<br>                            <span class="hljs-string">&quot;return 1&quot;</span> +<br>                    <span class="hljs-string">&quot;else &quot;</span> +<br>                            <span class="hljs-string">&quot;treturn 0&quot;</span> +<br>                    <span class="hljs-string">&quot;end&quot;</span>;<br>            <span class="hljs-keyword">while</span>(!redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(script,Boolean.class), Arrays.asList(lockName),field,EXPIRE))&#123;<br>                Thread.sleep(<span class="hljs-number">60</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span><br>                <span class="hljs-string">&quot;if redis.call(&#x27;hexists&#x27;,KEYS[1],ARGV[1]) == 0 then &quot;</span> +<br>                        <span class="hljs-string">&quot;return nil&quot;</span> +<br>                <span class="hljs-string">&quot;elseif redis.call(&#x27;incrby&#x27;,KEYS[1],ARGV[1],-1) == 0 then&quot;</span> +<br>                        <span class="hljs-string">&quot;return redis.call(&#x27;del&#x27;,key)&quot;</span> +<br>                <span class="hljs-string">&quot;else&quot;</span> +<br>                        <span class="hljs-string">&quot;return 0&quot;</span> +<br>                <span class="hljs-string">&quot;end&quot;</span>;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(script,Long.class), Arrays.asList(lockName),field);<br><br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;锁不存在&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="看门狗机制实现"><a href="#看门狗机制实现" class="headerlink" title="看门狗机制实现"></a>看门狗机制实现</h3><p>首先先实现续期的Lua脚本</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">if</span> redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;HEXISTS&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> redis.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;expire&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">2</span>])<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>思路，每次加锁成功后，开一个定时器每过10S再次调用重置时间函数</p><p><img src="/../Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%8F%90%E5%8D%87%E7%82%B9/4.png"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">resetExpire</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">String</span> script =<br>                <span class="hljs-string">&quot;if redis.call(&#x27;HEXISTS&#x27;,KEYS[1],ARGV[1]) == 1 then&quot;</span> +<br>                        <span class="hljs-string">&quot;return redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2])&quot;</span> +<br>                <span class="hljs-string">&quot;else&quot;</span> +<br>                        <span class="hljs-string">&quot;return 0&quot;</span> +<br>                <span class="hljs-string">&quot;end&quot;</span>;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>().<span class="hljs-title function_">schedule</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">if</span>(redisTemplate.<span class="hljs-title function_">execute</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(script,<span class="hljs-title class_">Boolean</span>.<span class="hljs-property">class</span>), <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">asList</span>(lockName),field,<span class="hljs-variable constant_">EXPIRE</span>))&#123;<br>                    <span class="hljs-title function_">resetExpire</span>();<br>                &#125;<br>            &#125;<br>        &#125;,(<span class="hljs-variable language_">this</span>.<span class="hljs-property">EXPIRE</span>*<span class="hljs-number">1000</span>)/<span class="hljs-number">3</span>);<br><br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis BigKey问题</title>
    <link href="/2023/10/22/RedisBigKey/"/>
    <url>/2023/10/22/RedisBigKey/</url>
    
    <content type="html"><![CDATA[<p>先来一张问题表</p><p><img src="/../RedisBigKey/1.png"></p><p>新闻</p><p><img src="/../RedisBigKey/2.png"></p><p>经过测试，使用 keys * 100W条数据也要花费16-30S，那么Redis单线程会阻塞其他命令</p><h3 id="生产上限制key-x2F-flushdb-x2F-flushall等危险命令"><a href="#生产上限制key-x2F-flushdb-x2F-flushall等危险命令" class="headerlink" title="生产上限制key * &#x2F; flushdb &#x2F;flushall等危险命令"></a>生产上限制key * &#x2F; flushdb &#x2F;flushall等危险命令</h3><p>解决：</p><p>redis.conf在security这一项中配置禁用上述命令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-built_in">rename</span>- <span class="hljs-keyword">command</span> <span class="hljs-built_in">keys</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-built_in">rename</span>- <span class="hljs-keyword">command</span> flushdb <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-built_in">rename</span>- <span class="hljs-keyword">command</span> flushall <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="scan命令"><a href="#scan命令" class="headerlink" title="scan命令"></a>scan命令</h3><p>Redis Scan命令及其相关命令SSCAN,HSCAN,ZSCAN命令都是用于增量遍历集合中的元素</p><ul><li>SCAN命令用于迭代当前数据库中的数据库键</li><li>SSCAN命令用于迭代SET集合中的元素</li><li>HSCAN命令用于迭代hash中的键值对</li><li>ZSCAN命令用于迭代ZSET中的元素(包括元素成员和元素分数)</li></ul><p><img src="/../RedisBigKey/3.png"></p><p>使用案例</p><p><img src="/../RedisBigKey/4.png"></p><h3 id="BigKey案例"><a href="#BigKey案例" class="headerlink" title="BigKey案例"></a>BigKey案例</h3><p>问题：</p><p><img src="/../RedisBigKey/5.png"></p><p>多大算big？来看阿里规范</p><p><img src="/../RedisBigKey/6.png"></p><p>有什么危害？</p><p><strong>内存不均，集群迁移困难</strong></p><p><strong>超时删除，大key删除作梗</strong></p><p><strong>网络流量阻塞</strong></p><p>那么如何产生bigkey的呢？</p><p><img src="/../RedisBigKey/7.png"></p><p>如何发现我们的bigkey？</p><p><img src="/../RedisBigKey/8.png"></p><p>redis-cli –bigkeys</p><p><img src="/../RedisBigKey/9.png"></p><p><img src="/../RedisBigKey/10.png"></p><p>memory usage</p><p><img src="/../RedisBigKey/11.png"></p><h3 id="如何删除bigkey？"><a href="#如何删除bigkey？" class="headerlink" title="如何删除bigkey？"></a>如何删除bigkey？</h3><p>根据不同的value类型使用不同的删除方法</p><ul><li>String</li></ul><p>一般用del，如果过于庞大使用unlink</p><ul><li>hash</li></ul><p>使用HSCAN每次获取少量field-value，再使用hdel删除每个field</p><p><img src="/../RedisBigKey/12.png"></p><p>然后剩下的list、set、zset都和hash一样进行<strong>渐进式删除</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线程池源码剖析</title>
    <link href="/2023/10/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <url>/2023/10/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>我们 <strong>JDK</strong> 中提供了一些封装好的线程池提供直接使用，比如</p><ul><li><strong>newFixedThreadPool</strong>：返回一个核心线程数为 <code>nThreads</code> 的线程池</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-keyword">new</span><span class="hljs-type">FixedThreadPool</span>(int nThreads) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="hljs-number">0</span>L, TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><strong>newSingleThreadExecutor</strong>：返回一个核心线程数为 <code>1</code> 的线程池</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-keyword">new</span><span class="hljs-type">SingleThreadExecutor</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">FinalizableDelegatedExecutorService</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>L, TimeUnit.MILLISECONDS,<span class="hljs-keyword">new</span> <span class="hljs-type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><strong>newCachedThreadPool</strong>：大同小异</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-keyword">new</span><span class="hljs-type">CachedThreadPool</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE, <span class="hljs-number">60</span>L, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-type">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面 <code>JDK</code> 提供的我们可以发现一个共识，他们其实都是调用了 <code>ThreadPoolExecutor</code> 的构造方法来进行线程池的创建</p><p>阿里巴巴Java开发手册中明确指出，<strong>『不允许』使用Executors创建线程池</strong>,因为可能会出现OOM的问题(提问：出现OOM应该怎么排查问题？)，所以，我们在生产中，一般使用 <code>ThreadPoolExecutor</code> 的构造方法自定义去创建线程池，比如：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolTest</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(<br>                <span class="hljs-number">2</span>,      <span class="hljs-comment">// 核心线程数</span><br>                <span class="hljs-number">5</span>,  <span class="hljs-comment">// 最大线程数</span><br>                <span class="hljs-number">200</span>,   <span class="hljs-comment">// 非核心工作线程在阻塞队列位置等待的时间</span><br>                TimeUnit.SECONDS,  <span class="hljs-comment">// 非核心工作线程在阻塞队列位置等待的单位</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedBlockingQueue</span>&lt;&gt;(), <span class="hljs-comment">// 阻塞队列，存放任务的地方</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>.AbortPolicy() <span class="hljs-comment">// 拒绝策略：这里有四种</span><br>        );<br><br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            MyTask task = <span class="hljs-keyword">new</span> <span class="hljs-type">MyTask</span>();<br>            executor.execute(task);<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭线程</span><br>        executor.shutdown();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Runnable</span></span> </span>&#123;<br>    @Override<br>    <span class="hljs-keyword">public</span> void run() &#123;<br>        System.out.println(<span class="hljs-string">&quot;我被执行了....&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>执行流程：</p><p><img src="/../%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90_pic/1.png"></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize, <span class="hljs-keyword">int</span> maximumPoolSize, <span class="hljs-keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler <span class="hljs-keyword">handler</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>         Executors.defaultThreadFactory(), <span class="hljs-keyword">handler</span>);<br>&#125;<br><br><span class="hljs-comment">// 执行ThreadPoolExecutor的构造方法进行初始化</span><br><span class="hljs-comment">// corePoolSize: 核心线程数</span><br><span class="hljs-comment">// maximumPoolSize: 最大线程数</span><br><span class="hljs-comment">// keepAliveTime: 非核心工作线程在阻塞队列位置等待的时间</span><br><span class="hljs-comment">// unit: 非核心工作线程在阻塞队列位置等待的时间单位</span><br><span class="hljs-comment">// workQueue: 存放任务的阻塞队列</span><br><span class="hljs-comment">// threadFactory: 线程工厂(生产线程的地方)</span><br><span class="hljs-comment">// RejectedExecutionHandler: 拒绝策略</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize, </span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-params"><span class="hljs-function">                          TimeUnit unit,</span></span><br><span class="hljs-params"><span class="hljs-function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-params"><span class="hljs-function">                          ThreadFactory threadFactory,</span></span><br><span class="hljs-params"><span class="hljs-function">                          RejectedExecutionHandler <span class="hljs-keyword">handler</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// 核心线程数可以为0</span><br>    <span class="hljs-comment">// 最大线程数不为0</span><br>    <span class="hljs-comment">// 最大线程数 大于 核心线程数</span><br>    <span class="hljs-comment">// 等待时间大于等于0</span><br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> || maximumPoolSize &lt;= <span class="hljs-number">0</span> || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || <span class="hljs-keyword">handler</span> == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-comment">// 将当前的入参赋值给成员变量</span><br>    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-keyword">this</span>.workQueue = workQueue;<br>    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-keyword">this</span>.<span class="hljs-keyword">handler</span> = <span class="hljs-keyword">handler</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们上面初始化的过程主要对入参做了一些校验，然后将方法的入参赋予给成员变量</p><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><ul><li>AbortPolicy(默认策略)</li></ul><p>简单粗暴，直接抛出异常</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbortPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() + <span class="hljs-string">&quot; rejected from &quot;</span> + e.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>CallerRunsPolicy</li></ul><p>当前拒绝策略会在线程池无法处理任务时，将任务交给调用者处理(适合用于处理比较重要的任务，不可丢失，但是实习的时候进行CR的时候听说可能会阻塞主线程)</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CallerRunsPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果当前的</span><br>        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>            r.run();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>DiscardOldestPolicy</li></ul><p>如果当前的阻塞队列满了，弹出时间最久的</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardOldestPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DiscardOldestPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>            <span class="hljs-comment">// 获取阻塞队列,弹出一个时间最久的</span><br>            e.getQueue().poll();<br>            <span class="hljs-comment">// 执行当前的</span><br>            e.execute(r);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>DiscardPolicy</li></ul><p>简单粗暴，不做任何操作</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DiscardPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>自定义拒绝策略</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRejectedExecution</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">rejectedExecution</span>(<span class="hljs-params">Runnable r, ThreadPoolExecutor executor</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;这是我自己的拒绝策略&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="其余变量"><a href="#其余变量" class="headerlink" title="其余变量"></a>其余变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 该数值代表两个意思：</span><br><span class="hljs-comment">// 高3位表示当前线程池的状态</span><br><span class="hljs-comment">// 低29位表示当前线程池工作线程的个数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">//  COUNT_BITS = 29</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br><span class="hljs-comment">// CAPACITY就是当前工作线程能记录的工作线程的最大个数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span>   <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 111：代表RUNNING状态，RUNNING可以处理任务，并且处理阻塞队列中的任务。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-comment">// 000：代表SHUTDOWN状态，不会接收新任务，正在处理的任务正常进行，阻塞队列的任务也会做完。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-comment">// 001：代表STOP状态，不会接收新任务，正在处理任务的线程会被中断，阻塞队列的任务一个不管。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-comment">// 010：代表TIDYING状态，这个状态是否SHUTDOWN或者STOP转换过来的，代表当前线程池马上关闭，就是过渡状态。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-comment">// 011：代表TERMINATED状态，这个状态是TIDYING状态转换过来的，转换过来只需要执行一个terminated方法。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 基于&amp;运算的特点，保证只会拿到ctl高三位的值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<br><span class="hljs-comment">// 基于&amp;运算的特点，保证只会拿到ctl低29位的值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<br><br></code></pre></td></tr></table></figure><p>线程池的状态变化流程图</p><p><img src="/../%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90_pic/1.png"></p><h4 id="线程池的execute方法"><a href="#线程池的execute方法" class="headerlink" title="线程池的execute方法"></a>线程池的execute方法</h4><ul><li><p>Step1：当前的线程池个数低于核心线程数，直接添加核心线程即可</p></li><li><p>Step2：当前的线程池个数大于核心线程数，将任务添加至阻塞队列中</p></li><li><p>Step3：如果添加阻塞队列失败，则需要添加非核心线程数处理任务</p></li><li><p>Step4：如果添加非核心线程数失败（满了），执行拒绝策略</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs awk">public void execute(Runnable command) &#123;<br>    <span class="hljs-regexp">//</span> 如果当前传过来的任务是null,直接抛出异常即可<br>    <span class="hljs-keyword">if</span> (command == null)<br>        throw new NullPointerException();<br>    <span class="hljs-regexp">//</span> 获取当前的数据值<br>    int c = ctl.get();<br>    <br><span class="hljs-regexp">//</span>==========================线程池第一阶段：启动核心线程数开始==================================================<br>    <span class="hljs-regexp">//</span> Step1:获取ctl低<span class="hljs-number">29</span>位的数值，与我们的核心线程数相比<br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-regexp">//</span> Step2:添加一个核心线程<br>        <span class="hljs-keyword">if</span> (addWorker(command, true))&#123;<br>            return;<br>        &#125;<br>        <span class="hljs-regexp">//</span> 更新一下当前值<br>        c = ctl.get();<br>    &#125;<br><span class="hljs-regexp">//</span>==========================线程池第一阶段：启动核心线程数结束==================================================<br>    <br>    <span class="hljs-regexp">//</span> 如果走到下面会有两种情况：<br>    <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>、核心线程数满了,需要往阻塞队列里面扔任务<br>    <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>、核心线程数满了,阻塞队列也满了,执行拒绝策略<br>    <br><span class="hljs-regexp">//</span>==========================线程池第二阶段：任务放至阻塞队列开始==================================================<br>    <span class="hljs-regexp">//</span> 判断当前的状态是不是Running的状态(RUNNING可以处理任务，并且处理阻塞队列中的任务)<br>    <span class="hljs-regexp">//</span> 如果是Running的状态,则可以将任务放至阻塞队列中<br>    <span class="hljs-regexp">//</span> 这里如果放阻塞队列失败了,证明阻塞队列满了<br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-regexp">//</span> 再次更新数值<br>        int recheck = ctl.get();<br>        <span class="hljs-regexp">//</span> 再次校验当前的线程池状态是不是Running<br>        <span class="hljs-regexp">//</span> 如果线程池状态不是Running的话,需要删除掉刚刚放的任务<br>        <span class="hljs-keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))&#123;<br>            <span class="hljs-regexp">//</span> 执行拒绝策略<br>            reject(command);<br>        &#125; <br>        <span class="hljs-regexp">//</span> 如果到这里,说明上面阻塞队列中已经有数据了<br>        <span class="hljs-regexp">//</span> 如果线程池的个数为<span class="hljs-number">0</span>的话,需要创建一个非核心工作线程去执行该任务<br>        <span class="hljs-regexp">//</span> 不能让人家堵塞着<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)&#123;<br>            addWorker(null, false);<br>        &#125;<br>    &#125;<br><span class="hljs-regexp">//</span>==========================线程池第二阶段：任务放至阻塞队列结束==================================================<br><br>    <span class="hljs-regexp">//</span> 如果走到这里的逻辑，证明上面的逻辑没走通，有以下两种情况：<br>    <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>、线程池的状态不是Running<br>    <span class="hljs-regexp">//</span>    <span class="hljs-number">1.1</span> 如果是这种情况,下面的添加非核心工作线程失败执行拒绝策略,但这个并不是这个逻辑的重点<br>    <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>、阻塞队列添加任务失败(阻塞队列满了)<br>    <span class="hljs-regexp">//</span>    <span class="hljs-number">2.1</span> 这种情况才是我们需要关心的<br>    <span class="hljs-regexp">//</span>    <span class="hljs-number">2.2</span> 阻塞队列满了,添加非核心工作线程<br>    <span class="hljs-regexp">//</span>    <span class="hljs-number">2.3</span> 若添加非核心工作线程失败,证明已经到达maximumPoolSize的限制,执行拒绝策略<br><span class="hljs-regexp">//</span>==========================线程池第三阶段：启动非核心线程数开始==================================================<br>    <span class="hljs-regexp">//</span> 添加一个非核心工作线程<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, false))<br>        <span class="hljs-regexp">//</span> 工作队列中添加任务失败,执行拒绝策略<br>        reject(command);<br><span class="hljs-regexp">//</span>==========================线程池第三阶段：启动非核心线程数结束==================================================<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="线程池的addWorker方法"><a href="#线程池的addWorker方法" class="headerlink" title="线程池的addWorker方法"></a>线程池的addWorker方法</h4><p>addWorker&#96;方法也是一个很关键的方法, 添加线程到线程池，返回 true 表示创建 Worker 成功，且启动线程。</p><p>校验</p><ul><li>校验当前线程池的状态</li><li>校验当前线程池工作线程的个数(核心线程数、最大工作线程数)</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs awk">private boolean addWorker(Runnable firstTask, boolean core) &#123;<br>    <span class="hljs-regexp">//</span> 这里主要是为了结束整个循环<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-regexp">//</span> 获取当前线程池的数值(ctl)<br>        int c = ctl.get();<br>        <br>        <span class="hljs-regexp">//</span> runStateOf:基于&amp;运算的特点，保证只会拿到ctl高三位的值<br>        int rs = runStateOf(c);<br><br><span class="hljs-regexp">//</span>==========================线程池状态判断=============================================================<br>        <span class="hljs-regexp">//</span> rs &gt;= SHUTDOWN:代表当前线程池状态为：SHUTDOWN、STOP、TIDYING、TERMINATED,线程池状态异常<br>        <span class="hljs-regexp">//</span> 但这里SHUTDOWN状态稍许不同(不会接收新任务，正在处理的任务正常进行，阻塞队列的任务也会做完)<br>        <span class="hljs-regexp">//</span> 如果当前的状态是SHUTDOWN状态并且阻塞队列任务不为空且新任务为空<br>        <span class="hljs-regexp">//</span> 需要新起一个非核心工作线程去执行任务<br>        <span class="hljs-regexp">//</span> 如果不是前面的,直接返回false即可<br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; !workQueue.isEmpty()))&#123;<br>            return false;<br>        &#125;<br><br><span class="hljs-regexp">//</span>==========================工作线程个数判断==========================================================<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-regexp">//</span> 获取当前线程池中线程的个数<br>            int wc = workerCountOf(c);<br>            <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>、如果线程池线程的个数是否超过了工作线程的最大个数<br>            <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>、core=true(核心线程)=false(工作线程)<br>            <span class="hljs-regexp">//</span> <span class="hljs-number">2.1</span> 根据当前core判断创建的是核心线程数(corePoolSize)还是非核心线程数(maximumPoolSize)<br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))&#123;<br>                return false;<br>            &#125;<br>            <span class="hljs-regexp">//</span> 尝试将线程池线程加一<br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))&#123;<br>                <span class="hljs-regexp">//</span> CAS成功后，直接退出外层循环，代表可以执行添加工作线程操作了。<br>                <span class="hljs-keyword">break</span> retry;<br>            &#125;<br>            <br>            <span class="hljs-regexp">//</span> 获取当前线程池的数值(ctl)<br>            c = ctl.get(); <br>            <span class="hljs-regexp">//</span> 获取当前线程池的状态<br>            <span class="hljs-regexp">//</span> 判断当前线程池的状态等不等于我们上面的rs<br>            <span class="hljs-regexp">//</span> 我们线程池的状态被人更改了，需要重新跑整个<span class="hljs-keyword">for</span>循环判断逻辑<br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)&#123;<br>                <span class="hljs-keyword">continue</span> retry;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-regexp">//</span> 省略下面的代码<br>&#125;<br><br></code></pre></td></tr></table></figure><p>添加线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// 下面开始真正创建线程了</span><br>    <span class="hljs-comment">// 运行标记，表示创建的 worker 是否已经启动，false未启动  true启动</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 添加标记，表示创建的 worker 是否添加到池子中了，默认false未添加，true是添加。</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//【创建 Worker，底层通过线程工厂 newThread 方法创建执行线程，指定了首先执行的任务】</span><br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>        <span class="hljs-comment">// 将新创建的 worker 节点中的线程赋值给 t</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>        <span class="hljs-comment">// 这里的判断为了防止 程序员自定义的 ThreadFactory 实现类有 bug，创造不出线程</span><br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>            <span class="hljs-comment">// 这里为什么要加全局锁？因为下面的操作是添加worker，但是万一其他调用了shotdown()或者shotdownNow()方法</span><br>            <span class="hljs-comment">// 那我到底是添加还是不添加？这是一个纠结的事情，当我们点开shotdown()或者shotdownNow()方法时，会发现也有一个</span><br>            <span class="hljs-comment">// 全局lock锁，所以加锁的原因是不想添加worker与关闭线程池冲突！</span><br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                 <span class="hljs-comment">// 获取最新线程池运行状态</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br>            <span class="hljs-comment">// 判断线程池是否为RUNNING状态，不是再【判断当前是否为SHUTDOWN状态且firstTask为空，特殊情况】</span><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                     <span class="hljs-comment">// 当线程start后，线程isAlive会返回true，这里还没开始启动线程，如果被启动了就需要报错</span><br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                    <span class="hljs-comment">//将新建的 Worker 添加到线程池中</span><br>                    workers.add(w);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                    <span class="hljs-comment">// 当前池中的线程数量是一个新高，更新 largestPoolSize</span><br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                     <span class="hljs-comment">// 添加标记置为 true</span><br>                    workerAdded = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>             <span class="hljs-comment">// 添加成功就【启动线程执行任务】</span><br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                <span class="hljs-comment">// 启动线程</span><br>                t.start();<br>                <span class="hljs-comment">// 运行标记置为 true</span><br>                workerStarted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 线程启动失败</span><br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            <span class="hljs-comment">// 清理工作，比如从线程池中移除。</span><br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWorkerFailed</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    <span class="hljs-comment">// 持有线程池全局锁，因为操作的是线程池相关的东西</span><br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//条件成立需要将 worker 在 workers 中清理出去。</span><br>        <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>)<br>            workers.remove(w);<br>        <span class="hljs-comment">// 将线程池计数 -1，相当于归还令牌。</span><br>        decrementWorkerCount();<br>        <span class="hljs-comment">// 尝试停止线程池</span><br>        tryTerminate();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//释放线程池全局锁。</span><br>        mainLock.unlock();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p><strong>这里注意一个点，SHUTDOWN 状态也能添加线程，但是要求新加的 Woker 没有 firstTask，而且当前 queue 不为空，所以创建一个线程来帮助线程池执行队列中的任务。</strong></p></li><li><p>这里为什么要加全局锁？因为下面的操作是添加worker，但是万一其他调用了shotdown()或者shotdownNow()方法，那我到底是添加还是不添加？这是一个纠结的事情，当我们点开shotdown()或者shotdownNow()方法时，会发现也有一个全局lock锁，所以加锁的原因是不想添加worker与关闭线程池冲突！</p></li></ul><h4 id="线程池的-worker-源码"><a href="#线程池的-worker-源码" class="headerlink" title="线程池的 worker 源码"></a>线程池的 worker 源码</h4><p>Woker类是ThreadPoolExecutor类的内部类，见明知意，它是承担了一个“工人”干活，也就是工作线程的责任。</p><ul><li>Worker类</li></ul><p>每个 Worker 对象有一个初始任务，启动 Worker 时优先执行，这也是造成线程池不公平的原因。Worker 继承自 AQS，本身具有锁的特性，采用独占锁模式，state &#x3D; 0 表示未被占用，&gt; 0 表示被占用，&lt; 0 表示初始状态不能被抢锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><span class="hljs-comment">// worker 内部封装的工作线程</span><br>    <span class="hljs-keyword">final</span> Thread thread;<br>    <span class="hljs-comment">// worker 第一个执行的任务，普通的 Runnable 实现类或者是 FutureTask</span><br>    Runnable firstTask;<br>    <span class="hljs-comment">// 记录当前 worker 所完成任务数量</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks;<br>    <br>    <span class="hljs-comment">// 构造方法</span><br>    Worker(Runnable firstTask) &#123;<br>        <span class="hljs-comment">// 设置AQS独占模式为初始化中状态，这个状态不能被抢占锁</span><br>       setState(-<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// firstTask不为空时，当worker启动后，内部线程会优先执行firstTask，执行完后会到queue中去获取下个任务</span><br>        <span class="hljs-built_in">this</span>.firstTask = firstTask;<br>        <span class="hljs-comment">// 使用线程工厂创建一个线程，并且【将当前worker指定为Runnable】，所以thread启动时会调用 worker.run()</span><br>        <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-comment">// 不可重入锁，重写了AQS中的方法</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>            setExclusiveOwnerThread(Thread.currentThread());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br> <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 设置state为0，开始抢锁</span><br>        setState(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><strong>Worker的工作方法run</strong></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Worker#run</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>    <span class="hljs-comment">// 调用自身的runWoker方法</span><br>    runWorker(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// Worker#runWorker</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> runWorker(Worker w) &#123;<br>    Thread wt = Thread.currentThread();<br>    <span class="hljs-comment">// 获取 worker 的 firstTask</span><br>    Runnable <span class="hljs-keyword">task</span> = w.firstTask;<br>    <span class="hljs-comment">// 引用置空，【防止复用该线程时重复执行该任务】</span><br>    w.firstTask = <span class="hljs-keyword">null</span>;<br><span class="hljs-comment">// 初始化 worker 时设置 state = -1，表示不允许抢占锁</span><br>    <span class="hljs-comment">// 这里需要设置 state = 0 和 exclusiveOwnerThread = null，可以被中断</span><br>    w.unlock(); <br>   <span class="hljs-comment">// true 表示发生异常退出，false 表示正常退出。</span><br>    <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// firstTask 不是 null 就直接运行，否则去 queue 中获取任务</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">task</span> != <span class="hljs-keyword">null</span> || (<span class="hljs-keyword">task</span> = getTask()) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// worker 加锁，shutdown 状态下不允许线程被中断</span><br>            w.lock();<br>            <span class="hljs-comment">// 说明线程池状态大于 STOP，目前处于 STOP/TIDYING/TERMINATION，此时给线程一个中断信号</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                <span class="hljs-comment">// 线程不是处于中断的情况</span><br>                !wt.isInterrupted())<br>                 <span class="hljs-comment">// 中断线程，设置线程的中断标志位为 true</span><br>                wt.interrupt();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 任务执行前的回调，空实现，可以在子类中自定义</span><br>                beforeExecute(wt, <span class="hljs-keyword">task</span>);<br>                Throwable thrown = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 真正执行任务</span><br>                    <span class="hljs-keyword">task</span>.run();<br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                     <span class="hljs-comment">// 钩子方法，【任务执行的后置处理】</span><br>                    afterExecute(<span class="hljs-keyword">task</span>, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 将局部变量task置为null，代表任务执行完成</span><br>                <span class="hljs-keyword">task</span> = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-comment">// 更新worker完成任务数量</span><br>                w.completedTasks++;<br>                <span class="hljs-comment">// 解锁</span><br>                w.unlock();<br>            &#125;<br>        &#125;<br>         <span class="hljs-comment">// getTask()方法返回null时会走到这里，表示queue为空并且线程空闲超过保活时间，【当前线程执行退出逻辑】</span><br>        completedAbruptly = <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 正常退出 completedAbruptly = false</span><br>       <span class="hljs-comment">// 异常退出 completedAbruptly = true，【从 task.run() 内部抛出异常】时，跳到这一行</span><br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="processWorkerExit-工作线程退出方法"><a href="#processWorkerExit-工作线程退出方法" class="headerlink" title="processWorkerExit()工作线程退出方法"></a><strong>processWorkerExit()工作线程退出方法</strong></h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 正常退出 completedAbruptly = false，异常退出为 true</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWorkerExit</span>(Worker w, <span class="hljs-type">boolean</span> completedAbruptly) &#123;<br>    <span class="hljs-comment">// 条件成立代表当前 worker 是发生异常退出的，task 任务执行过程中向上抛出异常了</span><br>    <span class="hljs-keyword">if</span> (completedAbruptly) <br>        <span class="hljs-comment">// 从异常时到这里 ctl 一直没有 -1，需要在这里 -1</span><br>        <span class="hljs-title function_">decrementWorkerCount</span>();<br><br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-variable">this</span>.<span class="hljs-property">mainLock</span>;<br>    <span class="hljs-comment">// 加锁</span><br>    mainLock.<span class="hljs-property">lock</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 将当前 worker 完成的 task 数量，汇总到线程池的 completedTaskCount</span><br>        completedTaskCount += w.<span class="hljs-property">completedTasks</span>;<br><span class="hljs-comment">// 将 worker 从线程池中移除</span><br>        workers.<span class="hljs-property">remove</span>(w);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.<span class="hljs-property">unlock</span>();<span class="hljs-comment">// 解锁</span><br>    &#125;<br><span class="hljs-comment">// 尝试停止线程池，唤醒下一个线程</span><br>    <span class="hljs-title function_">tryTerminate</span>();<br><br>    <span class="hljs-type">int</span> c = ctl.<span class="hljs-property">get</span>();<br>    <span class="hljs-comment">// 线程池不是停止状态就应该有线程运行【担保机制】</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">runStateLessThan</span>(c, STOP)) &#123;<br>        <span class="hljs-comment">// 正常退出的逻辑，是对空闲线程回收，不是执行出错</span><br>        <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<br>            <span class="hljs-comment">// 根据是否回收核心线程确定【线程池中的线程数量最小值】</span><br>            <span class="hljs-type">int</span> <span class="hljs-built_in">min</span> = allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>            <span class="hljs-comment">// 最小值为 0，但是线程队列不为空，需要一个线程来完成任务担保机制</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span> == <span class="hljs-number">0</span> &amp;&amp; !workQueue.<span class="hljs-property">isEmpty</span>())<br>                <span class="hljs-built_in">min</span> = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 线程池中的线程数量大于最小值可以直接返回</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_">workerCountOf</span>(c) &gt;= <span class="hljs-built_in">min</span>)<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 执行 task 时发生异常，有个线程因为异常终止了，需要添加</span><br>        <span class="hljs-comment">// 或者线程池中的数量小于最小值，这里要创建一个新 worker 加进线程池</span><br>        <span class="hljs-title function_">addWorker</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="线程复用的原理"><a href="#线程复用的原理" class="headerlink" title="线程复用的原理"></a>线程复用的原理</h3><p>在线程池中，同一个线程可以从阻塞队列中不断获取新任务来执行，其核心原理在于线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中不停的检查是否有任务需要被执行，如果有则直接执行，也就是调用任务中的 run 方法，将 run 方法当成一个普通的方法执行，通过这种方式将只使用固定的线程就将所有任务的 run 方法串联起来。</p><ul><li>源码剖析</li></ul><p>其实就是runWorker()方法</p><p>省略掉部分和复用无关的代码之后，代码如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> runWorker(Worker w) &#123;<br>    Thread wt = Thread.currentThread();<br>    Runnable <span class="hljs-keyword">task</span> = w.firstTask;<br>    w.firstTask = <span class="hljs-keyword">null</span>;<br>    w.unlock(); <span class="hljs-comment">// 释放锁 设置work的state=0 允许中断</span><br>    <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//一直执行 如果task不为空 或者 从队列中获取的task不为空</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">task</span> != <span class="hljs-keyword">null</span> || (<span class="hljs-keyword">task</span> = getTask()) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">task</span>.run();<span class="hljs-comment">//执行task中的run方法</span><br>            &#125;<br>        &#125;<br>        completedAbruptly = <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//1.将 worker 从数组 workers 里删除掉</span><br>        <span class="hljs-comment">//2.根据布尔值 allowCoreThreadTimeOut 来决定是否补充新的 Worker 进数组 workers</span><br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，实现线程复用的逻辑主要在一个不停循环的 while 循环体中。</p><ul><li>通过获取 Worker 的 firstTask 或者通过 getTask 方法从 workQueue 中获取待执行的任务</li><li>直接通过 <code>task.run()</code> 来执行具体的任务（而不是新建线程）</li></ul><p>在这里，我们找到了线程复用最终的实现，通过取 Worker 的 firstTask 或者 getTask 方法从 workQueue 中取出了新任务，并直接调用 Runnable 的 run 方法来执行任务，也就是如之前所说的，每个线程都始终在一个大循环中，反复获取任务，然后执行任务，从而实现了线程的复用。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SPI</title>
    <link href="/2023/10/11/SPI/"/>
    <url>/2023/10/11/SPI/</url>
    
    <content type="html"><![CDATA[<h3 id="SPI是什么"><a href="#SPI是什么" class="headerlink" title="SPI是什么"></a>SPI是什么</h3><p><code>SPI</code> 全称 <code>Service Provider Interface</code> ，是 <code>Java</code> 提供的一套用来被第三方实现或者扩展的 <code>API</code>，它可以用来启用框架扩展和替换组件。</p><p><img src="/../SPI_pic/1.png"></p><p>Java SPI实际上是基于<strong>接口+策略模式+配置文件</strong>组合实现的动态加载机制</p><p><code>Java SPI</code> 就是提供这样的一个机制：为某个接口寻找服务实现的机制。</p><p>将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。</p><p>所以 <code>SPI</code> 的核心思想就是<strong>解耦</strong>。</p><h3 id="SPI与API的区别"><a href="#SPI与API的区别" class="headerlink" title="SPI与API的区别"></a>SPI与API的区别</h3><p><img src="/../SPI_pic/5.png"></p><h3 id="SPI四要素"><a href="#SPI四要素" class="headerlink" title="SPI四要素"></a>SPI四要素</h3><ul><li><p>SPI<strong>接口</strong>：为服务提供者实现类约定的接口或抽象类</p></li><li><p>SPI<strong>实现类</strong>：实际提供服务的实现类</p></li><li><p>SPI<strong>配置</strong>：Java SPI 机制约定的配置文件，<strong>提供查找服务实现类的逻辑</strong>。配置文件<strong>必须置于 META-INF&#x2F;services 目录中</strong>，并且，文件名应与服务提供者接口的完全限定名保持一致。文件中的每一行都有一个实现服务类的详细信息，同样是服务提供者类的完全限定名称</p></li><li><p><strong>ServiceLoader</strong>：Java SPI 的核心类，<strong>用于加载 SPI 实现类</strong>。ServiceLoader 中有各种实用方法来获取特定实现、迭代它们或重新加载服务。</p></li></ul><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="SPI接口"><a href="#SPI接口" class="headerlink" title="SPI接口"></a>SPI接口</h4><p>首先，需要定义一个 SPI 接口，和普通接口并没有什么差别。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">city</span> &#123;<br>    <span class="hljs-function">String <span class="hljs-title">cityName</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SPI实现类"><a href="#SPI实现类" class="headerlink" title="SPI实现类"></a>SPI实现类</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChenzhouCity</span> <span class="hljs-keyword">implements</span> city&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">cityName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;郴州&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangSha</span> <span class="hljs-keyword">implements</span> city&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">cityName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;长沙&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>service 传入的是期望加载的 SPI 接口类型 到目前为止，定义接口，并实现接口和普通的 Java 接口实现没有任何不同。</p><h3 id="SPI配置"><a href="#SPI配置" class="headerlink" title="SPI配置"></a>SPI配置</h3><p>如果想通过 Java SPI 机制来发现服务，就需要在 SPI 配置中约定好发现服务的逻辑。配置文件必须置于 META-INF&#x2F;services 目录中，并且，文件名应与服务提供者接口的完全限定名保持一致。文件中的每一行都有一个实现服务类的详细信息，同样是服务提供者类的完全限定名称。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">spi<span class="hljs-selector-class">.ChangSha</span><br>spi.ChenzhouCity<br></code></pre></td></tr></table></figure><p><img src="/../SPI_pic/2.png"></p><p><img src="/../SPI_pic/3.png"></p><h3 id="ServiceLoader"><a href="#ServiceLoader" class="headerlink" title="ServiceLoader"></a>ServiceLoader</h3><p>完成了上面的步骤，就可以通过 ServiceLoader 来加载服务。示例如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> SPIDemo &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        ServiceLoader&lt;city&gt; serviceLoader = ServiceLoader.<span class="hljs-keyword">load</span>(city.<span class="hljs-keyword">class</span>);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;============ Java SPI 测试============&quot;);<br>        serviceLoader.<span class="hljs-keyword">forEach</span>(loader -&gt; <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(loader.cityName()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="/../SPI_pic/4.png"></p><h3 id="SPI作用"><a href="#SPI作用" class="headerlink" title="SPI作用"></a>SPI作用</h3><p>举例：日志</p><p>SLF4J （Simple Logging Facade for Java）是 Java 的一个日志门面（接口），其具体实现有几种，比如：Logback、Log4j、Log4j2 等等，而且还可以切换，在切换日志具体实现的时候我们是不需要更改项目代码的，只需要在 Maven 依赖里面修改一些 pom 依赖就好了。</p><p><img src="/../SPI_pic/6.png"></p><p>这就是依赖 SPI 机制实现的，那我们接下来就实现一个简易版本的日志框架。</p><h3 id="生产场景"><a href="#生产场景" class="headerlink" title="生产场景"></a>生产场景</h3><p>相信大家在生产上都使用过 <code>JDBC</code>，没错，我们的 <code>JDBC</code> 实际上也使用了 <code>SPI</code></p><p>我们看 <code>DriverManager</code> 的静态方法 <code>loadInitialDrivers</code>：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"> static &#123;<br>     <span class="hljs-comment">// 初始化加载</span><br>     <span class="hljs-built_in">loadInitialDrivers</span>();<br>     <span class="hljs-built_in">println</span>(&quot;JDBC DriverManager initialized&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们查看下 <code>loadInitialDrivers</code> 方法的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadInitialDrivers</span>()</span> &#123;<br>    String drivers;<br>    AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span>()</span> &#123;<br>            <span class="hljs-comment">// SPI的加载机制</span><br>            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.<span class="hljs-keyword">class</span>);<br>            <span class="hljs-comment">// 迭代</span><br>            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">while</span>(driversIterator.hasNext()) &#123;<br>                    driversIterator.next();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;);   <br>&#125;<br></code></pre></td></tr></table></figure><p>当然，这里我们需要引入下面的 <code>MAVEN</code> 依赖，不然 <code>Driver.class</code> 的实现类为空</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.18<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.study.spring.spi;<br><br><span class="hljs-keyword">import</span> java.sql.Driver;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.ServiceLoader;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ServiceLoader&lt;Driver&gt; serviceLoader = ServiceLoader.load(Driver.class);<br><br>        <span class="hljs-keyword">for</span> (Iterator&lt;Driver&gt; iterator = serviceLoader.iterator(); iterator.hasNext(); ) &#123;<br><br>            <span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> iterator.next();<br><br>            System.out.println(driver.getClass().getPackage() + <span class="hljs-string">&quot; ------&gt; &quot;</span> + driver.getClass().getName());<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">package com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.cj</span><span class="hljs-selector-class">.jdbc</span>, JDBC, version <span class="hljs-number">4.2</span> ------&gt; com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.cj</span><span class="hljs-selector-class">.jdbc</span>.Driver<br></code></pre></td></tr></table></figure><p>从这里的输出我们可以得出一个假设：我们引入的 <code>JDBC</code> 包里面，存在上述 <code>SPI</code> 机制的 <code>txt</code> 文件名称为: <strong>java.sql.Driver</strong> 且内容为：<strong>com.mysql.cj.jdbc.Driver</strong></p><p>我们直接去引入的包里面搜索一下：</p><p><img src="/../SPI_pic/7.png"></p><h3 id="JDK标准"><a href="#JDK标准" class="headerlink" title="JDK标准"></a>JDK标准</h3><p> <strong>JDK SPI 机制 ServiceLoader 约定好的标准</strong>：这里先大概解释一下：Java 中的 SPI 机制就是在每次类加载的时候会先去找到 class 相对目录下的 <code>META-INF</code> 文件夹下的 services 文件夹下的文件，将这个文件夹下面的所有文件先加载到内存中，然后根据这些文件的文件名和里面的文件内容找到相应接口的具体实现类，找到实现类后就可以通过反射去生成对应的对象，保存在一个 list 列表里面，所以可以通过迭代或者遍历的方式拿到对应的实例对象，生成不同的实现。</p><p>所以会提出一些规范要求：文件名一定要是接口的全类名，然后里面的内容一定要是实现类的全类名，实现类可以有多个，直接换行就好了，多个实现类的时候，会一个一个的迭代加载。</p><p>接下来同样将 <code>service-provider</code> 项目打包成 jar 包，这个 jar 包就是服务提供方的实现。通常我们导入 maven 的 pom 依赖就有点类似这种，只不过我们现在没有将这个 jar 包发布到 maven 公共仓库中，所以在需要使用的地方只能手动的添加到项目中。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Bean的生命周期</title>
    <link href="/2023/10/05/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2023/10/05/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p>先来一张全局图</p><p><img src="/..%5CBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F_pic%5C1.png"></p><p>再来一个小demo</p><p>结构如下</p><p><img src="/..%5CBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F_pic%5C2.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanNameAware</span> , BeanFactoryAware, ApplicationContextAware, InitializingBean &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//构造函数 </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;User的构造方法执行了&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//依赖注入</span><br>    <span class="hljs-meta">@Value(&quot;彭建飞&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setName方法执行了&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">//BeanNameAware接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanName</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setBeanName方法执行了&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">//BeanFactoryAware接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;setBeanFactory方法执行了&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">//ApplicationContextAware接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;setApplicationContext方法执行了&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@PostConstruct</span> <span class="hljs-comment">//自定义增强，属于初始化方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;自定义init方法执行了&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">//InitializingBean，属于初始化方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;afterPropertiesSet方法执行了&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;destroy执行了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-keyword">if</span>(beanName.equals(<span class="hljs-string">&quot;user&quot;</span>))&#123;<br>            System.out.println(<span class="hljs-string">&quot;postProcessBeforeInitialization方法执行了-&gt;user对象初始化方法前开始增强...&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-keyword">if</span>(beanName.equals(<span class="hljs-string">&quot;user&quot;</span>))&#123;<br>            System.out.println(<span class="hljs-string">&quot;postProcessBeforeInitialization方法执行了-&gt;user对象初始化方法后开始增强...&quot;</span>);<br>            <span class="hljs-comment">//cglib代理对象</span><br>            <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>            <span class="hljs-comment">//设置需要代理的类</span><br>            enhancer.setSuperclass(bean.getClass());<br>            <span class="hljs-comment">//设置回调方法，增强方法</span><br>            enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object o, Method method, Object[] objects)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                    System.out.println(<span class="hljs-string">&quot;执行增强方法&quot;</span>);<br>                    <span class="hljs-keyword">return</span> method.invoke(method,objects);<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Component</span><br><span class="hljs-variable">@ComponentScan</span>(<span class="hljs-string">&quot;com.guigu.beanlife/lifecycle&quot;</span>)<br>public class SpringConfig &#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> BeanLifeTest &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        AnnotationConfigApplicationContext ctx = <span class="hljs-built_in">new</span> AnnotationConfigApplicationContext(SpringConfig.<span class="hljs-keyword">class</span>);<br>        <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> = ctx.getBean(<span class="hljs-keyword">User</span>.<span class="hljs-keyword">class</span>);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">user</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">User的构造方法执行了<br><span class="hljs-keyword">set</span>Name方法执行了<br><span class="hljs-keyword">set</span>BeanName方法执行了<br><span class="hljs-keyword">set</span>BeanFactory方法执行了<br><span class="hljs-keyword">set</span>ApplicationContext方法执行了<br>postProcessBeforeInitialization方法执行了-&gt;user对象初始化方法前开始增强<span class="hljs-string">...</span><br>自定义init方法执行了<br>afterPropertiesSet方法执行了<br>postProcessBeforeInitialization方法执行了-&gt;user对象初始化方法后开始增强<span class="hljs-string">...</span><br>User的构造方法执行了<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/..%5CBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F_pic%5C3.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么要垂直分表</title>
    <link href="/2023/09/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8/"/>
    <url>/2023/09/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><img src="/..%5C%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8%5C1.png"></p><p>在以前，一张核心表的字段可能有上百个字段，这种肯定是有问题的，至于什么问题，后面分析</p><h3 id="什么是垂直分表"><a href="#什么是垂直分表" class="headerlink" title="什么是垂直分表"></a>什么是垂直分表</h3><p>垂直分表则是将一张大表按“列”拆分为两张以上的小标，通过主外键关联来获取数据。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>这是一张商品表拆分前与拆分后</p><p><img src="/..%5C%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8%5C2.png"></p><p>拆分后的SQL变换</p><p><img src="/..%5C%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8%5C3.png"></p><h3 id="拆表原因"><a href="#拆表原因" class="headerlink" title="拆表原因"></a>拆表原因</h3><p>先来看我们的InnoDB的存储结构</p><p><img src="/..%5C%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8%5C4.png"></p><p>我们每一页(Page)默认的大小为16K，保存我们 页的叫做区(Extent)(1M)，我们一个区能够存储64个页，我们的每一页存储<strong>行数据</strong>，我们的InnoDB 1.0版本之后，引入了一个<strong>压缩页</strong>，这比之前可以占用更小的空间，有压缩就有解压缩，在我们的跨页检索中，压缩和解压缩是效率不高的，所以我们的每一页尽可能多的存储一些行数据，这就是我们的理论支撑。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="/..%5C%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8%5C2.png"></p><p>假如有一亿条数据，每一条数据占用1K大小，那么此时需要625W页，做了垂直切分，小标64字节&#x2F;行，存储小标需要39W页。</p><p><img src="/..%5C%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8%5C5.png"></p><p>假如上面sql中的商品标题因为某种原因没有走索引，那么需要625W页全部扫描，那么我们拆表之后39W页效率就比之前提升了16倍</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过将重要字段单独剥离出一张小表，让每一页能够容纳更多的行，进而缩小数据扫描的范围，达到提高执行效率的目的</p><h3 id="触发垂直分表的条件"><a href="#触发垂直分表的条件" class="headerlink" title="触发垂直分表的条件"></a>触发垂直分表的条件</h3><p>单表数据量未来可能千万、字段超过20个，并且包含了超长的Varchar、CLOB、BLOB等字段</p><h3 id="小标的字段"><a href="#小标的字段" class="headerlink" title="小标的字段"></a>小标的字段</h3><p><img src="/..%5C%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8%5C6.png"></p><h3 id="大表的字段"><a href="#大表的字段" class="headerlink" title="大表的字段"></a>大表的字段</h3><p><img src="/..%5C%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8%5C7.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM实践问题排查</title>
    <link href="/2023/09/09/JVM%E5%AE%9E%E8%B7%B5%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <url>/2023/09/09/JVM%E5%AE%9E%E8%B7%B5%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="CPU突然飙高如何排查"><a href="#CPU突然飙高如何排查" class="headerlink" title="CPU突然飙高如何排查"></a>CPU突然飙高如何排查</h3><p><img src="D:\hexo\blog\source\jvm实践问题排查_pic\1.png"></p><ul><li>top</li></ul><p><img src="D:\hexo\blog\source\jvm实践问题排查_pic\2.png"></p><ul><li><p>ps命令查看进程及包含的线程和CPU情况</p><p><img src="D:\hexo\blog\source\jvm实践问题排查_pic\3.png"></p></li><li><p>jstack打印各线程情况</p></li></ul><p>根据刚刚的线程和CPU情况讲对应的16进制的线程ID去查找对应经常，观看日志信息，分析是哪一行代码即可</p><h3 id="JVM常见调优参数"><a href="#JVM常见调优参数" class="headerlink" title="JVM常见调优参数"></a>JVM常见调优参数</h3><ul><li>堆空间大小</li></ul><p><img src="D:\hexo\blog\source\jvm实践问题排查_pic\4.png"></p><ul><li>虚拟机栈大小</li></ul><p><img src="D:\hexo\blog\source\jvm实践问题排查_pic\5.png"></p><ul><li>年轻代及老年代</li></ul><p><img src="D:\hexo\blog\source\jvm实践问题排查_pic\6.png"></p><ul><li>设置垃圾收集器</li></ul><p><img src="D:\hexo\blog\source\jvm实践问题排查_pic\7.png"></p><h3 id="Java内存泄漏排查"><a href="#Java内存泄漏排查" class="headerlink" title="Java内存泄漏排查"></a>Java内存泄漏排查</h3><p><img src="D:\hexo\blog\source\jvm实践问题排查_pic\8.png"></p><p><img src="D:\hexo\blog\source\jvm实践问题排查_pic\9.png"></p><ul><li>获取dump文件</li></ul><p><img src="D:\hexo\blog\source\jvm实践问题排查_pic\10.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HashMap</title>
    <link href="/2023/09/08/HashMap/"/>
    <url>/2023/09/08/HashMap/</url>
    
    <content type="html"><![CDATA[<h3 id="Put方法流程"><a href="#Put方法流程" class="headerlink" title="Put方法流程"></a>Put方法流程</h3><p><img src="/..%5Chashmap_pic%5C1.png"></p><p><img src="/..%5Chashmap_pic%5C2.png"></p><p>JDK1.8 之前 HashMap 由 数组+链表 组成的，<strong>数组</strong>是 HashMap 的<strong>主体</strong>，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度<strong>大于等于</strong>阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><p><strong>链表长度大于等于8并且数组长度大于64才会转化为红黑树，否则会首先进行数组克隆</strong></p><h3 id="HashMap扩容流程"><a href="#HashMap扩容流程" class="headerlink" title="HashMap扩容流程"></a>HashMap扩容流程</h3><p><img src="/..%5Chashmap_pic%5C3.png"></p><p><img src="/..%5Chashmap_pic%5C4.png"></p><h3 id="HashMap的寻址算法"><a href="#HashMap的寻址算法" class="headerlink" title="HashMap的寻址算法"></a>HashMap的寻址算法</h3><p><img src="/..%5Chashmap_pic%5C5.png"></p><p><img src="/..%5Chashmap_pic%5C6.png"></p><h3 id="HashMap在1-7版本下的死循环问题"><a href="#HashMap在1-7版本下的死循环问题" class="headerlink" title="HashMap在1.7版本下的死循环问题"></a>HashMap在1.7版本下的死循环问题</h3><p><img src="/..%5Chashmap_pic%5C7.png"></p><p><img src="/..%5Chashmap_pic%5C8.png"></p><p><img src="/..%5Chashmap_pic%5C9.png"></p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap是一种线程安全的高效Map集合</p><p>底层数据结构：</p><ul><li>JDK1.7底层采用<strong>分段的数组</strong>+<strong>链表</strong>实现</li><li>JDK1.8采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树</li></ul><p><strong>1.7版本</strong></p><p><img src="/..%5Chashmap_pic%5C10.png"></p><p><img src="/..%5Chashmap_pic%5C11.png"></p><p>有默认16个segment数组，当进行put操作时，会根据hash运算查找是哪个segment数组，然后会获取ReentrantLock，当获取到锁时，再通过hash值定位hashEntry数组下标，然后插入</p><p><strong>1.8版本的</strong></p><p>放弃了Segment臃肿的设计，数据结构跟hashMap的数据结构是一样的：数组+链表&#x2F;红黑树，采用<strong>CAS+Synchronized</strong>来保证并发安全进行实现</p><ul><li>CAS控制数组节点的添加(谁能用CAS添加成功了就成功了)</li><li>Synchronized只锁定当前链表或红黑树树的首节点，只要hash不冲突，就不会产生并发的问题，效率的到提升</li></ul><p><img src="/..%5Chashmap_pic%5C12.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/..%5Chashmap_pic%5C13.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分库分表</title>
    <link href="/2023/09/07/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <url>/2023/09/07/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h3><ul><li><p>前提，项目业务数据越来越多，或者业务发展比较迅速(单表的数据量达<strong>1000W</strong>或<strong>10G</strong>以后)</p></li><li><p>优化已经解决不了性能问题(主从读写分离、查询索引…)</p></li><li><p>IO瓶颈(磁盘IO、网络IO)、CPU瓶颈(聚合查询、连接数太多)</p></li></ul><h3 id="拆分策略"><a href="#拆分策略" class="headerlink" title="拆分策略"></a>拆分策略</h3><ul><li>垂直<ul><li>垂直分库</li><li>垂直分表</li></ul></li><li>水平<ul><li>水平分库</li><li>水平分表</li></ul></li></ul><p><img src="/../%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8_pic/1.png"></p><h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>以表为依据，<strong>根据业务</strong>将不同表拆分到不同库中</p><p><img src="/../%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8_pic/2.png"></p><p>特点：</p><ul><li>按业务对数据分级管理、维护、监控、扩展</li><li>在高并发下，提高磁盘IO和数据量连接数</li></ul><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>以字段为依据，根据字段属性将不同字段拆分到不同表中。</p><p>特点：</p><ul><li>冷热数据分离</li><li>减少IO过度争抢，两表互不影响</li></ul><p><img src="/../%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8_pic/3.png"></p><h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><p>将一个库的数据拆分到多个库中</p><p><img src="/../%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8_pic/4.png"></p><p>特点：</p><ul><li>解决了单库大数量，高并发的性能瓶颈问题</li><li>提高了系统的稳定性和可用性</li></ul><p>那么一个Java应用如何知道是哪个库呢？</p><p>这时候就需要<strong>路由</strong></p><ul><li>根据ID结点取模</li><li>按ID范围路由，节点1(1-100W)，节点2(100W-200W)</li></ul><h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p>将一个表的数据拆分到多个表中(可以在同一个库内)</p><p><img src="/../%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8_pic/5.png"></p><p>特点：</p><ul><li>优化单一表数据量过大而产生的性能问题</li><li>避免IO争抢并减少锁表的几率</li></ul><h3 id="新技术带来的新问题"><a href="#新技术带来的新问题" class="headerlink" title="新技术带来的新问题"></a>新技术带来的新问题</h3><p><img src="/../%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8_pic/6.png"></p><p>中间件：mycat、sharding-sphere</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/2023/09/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/2023/09/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><p><img src="/../%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF_pic/10.png"></p><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="/../%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF_pic/11.png"></p><h3 id="有哪些常见队列"><a href="#有哪些常见队列" class="headerlink" title="有哪些常见队列"></a>有哪些常见队列</h3><p><img src="/../%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF_pic/12.png"></p><p><img src="/../%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF_pic/13.png"></p><h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><p><img src="/../%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF_pic/1.png"></p><h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p><img src="/../%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF_pic/2.png"></p><h3 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h3><p><img src="/../%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF_pic/6.png"></p><p><img src="/../%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF_pic/3.png"></p><p><img src="/../%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF_pic/4.png"></p><p><img src="/../%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF_pic/5.png"></p><p>这个@Async注解的使用在实习的时候坤哥代码也有用到过，相对来说用起来更加优雅</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/../%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF_pic/9.png"></p><h3 id="如何控制某个方法允许并发访问线程数量"><a href="#如何控制某个方法允许并发访问线程数量" class="headerlink" title="如何控制某个方法允许并发访问线程数量"></a>如何控制某个方法允许并发访问线程数量</h3><p>Semaphore [ ‘scme ,for]信号量，是JUC包下的一个工具类，底层是AQS，我们可以通过其限制执行的线程数量使用场景:</p><p>通常用于那些资源有明确访问数量限制的场景，常用于限流。</p><p><img src="/../%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF_pic/8.png"></p><p>在多线程中提供了一个工具类Semaphore，信号量。在并发的情况下，可以控制方法的访问量</p><ul><li>创建Semaphore对象，可以给一个容量</li><li>acquire()可以请求一个信号量，这时候的信号量个数-1</li><li>release()释放一个信号量，此时信号量个数+1</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>StampedLock</title>
    <link href="/2023/09/05/StampedLock/"/>
    <url>/2023/09/05/StampedLock/</url>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>StampedLock(邮戳锁，stamp–戳记，long类型)是JDK1.8中新增的一个读写锁，也是对JDK1.5的读写锁ReentrantReadWriteLock的优化。</p><p>stamp代表了锁的状态，当stamp返回0时，表示线程获取失败。并且，当释放锁或者转换锁的时候，都要传入最初获取的stamp值。</p><h3 id="锁饥饿问题"><a href="#锁饥饿问题" class="headerlink" title="锁饥饿问题"></a>锁饥饿问题</h3><p>ReentrantReadWriteLock实现了读写分离，但是一旦读操作比较多的时候，想要获取写锁就变得比较困难了，假如当前1000个线程，999个读，1个写，有可能999个读取线程长时间抢到了锁，那1个写线程就悲剧了</p><p><strong>因为当前有可能会一直存在读锁，而无法获得写锁</strong>，根本没机会写，o(.-…)o</p><p>如何解决锁饥饿问题？</p><p>使用“公平”策略可以一定程度上缓解这个问题，但是“公平”是以牺牲系统吞吐量为代价的</p><p>所以，<strong>StampedLock类的乐观读锁闪亮登场</strong></p><h3 id="读写锁问题与邮戳锁由来"><a href="#读写锁问题与邮戳锁由来" class="headerlink" title="读写锁问题与邮戳锁由来"></a>读写锁问题与邮戳锁由来</h3><p>ReentrantReadWriteLock</p><p>允许多个线程同时读，但是只允许一个线程写，在线程获取到写锁的时候，其他写操作和读操作都会处于阻塞状态，读锁和写锁也是互斥的，所以在读的时候是不允许写的，读写锁比传统的synchronized速度要快很多，原因就是在于<strong>ReentrantReadWriteLock支持读并发，读读可以共享</strong></p><p>StampedLock横空出世</p><p>ReentrantReadWriteLock的读锁被占用的时候，其他线程尝试获取写锁的时候会被阻塞。但是，StampedLock采取乐观获取锁后，其他线程尝试获取写锁时不会被阻塞，这其实是对读锁的优化，所以，<strong>在获取乐观读锁后，还需要对结果进行校验。</strong></p><p>一句话：对短的只读代码段，使用乐观锁模式通常可以减少争用并提高代码吞吐量</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>所有获取锁的方法，都返回一个邮戳(Stamp） , Stamp为零表示获取失败，其余都表示成功;</li><li>所有释放锁的方法，都需要一个邮戳(Stamp),这个Stamp必须是和成功获取锁时得到的Stamp一致;</li><li>stampedLock是不可重入的，危险(如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁)</li></ul><p>三种访问模式</p><ul><li>Reading（读模式悲观）:功能和ReentrantReadWriteLock的读锁类似</li><li>Writing (写模式）:功能和ReentrantRedWriteLock的写锁类似</li><li>Optimistic reading(乐观读模式):无锁机制，类似于数据库中的乐观锁，<br>支持读写并发，<strong>很乐观认对读取时没人修改，假如被修改再实现升级为悲观读模式</strong></li></ul><p><img src="D:\hexo\blog\source\读写锁_pic\8.png"></p><p>如果乐观读过程中因为被修改了，那么乐观读应该修改为悲观读</p><p><img src="D:\hexo\blog\source\读写锁_pic\7.png"></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><img src="D:\hexo\blog\source\读写锁_pic\9.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ReentrantReadWriteLock</title>
    <link href="/2023/09/05/%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <url>/2023/09/05/%E8%AF%BB%E5%86%99%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h3 id="读写锁定义"><a href="#读写锁定义" class="headerlink" title="读写锁定义"></a>读写锁定义</h3><p>读写锁定义为：一个资源能够被<strong>多个读线程</strong>访问，或者被<strong>一个写线程</strong>访问，但是<strong>不能同时存在</strong>读写线程(<strong>读写互斥、读读共享</strong>)</p><h3 id="锁演化过程"><a href="#锁演化过程" class="headerlink" title="锁演化过程"></a>锁演化过程</h3><p><img src="D:\hexo\blog\source\读写锁_pic\1.png"></p><p><strong>它只允许读读共存，而读写和写写依然是互斥的</strong>，大多实际场景是<strong>“读&#x2F;读”线程间并不存在互斥关系</strong>，只有”读&#x2F;写”线程或”写&#x2F;写”线程间的操作需要互斥的。因此引入ReentrantReadWriteLock。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一个ReentrantReadWriteLock同时只能存在一个写锁但是可以存在多个读锁，但是不能同时存在写锁和读锁，即<strong>一个资源可以被多个读操作访问或一个写操作访问</strong>，但两者不能同时进行。</p><p>只有在读多写少情景之下，读写锁才具有较高的性能体现</p><h3 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h3><p>ReentrantReadWriteLock锁降级：将写入锁降级为读锁(类似Linux文件读写权限理解，就像写权限要高于读权限一样)锁的严苛程度变强叫做升级，反之叫做降级</p><p><img src="D:\hexo\blog\source\读写锁_pic\2.png"></p><p>写锁的降级，降级成为了读锁</p><p>1.如果一个线程持有了写锁，在没有释放写锁的情况下，它还可以继续获得读锁，这就是写锁的降级</p><p>2.规则惯例，先获取写锁，然后获取读锁，再释放写锁的次序</p><p>3.如果释放了写锁，那么就完全转换为读锁</p><p><img src="D:\hexo\blog\source\读写锁_pic\3.png"></p><p>重入还允许通过获取写入锁定，然后读取锁然后释放写锁从写锁到读锁，但是，从读锁升级到写锁是不可能的。</p><p><img src="D:\hexo\blog\source\读写锁_pic\4.png"></p><p><img src="D:\hexo\blog\source\读写锁_pic\5.png"></p><h3 id="降级总结"><a href="#降级总结" class="headerlink" title="降级总结"></a>降级总结</h3><p>如果一个线程占有了写锁，在不释放写锁的情况下，它还能占有读锁(<strong>注意这里是同一个线程！！！</strong>)</p><p>读没有完成的时候无法获得写锁，必须要等着读锁读完后才有机会(不然我刚读的A是1，你写成了A&#x3D;2，那么就出现了不一致性)</p><p><strong>写锁和读锁是互斥的</strong>(这里的互斥是指<strong>线程间的互斥</strong>，当前线程可以获取到写锁又获取到读锁，但是获取到了读锁不能继续获取写锁)，这是因为读写锁要<strong>保持写操作的可见性</strong>。因为，如果允许读锁在被获取的情况下对写锁的获取，那么正在运行的其他读线程无法感知到当前写线程的操作。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java内存布局和对象头</title>
    <link href="/2023/09/04/Java%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%A4%B4/"/>
    <url>/2023/09/04/Java%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%A4%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以分为三个部分：<strong>对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)</strong></p><p><img src="/../Java%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%A4%B4_pic/1.png"></p><h3 id="内存布局详解"><a href="#内存布局详解" class="headerlink" title="内存布局详解"></a>内存布局详解</h3><ul><li>对象头<ul><li>对象标记Mark Work</li><li>类元信息(类型指针)</li></ul></li><li>实例数据</li><li>对齐填充</li></ul><p><img src="/../Java%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%A4%B4_pic/2.png"></p><p>对象内部结构分为：对象头、实例数据、对齐填充(保证8个字节的倍数)</p><p>对象头分为<strong>对象标记(markOop)和类元信息(klassOop)</strong>,类元信息存储的是指向对象类元数据(klass)的首地址</p><h3 id="带着问题探索"><a href="#带着问题探索" class="headerlink" title="带着问题探索"></a>带着问题探索</h3><p><img src="/../Java%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%A4%B4_pic/3.png"></p><h3 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h3><p><img src="/../Java%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%A4%B4_pic/4.png"></p><p><img src="/../Java%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%A4%B4_pic/5.png"></p><p><strong>在64位系统下，Mark Word占了8个字节，类型指针占了8个字节，一共64个字节</strong></p><p><img src="/../Java%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%A4%B4_pic/6.png"></p><h3 id="类元信息"><a href="#类元信息" class="headerlink" title="类元信息"></a>类元信息</h3><p>类元信息也叫<strong>类型指针</strong></p><p><img src="/../Java%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%A4%B4_pic/7.png"></p><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>存放类的属性(Field)数据信息，包括父类的属性信息</p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>虚拟机要求对象起始地址必须是8字节的整数倍</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>常见技术场景</title>
    <link href="/2023/08/21/%E5%B8%B8%E8%A7%81%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF/"/>
    <url>/2023/08/21/%E5%B8%B8%E8%A7%81%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="单点登录-没做过，带实践"><a href="#单点登录-没做过，带实践" class="headerlink" title="单点登录(没做过，带实践)"></a>单点登录(没做过，带实践)</h2><p><img src="/../%E5%B8%B8%E8%A7%81%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF_pic/1.png"></p><p><img src="/../%E5%B8%B8%E8%A7%81%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF_pic/2.png"></p><h2 id="权限认证"><a href="#权限认证" class="headerlink" title="权限认证"></a>权限认证</h2><p><img src="/../%E5%B8%B8%E8%A7%81%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF_pic/3.png"></p><p><img src="/../%E5%B8%B8%E8%A7%81%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF_pic/4.png"></p><p>重点：RBAC模型</p><p><img src="/../%E5%B8%B8%E8%A7%81%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF_pic/5.png"></p><p><img src="/../%E5%B8%B8%E8%A7%81%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF_pic/6.png"></p><p>我草！这就是实习的时候的权限控制实现啊！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>AQS</title>
    <link href="/2023/08/11/AQS/"/>
    <url>/2023/08/11/AQS/</url>
    
    <content type="html"><![CDATA[<h2 id="AQS是什么？"><a href="#AQS是什么？" class="headerlink" title="AQS是什么？"></a>AQS是什么？</h2><p>AQS全称为<strong>抽象队列同步器</strong>，是用来实现锁或者其它同步器组件的公共基础部分的<strong>抽象实现</strong>，是<strong>重量级基础框架及整个JuC体系的基石，主要用于解决锁分配给”谁”的问题</strong></p><p><img src="/../aqs_pic/1.png"></p><p>整体就是一个抽象的<strong>FIFO队列</strong>来完成资源获取线程的排队工作，并通过一个<strong>int类变量</strong>表示持有锁的状态</p><p><img src="/../aqs_pic/2.png"></p><h2 id="AQS的”产品”"><a href="#AQS的”产品”" class="headerlink" title="AQS的”产品”"></a>AQS的”产品”</h2><ul><li>ReentrantLock</li><li>CountDownLatch</li><li>ReentrantReadWriteLock</li><li>Semaphore</li><li>CyclicBarrier</li></ul><p><img src="/../aqs_pic/3.png"></p><p><img src="/../aqs_pic/4.png"></p><h2 id="进一步理解锁和同步器的关系"><a href="#进一步理解锁和同步器的关系" class="headerlink" title="进一步理解锁和同步器的关系"></a>进一步理解锁和同步器的关系</h2><p>锁，面向使用者：定义了程序员和锁交互的使用层API，屏蔽了实现细节，调用即可</p><p>同步器，面向锁的实现者：Java并发大神DougLee，提出统一规范并简化了锁的实现，<strong>将其抽象出来</strong>，屏蔽了同步状态管理、同步队列的管理和维护、阻塞线程排队和通知、唤醒机制等，是一切锁和同步组件实现的——–<strong>公共基础部分</strong></p><h2 id="AQS同步队列基本结构"><a href="#AQS同步队列基本结构" class="headerlink" title="AQS同步队列基本结构"></a>AQS同步队列基本结构</h2><p><img src="/../aqs_pic/5.png"></p><p>这个state非常重要！！！0就是空闲，&gt;&#x3D;1就是已经有人占用</p><h2 id="从ReentrantLock打开AQS"><a href="#从ReentrantLock打开AQS" class="headerlink" title="从ReentrantLock打开AQS"></a>从ReentrantLock打开AQS</h2><p><img src="/../aqs_pic/6.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CountDownLatch</title>
    <link href="/2023/07/31/CountDownLatch/"/>
    <url>/2023/07/31/CountDownLatch/</url>
    
    <content type="html"><![CDATA[<h2 id="CountDownLatch概述"><a href="#CountDownLatch概述" class="headerlink" title="CountDownLatch概述"></a>CountDownLatch概述</h2><p>用来进行线程同步协作，等待所有线程完成倒计时。</p><p>其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br> CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">3</span>);<br> <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> sleep(<span class="hljs-number">1</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> latch.countDown();</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> sleep(<span class="hljs-number">1</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> latch.countDown();</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> sleep(<span class="hljs-number">1</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> latch.countDown();</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">   <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;waiting...&quot;</span>)</span>;</span><br><span class="hljs-function">   <span class="hljs-title">latch</span>.<span class="hljs-title">await</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">   <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;wait end...&quot;</span>)</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">00.778</span> <span class="hljs-keyword">c</span>.TestCountDownLatch [main] - waiting... <br><span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">00.778</span> <span class="hljs-keyword">c</span>.TestCountDownLatch [Thread<span class="hljs-number">-2</span>] - <span class="hljs-keyword">begin</span>... <br><span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">00.778</span> <span class="hljs-keyword">c</span>.TestCountDownLatch [Thread<span class="hljs-number">-0</span>] - <span class="hljs-keyword">begin</span>... <br><span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">00.778</span> <span class="hljs-keyword">c</span>.TestCountDownLatch [Thread<span class="hljs-number">-1</span>] - <span class="hljs-keyword">begin</span>... <br><span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">01.782</span> <span class="hljs-keyword">c</span>.TestCountDownLatch [Thread<span class="hljs-number">-0</span>] - <span class="hljs-keyword">end</span>...<span class="hljs-number">2</span> <br><span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">02.283</span> <span class="hljs-keyword">c</span>.TestCountDownLatch [Thread<span class="hljs-number">-2</span>] - <span class="hljs-keyword">end</span>...<span class="hljs-number">1</span> <br><span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">02.782</span> <span class="hljs-keyword">c</span>.TestCountDownLatch [Thread<span class="hljs-number">-1</span>] - <span class="hljs-keyword">end</span>...<span class="hljs-number">0</span> <br><span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">02.782</span> <span class="hljs-keyword">c</span>.TestCountDownLatch [main] - wait <span class="hljs-keyword">end</span>...<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal</title>
    <link href="/2023/07/29/Threadlocal/"/>
    <url>/2023/07/29/Threadlocal/</url>
    
    <content type="html"><![CDATA[<h2 id="先上几个常见面试题"><a href="#先上几个常见面试题" class="headerlink" title="先上几个常见面试题"></a>先上几个常见面试题</h2><ul><li>ThreadLocal中ThreadLocalMap的数据结构和关系？</li><li>ThreadLocal的key是弱引用，这是为什么？</li><li>ThreadLocal内存泄漏问题你知道吗？</li><li>ThreadLocal中最后为什么要加remove方法？</li><li>……</li></ul><h2 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal"></a>什么是ThreadLocal</h2><p>ThreadLocal提供线程局部变量。这些变量与正常的变量<strong>不同</strong>，因为每一个线程在访问ThreadLocal实例的时候（通过其geti或set方法)<strong>都有自己的、独立初始化的变量副本</strong>。ThreadLocal实例通常是类中的私有静态字段，使用它的<strong>目的是希望将状态（例如，用户ID或事务ID)与线程关联起来</strong>。</p><h2 id="ThreadLocal能干嘛"><a href="#ThreadLocal能干嘛" class="headerlink" title="ThreadLocal能干嘛"></a>ThreadLocal能干嘛</h2><p>实现<strong>每一个线程都有自己专属的本地变量副本</strong>(自己用自己的变量不麻烦别人，不和其他人共享，人人有份，人各一份)，主要解决了让每个线程绑定自己的值，通过使用get)和l.set()方法，获取默认值或将其值更改为当前线程所存的副本的值从而避免了线程安全问题，比如我们之前讲解的8锁案例，资源类是使用同一部手机，多个线程抢夺同一部手机使用，假如人手一份是不是天下太平？？</p><p>阿里巴巴开发手册中定义：必须回收自定义的ThreadLocal变量，尤其在线程池场景下，<strong>线程经常会被反复利用</strong>，如果不清理自定义的ThreadLocal变量，可能会影响后续业务逻辑和造成内存泄漏等问题。尽量在代理中使用try-finally块进行回收</p><p><img src="/../threadlocal_pic/1.png"></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyData</span>&#123;<br>    ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial<span class="hljs-function"><span class="hljs-params">(()-&gt;<span class="hljs-number">0</span>)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span>&#123;</span><br><span class="hljs-function">        <span class="hljs-title">threadLocal</span>.<span class="hljs-title">set</span><span class="hljs-params">(threadLocal.get()+<span class="hljs-number">1</span>)</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">ThreadLocalTest</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">static</span> <span class="hljs-title">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-built_in">String</span>[] args)</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">MyData</span> <span class="hljs-title">myData</span> = <span class="hljs-title">new</span> <span class="hljs-title">MyData</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">ExecutorService</span> <span class="hljs-title">threadPool</span> = <span class="hljs-title">Executors</span>.<span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)</span> &#123;</span><br><span class="hljs-function">                <span class="hljs-title">threadPool</span>.<span class="hljs-title">submit</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                        Integer beforeInt = myData.threadLocal.get();</span></span><br><span class="hljs-params"><span class="hljs-function">                        myData.add();</span></span><br><span class="hljs-params"><span class="hljs-function">                        Integer afterInt = myData.threadLocal.get();</span></span><br><span class="hljs-params"><span class="hljs-function">                        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;  &quot;</span>+<span class="hljs-string">&quot;beforeInt:&quot;</span>+beforeInt + <span class="hljs-string">&quot;   &quot;</span>+<span class="hljs-string">&quot;afterInt:&quot;</span>+afterInt);</span></span><br><span class="hljs-params"><span class="hljs-function">                    &#125;<span class="hljs-keyword">finally</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                        myData.threadLocal.remove();</span></span><br><span class="hljs-params"><span class="hljs-function">                    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;)</span>;</span><br><span class="hljs-function">            &#125;</span><br><span class="hljs-function">        &#125;<span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">threadPool</span>.<span class="hljs-title">shutdown</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  beforeInt:<span class="hljs-number">0</span>   afterInt:<span class="hljs-number">1</span><br><span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  beforeInt:<span class="hljs-number">0</span>   afterInt:<span class="hljs-number">1</span><br><span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  beforeInt:<span class="hljs-number">0</span>   afterInt:<span class="hljs-number">1</span><br><span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  beforeInt:<span class="hljs-number">0</span>   afterInt:<span class="hljs-number">1</span><br><span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  beforeInt:<span class="hljs-number">0</span>   afterInt:<span class="hljs-number">1</span><br><span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  beforeInt:<span class="hljs-number">0</span>   afterInt:<span class="hljs-number">1</span><br><span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  beforeInt:<span class="hljs-number">0</span>   afterInt:<span class="hljs-number">1</span><br><span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>  beforeInt:<span class="hljs-number">0</span>   afterInt:<span class="hljs-number">1</span><br><span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>  beforeInt:<span class="hljs-number">0</span>   afterInt:<span class="hljs-number">1</span><br><span class="hljs-attribute">pool</span>-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>  beforeInt:<span class="hljs-number">0</span>   afterInt:<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="Thread、ThreadLocal、ThreadLocalMap关系"><a href="#Thread、ThreadLocal、ThreadLocalMap关系" class="headerlink" title="Thread、ThreadLocal、ThreadLocalMap关系"></a>Thread、ThreadLocal、ThreadLocalMap关系</h3><p><img src="/../threadlocal_pic/2.png"></p><p>打开Thread类，我们可以看到</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ThreadLocal.ThreadLocalMap inheritableThreadLocals <span class="hljs-operator">=</span> null<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>说明Thread包含ThreadLocal，ThreadLocal又包含静态内部类ThreadLocalMap</p><p><img src="/../threadlocal_pic/4.png"></p><p><img src="/../threadlocal_pic/3.png"></p><p>ThreadLocalMap的entry继承了弱引用，这点后面会涉及到</p><p>ThreadLocalMap实际上就是一个以threadLocal实例为key，任意对象为value的Entry对象，当我们为threadLocal变量赋值，实际上就是以当前threadLocal实例为key，值为value的Entry往这个ThreadLocalMap中存放</p><p>生动形象描述</p><p><img src="/../threadlocal_pic/6.png"></p><p><img src="/../threadlocal_pic/7.png"></p><p><strong>JVM内部维护了一个线程版的Map<ThreadLocal Value>(通过ThreadLocal对象的set方法，结果把ThreadLocal对象自己当做key,放进了ThreadLoaMap中</strong>),每个线程要用到这个T的时候，用当前的线程去Map里面获取，通过这样让每个线程都拥有了自己独立的变量，人手一份，竞争条件被彻底消除，在并发模式下是绝对安全的变量。</p><h3 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h3><p>什么是内存泄漏？</p><p>不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄漏</p><p><img src="/../threadlocal_pic/5.png"></p><p>java技术允许使用finalize()方法在垃圾收集器将对象从内存清除出去之前做必要的清理善后工作</p><p><img src="/../threadlocal_pic/3.png"></p><p>ThreadLocalMap从字面上就可以看出这是一个保存ThreadLocal对象的map(以ThreadLocal为key)，不过是经过了两层包装的ThreadLocalMap对象：</p><ul><li>第一层包装是使用了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;将ThreadLocal对象变成一个弱引用的对象</li><li>第二层包装是定义了一个专门的类Entry来扩展WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</li></ul><h3 id="回顾Java中的引用类型"><a href="#回顾Java中的引用类型" class="headerlink" title="回顾Java中的引用类型"></a>回顾Java中的引用类型</h3><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>当内存不足，JVM开始垃圾回收，对于强引用的对象，<strong>就算是出现了OOM也不会对该对象进行回收，死都不收</strong>。</p><p>强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，<strong>即使该对象以后永远都不会被用到，JVM也不会回收</strong>。因此强引用是造成Java内存泄漏的主要原因之一。</p><p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null一般认为就是可以被垃圾收集的了(当然具体回收时机还是要看垃圾收集策略)。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyObject</span>&#123;<br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span>() throws Throwable</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;-----invoke finalize method&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ReferenceDemo1</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws InterruptedException</span> &#123;<br>        MyObject <span class="hljs-built_in">object</span> = <span class="hljs-keyword">new</span> MyObject();<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">object</span>);<br>        <span class="hljs-built_in">object</span> = <span class="hljs-literal">null</span>;<br>        System.gc();<span class="hljs-comment">//人工开启一次GC</span><br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">object</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">reference</span>.MyObject@<span class="hljs-number">568</span>db2f2<br>-----invoke <span class="hljs-keyword">finalize</span> <span class="hljs-keyword">method</span><br><span class="hljs-title function_">null</span><br></code></pre></td></tr></table></figure><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集。</p><p>对于只有软引用的对象来说：</p><ul><li>当系统内存充足时，它不会被回收</li><li>当系统内存不充足时，它会被回收</li></ul><p><strong>软引用通常在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用的时候就保留，不够用就回收</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws InterruptedException</span> &#123;<br>        SoftReference&lt;Object&gt; softReference = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> MyObject());<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;-----softReference:&quot;</span>+softReference.<span class="hljs-keyword">get</span>());<br><br>        System.gc();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;gc after 内存够用：&quot;</span>+softReference.<span class="hljs-keyword">get</span>());<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">20</span> * <span class="hljs-number">1024</span> *<span class="hljs-number">1024</span>];<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;gc after 内存不够：&quot;</span>+softReference.<span class="hljs-keyword">get</span>());<br>        &#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">-----softReference:<span class="hljs-keyword">reference</span>.MyObject@<span class="hljs-number">568</span>db2f2<br>gc after 内存够用：<span class="hljs-keyword">reference</span>.MyObject@<span class="hljs-number">568</span>db2f2<br>gc after 内存不够：null<br>-----invoke <span class="hljs-keyword">finalize</span> <span class="hljs-keyword">method</span><br><span class="hljs-title function_">Exception</span> <span class="hljs-title function_">in</span> <span class="hljs-title function_">thread</span> &quot;<span class="hljs-title function_">main</span>&quot; <span class="hljs-title function_">java</span>.<span class="hljs-title function_">lang</span>.<span class="hljs-title function_">OutOfMemoryError</span>: Java heap space<br>at <span class="hljs-keyword">reference</span>.ReferenceDemo1.main(ReferenceDemo1.java:<span class="hljs-number">26</span>)<br></code></pre></td></tr></table></figure><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用需要用java.lang.ref.WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的内存</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">-----gc before 内存够用 WeakReference:<span class="hljs-keyword">reference</span>.MyObject@<span class="hljs-number">568</span>db2f2<br>-----invoke <span class="hljs-keyword">finalize</span> <span class="hljs-keyword">method</span><br>-----<span class="hljs-title function_">gc</span> <span class="hljs-title function_">after</span> 内存不够用 <span class="hljs-title function_">WeakReference</span>:null<br></code></pre></td></tr></table></figure><p>适用场景：</p><p>假如有一个应用需要读取大量的本地图片：</p><ul><li>如果每次读取图片都从硬盘读取则会严重影响性能</li><li>如果一次性全部加载到内存中有可能造成内存溢出</li></ul><p>此时使用软引用可以解决这个问题</p><p>设计思路是：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关联关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效避免了OOM的问题。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,SoftReferen&lt;Bitmap&gt;&gt; imageCache = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br></code></pre></td></tr></table></figure><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>虚引用需要java.lang.ref.PhantomReference类来实现,顾名思义，<strong>就是形同虚设</strong>，与其他几种引用都不同，虚引用并不会决定对象的生命周期。<strong>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收</strong>，它不能单独使用也不能通过它访问对象，<strong>虚引用必须和引用队列(ReferenceQueue)联合使用。</strong></p><p>虚引用的主要作用是跟踪对象被垃圾回收的状态。仅仅是提供了一种确保对象被finalize以后，做某些事情的通知机制。<strong>PhantomReference的get方法总是返回null</strong>，因此无法访问对应的引用对象。</p><p>换句话说，设置虚引用关联对象的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理，用来实现比finalize机制更灵活的回收操作</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/../threadlocal_pic/8.png"></p><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p><img src="/../threadlocal_pic/9.png"></p><p>ThreadLocal是一个壳子，真正的存储结构是ThreadLocal里有ThreadLocalMap这么个内部类，每个Thread对象维护着一个ThreadLoclMap的引用， ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储。</p><ul><li>调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值Value是传递进来的对象</li><li>调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象</li></ul><p>ThreadLocal本身并不存储值(ThreadLocal是一个壳子)，它只是自己作为一个key来让线程从ThreadLocalMap获取value。正因为这个原理，所以ThreadLocal能够实现“数据隔离”，获取当前线程的局部变量值，不受其他线程影响～</p><h3 id="ThreadLocal的key是弱引用，这是为什么？"><a href="#ThreadLocal的key是弱引用，这是为什么？" class="headerlink" title="ThreadLocal的key是弱引用，这是为什么？"></a>ThreadLocal的key是弱引用，这是为什么？</h3><p><img src="/../threadlocal_pic/10.png"></p><p>line1新建了一个ThreadLocal对象，t1是强引用指向这个对象；</p><p>line2调用set()方法后新建了一个entry，通过源码可知Entry对象里的Key是弱引用指向这个对象</p><p><img src="/../threadlocal_pic/11.png"></p><p>为什么源代码用弱引用？</p><p>当function01方法执行完毕后，栈帧销毁强引用t1也就没有了。但此时线程的TreadLocalMap里某个entry的key的引用还指向这个对象</p><ul><li>若这个key引用是强引用，就会导致key指向的ThreadLocal对象及V指向的对象不能被gc回收，造成内存泄漏</li><li>若这个key引用是弱引用就大概率会减少内存泄漏的问题(还有一个key为null的雷，后面说)。使用弱引用就可以使ThreadLocal对象在方法执行完毕后顺利被回收且entry的key引用指向null</li></ul><p>当ThreadLocal被回收之后，TreadLocalMap的entry是一个key为null的K-V键值对，那么我们无法清除V，而且线程池的线程是复用的，所以V值越积越多会导致内存泄漏</p><p>所以弱引用不能100%保证内存不泄露，我们要在不适用某个ThreadLocal对象后，<strong>手动用remove()方法删除它</strong></p><p><strong>并且</strong>，通过分析set、get、remove方法看出，在threadlocal的生命周期里，针对threadlocal存在的内部泄漏滴滴问题，都会通过<strong>expungeStaleEntry</strong>、cleanSomeSlots、replaceStaleEntry这三个方法清理掉key为null的脏entry</p><p>remove：寻找脏Entry，即key&#x3D;null的Entry，然后进行删除</p><h3 id="ThreadLocal最佳实践"><a href="#ThreadLocal最佳实践" class="headerlink" title="ThreadLocal最佳实践"></a>ThreadLocal最佳实践</h3><ul><li>ThreadLocal.withInitial(()-&gt;初始化值)记得初始化避免空指针异常</li><li>建议把Threadlocal修饰为static</li><li>强制：记得用完手动remove</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>走入UnSafe</title>
    <link href="/2023/07/25/UnSafe/"/>
    <url>/2023/07/25/UnSafe/</url>
    
    <content type="html"><![CDATA[<h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeAccessor</span> &#123;<br> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-keyword">unsafe</span>;<br> <br> <span class="hljs-keyword">static</span> &#123;<br> <span class="hljs-keyword">try</span> &#123; <br> Field theUnsafe = Unsafe.<span class="hljs-keyword">class</span>.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br> theUnsafe.setAccessible(<span class="hljs-literal">true</span>);<br> <span class="hljs-keyword">unsafe</span> = (Unsafe) theUnsafe.<span class="hljs-keyword">get</span>(<span class="hljs-literal">null</span>);<br> &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(e);<br> &#125;<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">getUnsafe</span>()</span> &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">unsafe</span>;<br> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Unsafe-CAS-操作"><a href="#Unsafe-CAS-操作" class="headerlink" title="Unsafe CAS 操作"></a>Unsafe CAS 操作</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran">@<span class="hljs-keyword">Data</span><br><span class="hljs-keyword">class</span> Student &#123;<br> <span class="hljs-keyword">volatile</span> <span class="hljs-built_in">int</span> id;<br> <span class="hljs-keyword">volatile</span> String <span class="hljs-keyword">name</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Unsafe unsafe = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UnsafeAccessor</span>.</span></span>get<span class="hljs-constructor">Unsafe()</span>;<br>Field id = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Student</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">DeclaredField(<span class="hljs-string">&quot;id&quot;</span>)</span>;<br>Field name = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Student</span>.</span></span><span class="hljs-keyword">class</span>.get<span class="hljs-constructor">DeclaredField(<span class="hljs-string">&quot;name&quot;</span>)</span>;<br><span class="hljs-comment">// 获得成员变量的偏移量</span><br>long idOffset = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UnsafeAccessor</span>.</span></span>unsafe.<span class="hljs-keyword">object</span><span class="hljs-constructor">FieldOffset(<span class="hljs-params">id</span>)</span>;<br>long nameOffset = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UnsafeAccessor</span>.</span></span>unsafe.<span class="hljs-keyword">object</span><span class="hljs-constructor">FieldOffset(<span class="hljs-params">name</span>)</span>;<br>Student student = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Student()</span>;<br><span class="hljs-comment">// 使用 cas 方法替换成员变量的值</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UnsafeAccessor</span>.</span></span>unsafe.compare<span class="hljs-constructor">AndSwapInt(<span class="hljs-params">student</span>, <span class="hljs-params">idOffset</span>, 0, 20)</span>; <span class="hljs-comment">// 返回 true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UnsafeAccessor</span>.</span></span>unsafe.compare<span class="hljs-constructor">AndSwapObject(<span class="hljs-params">student</span>, <span class="hljs-params">nameOffset</span>, <span class="hljs-params">null</span>, <span class="hljs-string">&quot;张三&quot;</span>)</span>; <span class="hljs-comment">// 返回 true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(student);<br><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Student(<span class="hljs-attribute">id</span>=20, <span class="hljs-attribute">name</span>=张三) <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CompetableFutrue</title>
    <link href="/2023/07/22/CompetableFuture/"/>
    <url>/2023/07/22/CompetableFuture/</url>
    
    <content type="html"><![CDATA[<h2 id="Futrue"><a href="#Futrue" class="headerlink" title="Futrue"></a>Futrue</h2><p>Futrue接口定义了(FutrueTask)定义了操作<strong>异步任务执行一些方法</strong>，如获取异步任务的执行结果、取消任务的执行、判断任务是否取消、判断任务执行是否完毕等。</p><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 <code>Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p><p>这其实就是多线程中经典的 <strong>Future 模式</strong>，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p><p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li>取消任务；</li><li>判断任务是否被取消;</li><li>判断任务是否已经执行完成;</li><li>获取任务执行结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// V 代表了Future执行的任务返回值的类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt; &#123;<br>    <span class="hljs-comment">// 取消任务执行</span><br>    <span class="hljs-comment">// 成功取消返回 true，否则返回 false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span>;<br>    <span class="hljs-comment">// 判断任务是否被取消</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 判断任务是否已经执行完成</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 获取任务执行结果</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br>    <span class="hljs-comment">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutExceptio<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>简单理解就是：我有一个任务，提交给了 <code>Future</code> 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 <code>Future</code> 那里直接取出任务执行结果</p><p><img src="/../futrue_pic/1.png"></p><p>实例：</p><p><img src="/../futrue_pic/2.png"></p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><strong>优点：</strong></h3><p>Futrue+线程池异步多线程任务配合，能够显著提高程序的执行效率。</p><p><img src="/../futrue_pic/3.png"></p><h3 id="缺点1"><a href="#缺点1" class="headerlink" title="缺点1"></a>缺点1</h3><p>一旦调用get()方法求结果，如果计算没有完成容易导致程序阻塞</p><p><img src="/../futrue_pic/4.png"></p><h3 id="缺点2"><a href="#缺点2" class="headerlink" title="缺点2"></a>缺点2</h3><p>轮询的方式会耗费无谓的CPU资源，而且也不见得能及时地得到计算结果.如果想要异步获取结果,通常都会以轮询的方式去获取结果</p><p><img src="/../futrue_pic/5.png"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Future对于结果的获取不是很友好，只能通过阻塞或轮询的方式得到任务的结果</p><h2 id="CompetableFuture"><a href="#CompetableFuture" class="headerlink" title="CompetableFuture"></a>CompetableFuture</h2><p>get()方法在Future计算完成之前会一直处在阻塞状态下，isDone()方法容易耗费CPU资源，对于真正的异步处理我们希望是可以通过传入回调函数，在Future结束时自动调用该回调函数，这样，我们就不用等待结果。</p><p><strong>阻塞的方式和异步编程的设计理念相违背，而轮询的方式会耗费无谓的CPU资源</strong>。因此，JDK8设计出CompletableFuture。</p><p>CompletableFuture提供了一种<strong>观察者模式</strong>类似的机制，可以让任务执行完成后通知监听的一方。</p><p><img src="/../futrue_pic/6.png"></p><p><code>CompletionStage</code> 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。</p><p><code>CompletionStage</code> 接口中的方法比较多，<code>CompletableFuture</code> 的函数式能力就是这个接口赋予的。从这个接口的方法参数你就可以发现其大量使用了 Java8 引入的函数式编程。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><img src="/../futrue_pic/12.png"></p><p><strong>无返回值的</strong></p><p><img src="/../futrue_pic/7.png"></p><p>默认有线程池(ForkJoinPool)，上面这个是自己new的</p><p><strong>有返回值的</strong></p><p><img src="/../futrue_pic/8.png"></p><p>跟Futrue区别</p><p><img src="/../futrue_pic/10.png"></p><p><img src="/../futrue_pic/9.png"></p><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p><img src="/../futrue_pic/11.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CAS</title>
    <link href="/2023/06/12/CAS/"/>
    <url>/2023/06/12/CAS/</url>
    
    <content type="html"><![CDATA[<h2 id="CAS概述"><a href="#CAS概述" class="headerlink" title="CAS概述"></a>CAS概述</h2><p>CAS是JDK提供的<strong>非阻塞原子性</strong>操作，它通过<strong>硬件</strong>保证了比较-更新的原子性。</p><p>它是非阻塞的且自身具有原子性，也就是说这玩意效率更高且通过硬件保证，说明这玩意更可靠。</p><p><strong>CAS是一条CPU的原子指令(cmpxchg指令）</strong>，不会造成所谓的数据不一致问题，<strong>Unsafe</strong>提供的CAS方法（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg。</p><p>执行cmpxchg指令的时候，会判断当前系统是否为多核系统(一般都是多核系统)，如果是就<strong>给总线加锁</strong>，只有一个线程会对总线加锁成功，加锁成功之后会执行cas操作，<strong>也就是说CAS的原子性实际上是CPU实现独占的</strong>，比起用synchronized重量级锁，这里的排他时间要短很多，所以在多线程情况下性能会比较好。</p><h3 id="CAS乐观锁"><a href="#CAS乐观锁" class="headerlink" title="CAS乐观锁"></a>CAS乐观锁</h3><p>CAS 全称为 <code>Compare And Swap</code> 翻译过来就是<code>比较并且交换</code></p><ul><li>Synchornized 是悲观锁，线程一旦得到锁，其他的线程就只能挂起了</li><li>CAS 的操作则是乐观锁，他认为自己一定会拿到锁，所以他会一直尝试，直到成功拿到为止；</li></ul><h3 id="CAS-机制"><a href="#CAS-机制" class="headerlink" title="CAS 机制"></a>CAS 机制</h3><p>在看到 Compare 和 Swap 后，我们就应该知道，CAS 里面至少包含了两个动作，分别是比较和交换，在现在的 CPU 中，为这两个动作专门提供了一个指令，就是<code>CAH</code> 指令，<strong>由 CPU 来保证</strong>这两个操作一定是原子的，也就是说比较和交换这两个操作只能是<code>要么全部完成，要么全部没有完成</code></p><h3 id="Java中CAS实现"><a href="#Java中CAS实现" class="headerlink" title="Java中CAS实现"></a>Java中CAS实现</h3><p>来看一个方法compareAndSet</p><p><img src="/../cas_pic/1.png"></p><p>点开方发现是一个Unsafe类的compareAndSwapInt方法</p><p>参数：(当前要操作的对象，要操作对象中属性地址的偏移量，需要修改数据的期望值，需要修改的新值)</p><p>Java中一般是这三个方法</p><p><img src="/../cas_pic/2.png"></p><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地〈native)方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。<strong>Unsafe类存在于sun.misc包中</strong>，其内部方法操作可以像c的<strong>指针</strong>一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。</p><p>再次强调！由于CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行的过程中不允许被中断，也就是说<strong>CAS是一条CPU的原子指令</strong>，不会造成所谓的数据不一致问题。</p><p>CAS核心思想：<strong>比较要更新变量的值V和要预期值E，相等才会将V的值设为新值N，如果不相等自选再来</strong></p><h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h3><p>我们看了AtomicInteger、AtomicLong、AtomicBoolean等等方法，那能不能所以类型都有原子类呢？当然可以——AtomicReference！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">Class AtomicReference<span class="hljs-tag">&lt;<span class="hljs-name">V</span>&gt;</span><br></code></pre></td></tr></table></figure><p>看到V就知道可以装任意类型进去了</p><p>定义一个User类</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Getter</span><br><span class="hljs-variable">@Setter</span><br><span class="hljs-variable">@ToString</span><br><span class="hljs-variable">@Builder</span><br>class User&#123;<br>    <span class="hljs-selector-tag">private</span> <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">name</span>;<br>    <span class="hljs-selector-tag">private</span> <span class="hljs-selector-tag">Integer</span> <span class="hljs-selector-tag">age</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        AtomicReference&lt;<span class="hljs-keyword">User</span>&gt; atomicReference = <span class="hljs-built_in">new</span> AtomicReference&lt;&gt;();<br>        <span class="hljs-keyword">User</span> pjf = <span class="hljs-built_in">new</span> <span class="hljs-keyword">User</span>(&quot;彭建飞&quot;,<span class="hljs-number">21</span>);<br>        <span class="hljs-keyword">User</span> xxx = <span class="hljs-built_in">new</span> <span class="hljs-keyword">User</span>(&quot;xxx&quot;,<span class="hljs-number">21</span>);<br>        atomicReference.<span class="hljs-keyword">set</span>(pjf);<br><br>        atomicReference.compareAndSet(pjf,xxx);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(atomicReference.<span class="hljs-keyword">get</span>());<br>    &#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">User(<span class="hljs-params">name</span>=<span class="hljs-params">xxx</span>, <span class="hljs-params">age</span>=21)</span><br></code></pre></td></tr></table></figure><h3 id="CAS与自旋锁"><a href="#CAS与自旋锁" class="headerlink" title="CAS与自旋锁"></a>CAS与自旋锁</h3><p>CAS是实现自旋锁的基础，<strong>CAS利用CPU指令保证了操作的原子性以达到锁的效果</strong>，至于自选看字面意思就能明白，自己<strong>旋转(while)<strong>，是指尝试获取锁的线程不会立即阻塞，而是</strong>采取循环的方式去尝试获取锁</strong>，当线程发现锁被占用时，会不断循环判断锁的状态，直到获取。这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">AtomicInteger atomicInteger <span class="hljs-operator">=</span> new AtomicInteger(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>        atomicInteger.incrementAndGet()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><img src="/../cas_pic/3.png"></p><p>循环自选</p><p><img src="/../cas_pic/4.png"></p><h4 id="自定义自旋锁"><a href="#自定义自旋锁" class="headerlink" title="自定义自旋锁"></a>自定义自旋锁</h4><p>题目：实现一个自旋锁，复习CAS思想</p><p>自旋锁的好处：循环比较获取没有类似wait的阻塞</p><p>通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒钟，B随后进来后发现当前有线程持有锁，所以只能通过自选等待，直到A释放锁后B随后抢到</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpinLockDemo</span> &#123;<br>    AtomicReference&lt;Thread&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();<br><br>    public <span class="hljs-literal">void</span> lock() throws InterruptedException &#123;<br>        Thread currentThread = Thread.currentThread();<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;   come in&quot;</span>);<br>        <span class="hljs-keyword">while</span>(!atomicReference.compareAndSet(<span class="hljs-literal">null</span>,currentThread))&#123;<br>            Thread.sleep(<span class="hljs-number">10</span>);<br>        &#125;<br>    &#125;<br><br>    public <span class="hljs-literal">void</span> unLock()&#123;<br>        atomicReference.compareAndSet(Thread.currentThread(),<span class="hljs-literal">null</span>);<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;task over&quot;</span>);<br>    &#125;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        SpinLockDemo spinLockDemo = <span class="hljs-keyword">new</span> SpinLockDemo();<br><br>        <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                spinLockDemo.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                Thread.sleep(<span class="hljs-number">5000</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">            spinLockDemo.unLock();</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;,<span class="hljs-string">&quot;A&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                spinLockDemo.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">            spinLockDemo.unLock();</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;,<span class="hljs-string">&quot;B&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h3><h4 id="循环时间长CPU开销大"><a href="#循环时间长CPU开销大" class="headerlink" title="循环时间长CPU开销大"></a>循环时间长CPU开销大</h4><p><img src="/../cas_pic/4.png"></p><p>一直靠循环去竞争获取锁，CPU开销大</p><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>CAS会导致“ABA”问题</p><p>CAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个<strong>时间差类</strong>会导致数据的变化。</p><p>比如说一个线程1从内存位置V中取出A，这时候另一个线程2也从内存中取出A，并且线程2进行了一些操作将值变成了B,然后线程2又将V位置的数据变成A，这时候线程1进行CAS操作发现内存中仍然是A，预期OK，然后线程1操作成功。</p><p>尽管线程1的CAS操作成功，但不是代表这个过程就是没有问题的</p><p>分析为什么普通CAS会有ABA问题，因为我们比较的时候<strong>只比较了内容</strong>，那么这里可以解决的办法就是<strong>加上时间戳记(Stamp)</strong>,在我们的原子类中有一个<strong>AtomicStampedReference类</strong>,在AtomicReference之上加了一个Stamped</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> AtomicStampReference &#123;<br>    static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-number">100</span>,<span class="hljs-number">1</span>);<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span>-&gt;&#123;<br>            <span class="hljs-built_in">int</span> stamp = atomicStampedReference.get<span class="hljs-constructor">Stamp()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;    &quot;</span>+<span class="hljs-string">&quot;首次版本号：&quot;</span>+stamp);<br>            <span class="hljs-comment">//暂停500毫秒保证t4线程初始化拿到的版本号一样</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">500</span>);<br>            &#125; catch (InterruptedException e) &#123;<br>                e.print<span class="hljs-constructor">StackTrace()</span>;<br>            &#125;<br><br>            atomicStampedReference.compare<span class="hljs-constructor">AndSet(100,101,<span class="hljs-params">atomicStampedReference</span>.<span class="hljs-params">getStamp</span>()</span>,atomicStampedReference.get<span class="hljs-constructor">Stamp()</span>+<span class="hljs-number">1</span>);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;    &quot;</span>+<span class="hljs-string">&quot;第二次次版本号：&quot;</span>+atomicStampedReference.get<span class="hljs-constructor">Stamp()</span>);<br><br>            atomicStampedReference.compare<span class="hljs-constructor">AndSet(101,100,<span class="hljs-params">atomicStampedReference</span>.<span class="hljs-params">getStamp</span>()</span>,atomicStampedReference.get<span class="hljs-constructor">Stamp()</span>+<span class="hljs-number">1</span>);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;    &quot;</span>+<span class="hljs-string">&quot;第二次次版本号：&quot;</span>+atomicStampedReference.get<span class="hljs-constructor">Stamp()</span>);<br>        &#125;,<span class="hljs-string">&quot;t3&quot;</span>).start<span class="hljs-literal">()</span>;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span>-&gt;&#123;<br>            <span class="hljs-built_in">int</span> stamp = atomicStampedReference.get<span class="hljs-constructor">Stamp()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span>+<span class="hljs-string">&quot;    &quot;</span>+<span class="hljs-string">&quot;首次版本号：&quot;</span>+stamp);<br>            <span class="hljs-comment">//暂停1秒保证t4线程初始化拿到的版本号一样</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">1000</span>);<br>            &#125; catch (InterruptedException e) &#123;<br>                e.print<span class="hljs-constructor">StackTrace()</span>;<br>            &#125;<br><br>            boolean b = atomicStampedReference.compare<span class="hljs-constructor">AndSet(100, 2023, <span class="hljs-params">stamp</span>, <span class="hljs-params">stamp</span>+ 1)</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(b+<span class="hljs-string">&quot;  &quot;</span>+atomicStampedReference.get<span class="hljs-constructor">Reference()</span>+<span class="hljs-string">&quot;    &quot;</span>+<span class="hljs-string">&quot;第二次次版本号：&quot;</span>+atomicStampedReference.get<span class="hljs-constructor">Stamp()</span>);<br><br>        &#125;,<span class="hljs-string">&quot;t4&quot;</span>).start<span class="hljs-literal">()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2023/05/30/Redis/"/>
    <url>/2023/05/30/Redis/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>单机的Redis存在四大问题：</p><p><img src="/../redis_pic/1.png"></p><p>Redis有两种持久化方案: </p><ul><li>RDB持久化</li><li>AOF持久化</li></ul><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p><h4 id="RDB执行时机"><a href="#RDB执行时机" class="headerlink" title="RDB执行时机"></a>RDB执行时机</h4><p>RDB持久化在四种情况下会执行：</p><ul><li>执行save命令</li><li>执行bgsave命令</li><li>Redis停机时(ctrl+C)</li><li>触发RDB条件时</li></ul><hr><p><strong>1）save命令</strong></p><p><strong>执行下面的命令，可以立即执行一次RDB：</strong></p><p><img src="/../redis_pic/2.png"></p><p>save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p><p><strong>2）bgsave命令</strong></p><p>下面的命令可以异步执行RDB：</p><p><img src="/../redis_pic/3.png"></p><p>这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p><p><strong>3）停机时</strong></p><p>Redis停机时会执行一次save命令，实现RDB持久化</p><p><strong>4）触发RDB条件</strong></p><p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save &quot;&quot; 则表示禁用RDB</span><br><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span>  <br><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span>  <br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><p>RDB的其它配置也可以在redis.conf文件中设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span><br>rdbcompression <span class="hljs-built_in">yes</span><br><br><span class="hljs-comment"># RDB文件名称</span><br>dbfilename dump.rdb  <br><br><span class="hljs-comment"># 文件保存的路径目录</span><br><span class="hljs-built_in">dir</span> ./ <br></code></pre></td></tr></table></figure><h4 id="RDB原理"><a href="#RDB原理" class="headerlink" title="RDB原理"></a>RDB原理</h4><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p><p>fork采用的是copy-on-write技术：</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><p><img src="/../redis_pic/4.png"></p><h4 id="RDB小结"><a href="#RDB小结" class="headerlink" title="RDB小结"></a>RDB小结</h4><p>RDB方式bgsave的基本流程？</p><ul><li>fork主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新的RDB文件</li><li>用新RDB文件替换旧的RDB文件</li></ul><p>RDB会在什么时候执行？save 60 1000代表什么含义？</p><ul><li>默认是服务停止时</li><li>代表60秒内至少执行1000次修改则触发RDB</li></ul><p>RDB的缺点？</p><ul><li><strong>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</strong></li><li>fork子进程、压缩、写出RDB文件都比较耗时</li></ul><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。(有点像MySQL里的redo log保证数据的持久化)。</p><p><img src="/../redis_pic/5.png"></p><h4 id="AOF配置"><a href="#AOF配置" class="headerlink" title="AOF配置"></a>AOF配置</h4><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 是否开启AOF功能，默认是no</span><br><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">yes</span><br><span class="hljs-comment"># AOF文件的名称</span><br>appendfilename <span class="hljs-string">&quot;appendonly.aof&quot;</span><br></code></pre></td></tr></table></figure><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 表示每执行一次写命令，立即记录到AOF文件</span><br><span class="hljs-attribute">appendfsync</span> always <br><span class="hljs-comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span><br>appendfsync everysec <br><span class="hljs-comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span><br>appendfsync <span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><p>三种策略对比：</p><p><img src="/../redis_pic/6.png"></p><h4 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h4><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><p><img src="/../redis_pic/7.png"></p><p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p><p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span><br><span class="hljs-attribute">auto</span>-aof-rewrite-percentage <span class="hljs-number">100</span><br><span class="hljs-comment"># AOF文件体积最小多大以上才触发重写 </span><br><span class="hljs-attribute">auto</span>-aof-rewrite-min-size <span class="hljs-number">64</span>mb <br></code></pre></td></tr></table></figure><h3 id="RDB与AOF对比"><a href="#RDB与AOF对比" class="headerlink" title="RDB与AOF对比"></a>RDB与AOF对比</h3><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p><p><img src="/../redis_pic/8.png"></p><h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>尽管 RDB 比 AOF 的数据恢复速度快，但是快照的频率不好把握：</p><ul><li>如果频率太低，两次快照间一旦服务器发生宕机，就可能会比较多的数据丢失；</li><li>如果频率太高，频繁写入磁盘和创建子进程会带来额外的性能开销。</li></ul><p>那有没有什么方法不仅有 RDB 恢复速度快的优点和，又有 AOF 丢失数据少的优点呢？</p><p>当然有，那就是将 RDB 和 AOF 合体使用，这个方法是在 Redis 4.0 提出的，该方法叫<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化。</p><p>如果想要开启混合持久化功能，可以在 Redis 配置文件将下面这个配置项设置成 yes：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">aof-<span class="hljs-keyword">use</span>-rdb-preamble yes<br></code></pre></td></tr></table></figure><p>混合持久化工作在 <strong>AOF 日志重写过程</strong>。</p><p>当开启了混合持久化时，在 AOF 重写日志时，<code>fork</code> 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p><p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p><p><img src="/../redis_pic/11.png"></p><p>这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。</p><p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p><h3 id="纯缓存模式"><a href="#纯缓存模式" class="headerlink" title="纯缓存模式"></a>纯缓存模式</h3><p>由于开启了持久化，会对redis性能造成一定影响</p><p>同时关闭RDB+AOF</p><p><strong>关闭RDB</strong>：修改触发条件 save “” (禁用RDB持久化模式下，我们仍然可以使用命令save、bgsave生成RDB文件)</p><p><strong>关闭AOF</strong>: 修改配置文件 appendonly no(禁用AOF持久化模式下，我们仍然可以使用bgrewriteaof生成AOF文件)</p><h2 id="分布式锁-redission"><a href="#分布式锁-redission" class="headerlink" title="分布式锁-redission"></a>分布式锁-redission</h2><h3 id="分布式锁-redission功能介绍"><a href="#分布式锁-redission功能介绍" class="headerlink" title="分布式锁-redission功能介绍"></a>分布式锁-redission功能介绍</h3><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><p><img src="/../redis_pic/9.png"></p><p>那么什么是Redission呢</p><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><p>Redission提供了分布式锁的多种多样的功能</p><p><img src="/../redis_pic/10.png"></p><h3 id="分布式锁-Redission快速入门"><a href="#分布式锁-Redission快速入门" class="headerlink" title="分布式锁-Redission快速入门"></a>分布式锁-Redission快速入门</h3><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置Redisson客户端：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino">@Configuration<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonConfig</span> &#123;<br><br>    @<span class="hljs-function">Bean</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title">redissonClient</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 配置</span><br>        Config config = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Config</span>();<br>        config.<span class="hljs-built_in">useSingleServer</span>().<span class="hljs-built_in">setAddress</span>(<span class="hljs-string">&quot;redis://192.168.150.101:6379&quot;</span>)<br>            .<span class="hljs-built_in">setPassword</span>(<span class="hljs-string">&quot;123321&quot;</span>);<br>        <span class="hljs-comment">// 创建RedissonClient对象</span><br>        <span class="hljs-keyword">return</span> Redisson.<span class="hljs-built_in">create</span>(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如何使用Redission的分布式锁</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp">@Resource<br><span class="hljs-keyword">private</span> RedissionClient redissonClient;<br><br>@Test<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testRedisson</span>() throws Exception</span>&#123;<br>    <span class="hljs-comment">//获取锁(可重入)，指定锁的名称</span><br>    RLock <span class="hljs-keyword">lock</span> = redissonClient.getLock(<span class="hljs-string">&quot;anyLock&quot;</span>);<br>    <span class="hljs-comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span><br>    boolean isLock = <span class="hljs-keyword">lock</span>.tryLock(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,TimeUnit.SECONDS);<br>    <span class="hljs-comment">//判断获取锁成功</span><br>    <span class="hljs-keyword">if</span>(isLock)&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;执行业务&quot;</span>);          <br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            <span class="hljs-comment">//释放锁</span><br>            <span class="hljs-keyword">lock</span>.unlock();<br>        &#125;  <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>在 VoucherOrderServiceImpl</p><p>注入RedissonClient</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Resource<br><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br>@Override<br>public Result seckill<span class="hljs-constructor">Voucher(Long <span class="hljs-params">voucherId</span>)</span> &#123;<br>        <span class="hljs-comment">// 1.查询优惠券</span><br>        SeckillVoucher voucher = seckillVoucherService.get<span class="hljs-constructor">ById(<span class="hljs-params">voucherId</span>)</span>;<br>        <span class="hljs-comment">// 2.判断秒杀是否开始</span><br>        <span class="hljs-keyword">if</span> (voucher.get<span class="hljs-constructor">BeginTime()</span>.is<span class="hljs-constructor">After(LocalDateTime.<span class="hljs-params">now</span>()</span>)) &#123;<br>            <span class="hljs-comment">// 尚未开始</span><br>            return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Result</span>.</span></span>fail(<span class="hljs-string">&quot;秒杀尚未开始！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 3.判断秒杀是否已经结束</span><br>        <span class="hljs-keyword">if</span> (voucher.get<span class="hljs-constructor">EndTime()</span>.is<span class="hljs-constructor">Before(LocalDateTime.<span class="hljs-params">now</span>()</span>)) &#123;<br>            <span class="hljs-comment">// 尚未开始</span><br>            return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Result</span>.</span></span>fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 4.判断库存是否充足</span><br>        <span class="hljs-keyword">if</span> (voucher.get<span class="hljs-constructor">Stock()</span> &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 库存不足</span><br>            return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Result</span>.</span></span>fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>        &#125;<br>        Long userId = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserHolder</span>.</span></span>get<span class="hljs-constructor">User()</span>.get<span class="hljs-constructor">Id()</span>;<br>        <span class="hljs-comment">//创建锁对象 这个代码不用了，因为我们现在要使用分布式锁</span><br>        <span class="hljs-comment">//SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span><br>        RLock lock = redissonClient.get<span class="hljs-constructor">Lock(<span class="hljs-string">&quot;lock:order:&quot;</span> + <span class="hljs-params">userId</span>)</span>;<br>        <span class="hljs-comment">//获取锁对象</span><br>        boolean isLock = lock.<span class="hljs-keyword">try</span><span class="hljs-constructor">Lock()</span>;<br>       <br><span class="hljs-comment">//加锁失败</span><br>        <span class="hljs-keyword">if</span> (!isLock) &#123;<br>            return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Result</span>.</span></span>fail(<span class="hljs-string">&quot;不允许重复下单&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取代理对象(事务)</span><br>            IVoucherOrderService proxy = (IVoucherOrderService) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AopContext</span>.</span></span>current<span class="hljs-constructor">Proxy()</span>;<br>            return proxy.create<span class="hljs-constructor">VoucherOrder(<span class="hljs-params">voucherId</span>)</span>;<br>        &#125; finally &#123;<br>            <span class="hljs-comment">//释放锁</span><br>            lock.unlock<span class="hljs-literal">()</span>;<br>        &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="Redission锁可重入原理"><a href="#Redission锁可重入原理" class="headerlink" title="Redission锁可重入原理"></a>Redission锁可重入原理</h3><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state&#x3D;0，假如有人持有这把锁，那么state&#x3D;1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。  </p><p>在redission中，我们的也支持支持可重入锁</p><p><img src="/../redis_pic/12.png"></p><h3 id="分布式锁-redission锁重试和WatchDog机制"><a href="#分布式锁-redission锁重试和WatchDog机制" class="headerlink" title="分布式锁-redission锁重试和WatchDog机制"></a>分布式锁-redission锁重试和WatchDog机制</h3><p><img src="/../redis_pic/13.png"></p><p>抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p><p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p><p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p><p>所以如果返回是null，则代表着当前这哥们已经抢锁完毕，或者可重入完毕，但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，同学们可以自行往下翻一点点，你能发现有个while( true) 再次进行tryAcquire进行抢锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">long threadId = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Id()</span>;<br>Long ttl = <span class="hljs-keyword">try</span><span class="hljs-constructor">Acquire(-1, <span class="hljs-params">leaseTime</span>, <span class="hljs-params">unit</span>, <span class="hljs-params">threadId</span>)</span>;<br><span class="hljs-comment">// lock acquired</span><br><span class="hljs-keyword">if</span> (ttl<span class="hljs-operator"> == </span>null) &#123;<br>    return;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来会有一个条件分支，因为lock方法有重载方法，一个是带参数，一个是不带参数，如果带带参数传入的值是-1，如果传入参数，则leaseTime是他本身，所以如果传入了参数，此时leaseTime !&#x3D; -1 则会进去抢锁，抢锁的逻辑就是之前说的那三个逻辑</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (leaseTime != -<span class="hljs-number">1</span>) &#123;<br>    return <span class="hljs-keyword">try</span><span class="hljs-constructor">LockInnerAsync(<span class="hljs-params">waitTime</span>, <span class="hljs-params">leaseTime</span>, <span class="hljs-params">unit</span>, <span class="hljs-params">threadId</span>, RedisCommands.EVAL_LONG)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是没有传入时间，则此时也会进行抢锁， 而且抢锁时间是默认看门狗时间 commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()</p><p>ttlRemainingFuture.onComplete((ttlRemaining, e) 这句话相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">RFuture&lt;<span class="hljs-built_in">Long</span>&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,<br>                                        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),<br>                                        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);<br>ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// lock acquired</span><br>    <span class="hljs-keyword">if</span> (ttlRemaining == <span class="hljs-literal">null</span>) &#123;<br>        scheduleExpirationRenewal(threadId);<br>    &#125;<br>&#125;);<br><span class="hljs-keyword">return</span> ttlRemainingFuture;<br></code></pre></td></tr></table></figure><p>此逻辑就是续约逻辑，注意看commandExecutor.getConnectionManager().newTimeout（） 此方法</p><p>Method(  <strong>new</strong> TimerTask() {},参数2 ，参数3  )</p><p>指的是：通过参数2，参数3 去描述什么时候去做参数1的事情，现在的情况是：10s之后去做参数一的事情</p><p>因为锁的失效时间是30s，当10s之后，此时这个timeTask 就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p><p>那么大家可以想一想，假设我们的线程出现了宕机他还会续约吗？当然不会，因为没有人再去调用renewExpiration这个方法，所以等到时间之后自然就释放了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">renewExpiration</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ExpirationEntry</span> <span class="hljs-variable">ee</span> <span class="hljs-operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());<br>    <span class="hljs-keyword">if</span> (ee == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">Timeout</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Timeout timeout)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            <span class="hljs-type">ExpirationEntry</span> <span class="hljs-variable">ent</span> <span class="hljs-operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());<br>            <span class="hljs-keyword">if</span> (ent == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ent.getFirstThreadId();<br>            <span class="hljs-keyword">if</span> (threadId == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <br>            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);<br>            future.onComplete((res, e) -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>                    log.error(<span class="hljs-string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="hljs-string">&quot; expiration&quot;</span>, e);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span> (res) &#123;<br>                    <span class="hljs-comment">// reschedule itself</span><br>                    renewExpiration();<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;, internalLockLeaseTime / <span class="hljs-number">3</span>, TimeUnit.MILLISECONDS);<br>    <br>    ee.setTimeout(task);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>可以一次执行多个命令，本质是一组命令的集合，一个事务中的所有命令都会序列化，按顺序地串行化执行而<strong>不会被其他命令插入</strong>，<strong>不许加塞</strong></p><p>能干吗？<strong>在一个队列中</strong>、一次性、顺序性、排他性的执行一系列命令</p><p>redis事务 VS MySQL事务</p><table><thead><tr><th>1.单独的隔离操作</th><th>Redis的事务仅仅是保证事务里的操作会被连续独占的执行，redis命令执行是单线程架构，在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的</th></tr></thead><tbody><tr><td>2.没有隔离级别的概念</td><td>因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这种问题了</td></tr><tr><td>3.不保证原子性</td><td>Redis的事务不保证原子性，也就是不保证所有指令同时成功或同时失败，只有决定是否开始执行全部指令的能力，没有执行到一半进行回滚的能力</td></tr><tr><td>4.排它性</td><td>Redis会保证一个事务内的命令依次执行，而不会被其它命令插入</td></tr></tbody></table><h3 id="事务有关的常用命令"><a href="#事务有关的常用命令" class="headerlink" title="事务有关的常用命令"></a>事务有关的常用命令</h3><p><img src="/../redis_pic/14.png"></p><p>翻译：discard —- 丢弃</p><h3 id="case1-正常执行"><a href="#case1-正常执行" class="headerlink" title="case1-正常执行"></a>case1-正常执行</h3><p><img src="/../redis_pic/15.png"></p><p>multi、exec</p><p>multi开启事务，然后输入了4条指令，注意，这时候并没有执行，看命令下方，<strong>出现了QUEUED</strong>，这就是上面说的<strong>队列</strong>（<strong>在一个队列中</strong>、一次性、顺序性、排他性的执行一系列命令），它先将命令放在一个队列中，然后当调用exec的时候<strong>一次性的、顺序的</strong>执行完队列中的命令，并且不许被插入(排他)</p><h3 id="case2-放弃事务"><a href="#case2-放弃事务" class="headerlink" title="case2-放弃事务"></a>case2-放弃事务</h3><p>multi、discard</p><p><img src="/../redis_pic/16.png"></p><h3 id="case3-全体连坐"><a href="#case3-全体连坐" class="headerlink" title="case3-全体连坐"></a>case3-全体连坐</h3><p><img src="/../redis_pic/17.png"></p><h3 id="case4-冤头债主"><a href="#case4-冤头债主" class="headerlink" title="case4-冤头债主"></a>case4-冤头债主</h3><p><img src="/../redis_pic/18.png"></p><h3 id="case5-watch监控"><a href="#case5-watch监控" class="headerlink" title="case5-watch监控"></a>case5-watch监控</h3><p>Redis使用Watch来提供<strong>乐观锁定</strong>，类似于CAS(Check-and-Set)</p><p>复习：</p><p><strong>悲观锁(Pessimistic Lock)</strong>, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</p><p><strong>乐观锁(Optimistic Lock)</strong>, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。</p><p><strong>乐观锁策略</strong>:提交版本必须  大于  记录当前版本才能执行更新</p><p>watch：初始化k1和balance两个key，先监控再开启multi，保证两key变动在同一个失误内</p><p><strong>正常情况：</strong></p><p><img src="/../redis_pic/19.png"></p><p><strong>有加塞篡改：</strong></p><p><strong>watch命令是一种乐观锁的实现，Redis在修改的时候会检测数据是否被更改，如果更改了，则整个执行失败</strong></p><p><strong>第一个窗口蓝色框第5步执行结果返回为空，也就是相当于是失败，笔记见最下面官网说明</strong></p><p><img src="/../redis_pic/20.png"></p><p><img src="/../redis_pic/21.png"></p><hr><p>总结：</p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230703223637525.png" alt="image-20230703223637525"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>常用数据结构</title>
    <link href="/2023/05/08/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/05/08/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="红黑树-平衡二叉查找树"><a href="#红黑树-平衡二叉查找树" class="headerlink" title="红黑树(平衡二叉查找树)"></a>红黑树(平衡二叉查找树)</h2><p>首先他是一棵<strong>二叉搜索树</strong>(左子节点的值小于自身，右子结点的值大于自身，左子树都小于自身，右子树都大于自身，中序遍历是递增有序的)</p><p><img src="/../struct_pic/3.png"></p><p>极端情况下退化为链表，此时高度为n,操作时间复杂读降低。所以需要平衡树</p><p>红黑树<strong>通过对结点进行黑红标色，旋转及其他操作进行平衡操作</strong></p><p><img src="/../struct_pic/4.png"></p><p>红黑树<strong>不具有严格的平衡属性</strong>(平衡属性：任意结点左右子树高度相差不大于1)，但是平均使用性能非常良好。适用于<strong>频繁插入</strong>和<strong>删除</strong>的的场景。什么时候红黑树进行旋转调整高度呢？<strong>当根到叶子结点的最长路径大于最短路径的两倍时</strong>，红黑树进行调整。</p><h3 id="红黑树与AVL树对比"><a href="#红黑树与AVL树对比" class="headerlink" title="红黑树与AVL树对比"></a>红黑树与AVL树对比</h3><p><img src="/../struct_pic/8.png"></p><h3 id="红黑树规则特点"><a href="#红黑树规则特点" class="headerlink" title="红黑树规则特点"></a>红黑树规则特点</h3><ul><li><p>节点分为红色或者黑色；</p></li><li><p>根节点必为黑色；</p></li><li><p>叶子节点都为黑色，且为null(不存储数据)；</p></li><li><p>连接红色节点的两个子节点都为黑色（红黑树不会出现相邻的红色节点）；</p></li><li><p>从任意节点出发，到其每个叶子节点的路径中包含相同数量的黑色节点；</p></li><li><p>新加入到红黑树的节点为红色节点；</p></li></ul><p>这些规则强制了红黑树的关键性质：<strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</strong>(而AVL平衡二叉搜索树的旋转策略是最大高度差不超过1)，结果是这个树大致上是平衡的。因为操作比如<strong>插入、删除和查找</strong>某个值的最坏情况时间<strong>都要求与树的高度成比例</strong>，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。</p><p><img src="/../struct_pic/1.png"></p><p><img src="/../struct_pic/2.png"></p><p>树的高度趋近于logn，从而树上的各种操作(插入&#x2F;删除&#x2F;查找)的<strong>时间复杂度为logn</strong>。</p><p>一颗有N的结点的红黑树高度最多不超过(&lt;&#x3D;)2long(N+1).</p><h3 id="红黑树的变色与旋转"><a href="#红黑树的变色与旋转" class="headerlink" title="红黑树的变色与旋转"></a>红黑树的变色与旋转</h3><p>回顾红黑色的规则特点，当我们对红黑树进行插入和删除是，可能会破坏这些规则，所以我们需要<strong>变色</strong>和<strong>旋转</strong>维护红黑树的规则特点。</p><p>变色就是红色—-&gt;黑色或者黑色—-&gt;红色</p><p>旋转分为<strong>左旋</strong>和<strong>右旋</strong></p><p><img src="/../struct_pic/5.png"></p><p>加入要对4结点进行左旋操作其中左旋右两个核心操作</p><p><strong>一.4的右节点成为4的父节点</strong></p><p><img src="/../struct_pic/6.png"></p><p><strong>二.4结点的右孩子结点的左子树成为4的右子树</strong></p><p><img src="/../struct_pic/7.png"></p><p>右旋和左旋对称同理</p><h2 id="一、Queue和Deque"><a href="#一、Queue和Deque" class="headerlink" title="一、Queue和Deque"></a>一、Queue和Deque</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Queue以及Deque都是继承于Collection，Deque是Queue的子接口。</p><p>Queue是FIFO的单向队列，Deque是双向队列。</p><p>Queue有一个直接子类PriorityQueue，而Deque中直接子类有两个：LinkedList以及ArrayDeque。</p><p>PriorityQueue的底层数据结构是数组，而无边界的形容，那么指明了PriorityQueue是自带扩容机制的。</p><p>ArrayDeque是无初始容量的双端队列，LinkedList则是双向链表。</p><p>PriorityQueue可以作为堆使用，而且可以根据传入的Comparator实现大小的调整，会是一个很好的选择。<br>ArrayDeque通常作为栈或队列使用，但是栈的效率不如LinkedList高。<br>LinkedList通常作为栈或队列使用，但是队列的效率不如ArrayQueue高。</p><h3 id="api对比"><a href="#api对比" class="headerlink" title="api对比"></a>api对比</h3><table><thead><tr><th></th><th>Queue</th><th>Deque</th></tr></thead><tbody><tr><td>增加</td><td>add</td><td>add、addFirst、addLast</td></tr><tr><td></td><td>offer</td><td>offer、offerFirst、offerLast</td></tr><tr><td>移除</td><td>remove</td><td>remove、removeFirst、removeLast</td></tr><tr><td></td><td>poll</td><td>pop、poll、pollFirst、pollLast</td></tr><tr><td>获取</td><td>element</td><td>element、getFirst、getLast</td></tr><tr><td></td><td>peek</td><td>peek、peekFirst、peekLast</td></tr></tbody></table><p><strong>备注：</strong></p><p>1、add和offer区别</p><ul><li>add() : 添加元素，如果添加成功则返回true，如果队列是满的，则抛出异常</li><li>offer() : 添加元素，如果添加成功则返回true，如果队列是满的，则返回false</li></ul><p>2、remove和poll</p><ul><li>remove() : 移除队列头的元素并且返回，如果队列为空则抛出异常</li><li>poll() : 移除队列头的元素并且返回，如果队列为空则返回null</li><li>Deque新增了一个pop方法，也是移除队列头的元素并且返回，如果队列为空则抛出异常。</li></ul><p>3、element和peek</p><ul><li>element() ：返回队列头元素但不移除，如果队列为空，则抛出异常</li><li>peek() ：返回队列头元素但不移除，如果队列为空，则返回null</li><li>因此，增加推荐使用add，移除推荐使用poll，获取元素推荐使用peek。</li></ul><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><h4 id="1、queue"><a href="#1、queue" class="headerlink" title="1、queue"></a>1、queue</h4><p>队列(queue)是一种常用的数据结构，可以将队列看做是一种特殊的线性表，该结构遵循的先进先出原则。Java中，LinkedList实现了Queue接口,因为LinkedList进行插入、删除操作效率较高。</p><p><strong>初始化：</strong></p><blockquote><p>Queue <Integer> q &#x3D; new LinkedList<Integer>();</p></blockquote><p>**常用方法：<br>**</p><p>**add(E e)?*将指定元素插入此队列尾部，成功返回true。</p><p>**offer(E e)?*将指定元素插入队列尾部，成功返回true。当队列有容量 限制时，此方法由于add，因为后者可能无法插入，而只是抛出IllegalStateException异常。</p><p>**remove()?*获取并移除队列的头部元素，队列为空抛出异常。</p><p><strong>poll()：</strong>获取并移除队列的头部元素，队列为空返回null。</p><p>**element()?*获取但是不移除队列头部元素，队列为空抛出异常。</p><p>**peek()?*获取但是不移除队列头部元素，队列为空返回null。</p><p>**isEmpty()?*判断队列是否为空，为空返回true。</p><p>**size()?*获取队列元素数量.</p><p><strong>实例代码：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Queue&lt;<span class="hljs-type">String</span>&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">// add()和remove()方法在失败的时候会抛出异常(不推荐)</span><br>    queue.<span class="hljs-built_in">offer</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>    queue.<span class="hljs-built_in">offer</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>    queue.<span class="hljs-built_in">offer</span>(<span class="hljs-string">&quot;c&quot;</span>);<br>    queue.<span class="hljs-built_in">offer</span>(<span class="hljs-string">&quot;d&quot;</span>);<br>    queue.<span class="hljs-built_in">offer</span>(<span class="hljs-string">&quot;e&quot;</span>);<br>    queue.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;f&quot;</span>);<br>    <span class="hljs-comment">//在队列元素为空的情况下，remove() 方法会抛出NoSuchElementException异常，poll() 方法只会返回 null 。</span><br>    <span class="hljs-type">String</span> first2 = queue.<span class="hljs-built_in">remove</span>();<span class="hljs-comment">//返回第一个元素，删除</span><br>    System.out.<span class="hljs-built_in">println</span>(first2);<span class="hljs-comment">//a</span><br>    <span class="hljs-type">String</span> first1 = queue.<span class="hljs-built_in">poll</span>();<span class="hljs-comment">//返回第一个元素，删除</span><br>    System.out.<span class="hljs-built_in">println</span>(first1);<span class="hljs-comment">//b</span><br>    <span class="hljs-type">String</span> first = queue.<span class="hljs-built_in">peek</span>();<span class="hljs-comment">//返回第一个元素，但不删除</span><br>    System.out.<span class="hljs-built_in">println</span>(first);<span class="hljs-comment">//c</span><br>    System.out.<span class="hljs-built_in">println</span>(queue);<span class="hljs-comment">//[c, d, e, f]</span><br>    first = queue.<span class="hljs-built_in">element</span>();<span class="hljs-comment">//返回第一个元素</span><br>    System.out.<span class="hljs-built_in">println</span>(first);<span class="hljs-comment">//c</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、deque"><a href="#2、deque" class="headerlink" title="2、deque"></a>2、deque</h4><p>双向队列是指该队列两端的元素既能入队(offer)也能出队(poll),如果将Deque限制为只能从一端入队和出队，则可实现栈的数据结构。对于栈而言，有入栈(push)和出栈(pop)，遵循先进后出原则。</p><p><strong>初始化：</strong></p><blockquote><p>Deque<Integer> d &#x3D; new LinkedList<Integer>();</p></blockquote><p>**常用方法：<br>**</p><p>**addLast(E e)?*在队列尾部插入元素.</p><p>**offerLast(E e)?*在队列尾部插入元素。</p><p>**removeFirst()?*获取头部元素。</p><p>**pollFirst()?*获取头部元素。</p><p>**getFirst()?*获取头部元素。</p><p>**peekFirst()?*获取头部元素。</p><blockquote><p>&#x2F;&#x2F;上述方法均和queue中方法一一对应。<br>&#x2F;&#x2F;且queue中的方法，deque中均可用。</p></blockquote><p>**getLast()?*获取但不移除队列最后一个元素。</p><p>**offerFirst()?*将指定元素插入队列开头。</p><p>**peekLast()?*获取但不移除双端队列最后一个元素。</p><p>**pollLast()?*获取并移除双端队列最后一个元素。</p><p>**pop()?*从双端队列表示的堆栈 中弹出一个元素。</p><p>**push()?*将一个元素推入双端队列表示的堆栈，即队列的头部。成功返回true，如果没有可用空间，抛出IllegalStateException。</p><p>**removeLast()?*获取并移除移除双端队列最后一个元素。</p><p>**size()?*返回双端队列元素数。</p><p>**isEmpty()?*判断队列是否为空，为空返回true。</p><p>**remove(Object o)?*从双端队列中移除第一次出现的指定元素。</p><p><strong>实例代码：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs awk">public static void test02()&#123;<br>    Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();<br>    deque.offer(<span class="hljs-string">&quot;a&quot;</span>);<br>    deque.offer(<span class="hljs-string">&quot;b&quot;</span>);<br>    deque.offerFirst(<span class="hljs-string">&quot;c&quot;</span>);<span class="hljs-regexp">//</span>在队列头部进行插入<br>    System.out.println(deque);<span class="hljs-regexp">//</span>[c, a, b]<br>    deque.offerLast(<span class="hljs-string">&quot;d&quot;</span>);<br>    System.out.println(deque);<span class="hljs-regexp">//</span>[c, a, b, d]<br> <br>    String ret = deque.element();<span class="hljs-regexp">//</span>返回第一个元素<br>    System.out.println(ret);<span class="hljs-regexp">//</span>c<br> <br>    ret = deque.getFirst();<span class="hljs-regexp">//</span>返回第一个元素<br>    System.out.println(ret);<span class="hljs-regexp">//</span>c<br>    ret = deque.getLast();<span class="hljs-regexp">//</span>返回最后一个元素<br>    System.out.println(ret);<span class="hljs-regexp">//</span>d<br> <br>    ret = deque.peek();<span class="hljs-regexp">//</span>返回第一个元素，但不删除<br>    System.out.println(ret);<span class="hljs-regexp">//</span>c<br> <br>    ret = deque.peekFirst();<span class="hljs-regexp">//</span>返回第一个元素，但不删除<br>    System.out.println(ret);<span class="hljs-regexp">//</span>c<br>    ret = deque.peekLast();<span class="hljs-regexp">//</span>返回最后一个元素，但不删除<br>    System.out.println(ret);<span class="hljs-regexp">//</span>d<br> <br>    System.out.println(deque);<br> <br>    ret = deque.poll();<span class="hljs-regexp">//</span>返回第一个元素，删除<br>    System.out.println(ret);<span class="hljs-regexp">//</span>c<br>    System.out.println(deque);<span class="hljs-regexp">//</span>[a, b, d]<br> <br>    ret = deque.pop();<span class="hljs-regexp">//</span>返回第一个元素，删除<br>    System.out.println(ret);<span class="hljs-regexp">//</span>a<br>    System.out.println(deque);<span class="hljs-regexp">//</span>[b, d]<br> <br>    deque.clear();<br>    ret = deque.pop();<span class="hljs-regexp">//</span>抛异常<br>    System.out.println(<span class="hljs-string">&quot;11111&quot;</span>);<br>    ret = deque.poll();<span class="hljs-regexp">//</span>返回null,但不抛异常<br>    System.out.println(<span class="hljs-string">&quot;++&quot;</span>+ret);<br>    System.out.println(<span class="hljs-string">&quot;22222&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java8新特性</title>
    <link href="/2023/04/26/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2023/04/26/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda是一个<strong>匿名函数</strong>，我们可以把Lambda表达式理解为是<strong>一段可以传递的代码</strong>(将代码像数据一样进行传递)。使用它可以写出更简洁，灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p><h3 id="Lambda表达式的格式"><a href="#Lambda表达式的格式" class="headerlink" title="Lambda表达式的格式"></a>Lambda表达式的格式</h3><h4 id="1-标准格式："><a href="#1-标准格式：" class="headerlink" title="1.标准格式："></a>1.标准格式：</h4><p>​        （参数列表） -&gt; {代码}</p><h4 id="2-格式说明："><a href="#2-格式说明：" class="headerlink" title="2.格式说明："></a>2.格式说明：</h4><p>​- 小括内的语法与传统方法参数列表一致，没有参数就留空，有多个参数就用逗号分隔</p><p>​        - 【-&gt;】 是新引入的语法格式，代表指向动作</p><p>​        - 大括号内的语法与传统方法体要求一致</p><h4 id="3-案例说明"><a href="#3-案例说明" class="headerlink" title="3.案例说明"></a>3.案例说明</h4><p>第一个线程案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span> <span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程需要执行的任务代码1&quot;</span>);<br>    &#125;<br>&#125;);<br>thread1.start();<br> <br><span class="hljs-comment">// Lambda表达式</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    System.out.println(<span class="hljs-string">&quot;线程需要执行的任务代码2&quot;</span>);<br>&#125;);<br>t2.start();<br></code></pre></td></tr></table></figure><p>第二个比较器案例</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">List&lt;<span class="hljs-type">Integer</span>&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>Collections.addAll(list,<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>,<span class="hljs-number">55</span>);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;排序之前的集合：&quot; + list);<br><br>// 比较器的正常书写格式<br>Collections.sort(list, <span class="hljs-built_in">new</span> Comparator&lt;<span class="hljs-type">Integer</span>&gt;() &#123;<br>    @Override<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> compare (<span class="hljs-type">Integer</span> o1, <span class="hljs-type">Integer</span> o2) &#123;<br>        <span class="hljs-keyword">return</span> o2-o1;<br>    &#125;<br>&#125;);<br> <br>// Lambda表达式<br>Collections.sort(list,(<span class="hljs-type">Integer</span> o1, <span class="hljs-type">Integer</span> o2)-&gt;&#123;<span class="hljs-keyword">return</span> o2-o1;&#125;);<br>//或者<br>list.sort((o1,o2)-&gt;(o1-o2));<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;排序之后的集合：&quot; + list);<br></code></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">sortTest</span> &#123;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        int[][] arr =&#123;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">8</span>,<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-number">15</span>,<span class="hljs-number">18</span>&#125;&#125;;<br>        Arrays.sort<span class="hljs-function"><span class="hljs-params">(arr,(x,y)-&gt;(x[<span class="hljs-number">0</span>]-y[<span class="hljs-number">0</span>]))</span>;</span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(int[] ints : arr)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">for</span> <span class="hljs-params">(int anInt : ints)</span> &#123;</span><br><span class="hljs-function">                <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">print</span><span class="hljs-params">(anInt+<span class="hljs-string">&quot; &quot;</span>)</span>;</span><br><span class="hljs-function">            &#125;</span><br><span class="hljs-function">            <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">输出：</span><br><span class="hljs-function">1 3 </span><br><span class="hljs-function">2 6 </span><br><span class="hljs-function">8 10 </span><br><span class="hljs-function">15 18</span><br><span class="hljs-function">排序成功！</span><br></code></pre></td></tr></table></figure><h3 id="Lambda表达式的使用条件"><a href="#Lambda表达式的使用条件" class="headerlink" title="Lambda表达式的使用条件"></a>Lambda表达式的使用条件</h3><ul><li>Lambda表达式不是万能的，他需要函数式接口的支持；</li><li>什么是函数式接口：<br>函数式接口的定义是: 只包含一个抽象方法的接口，称为函数式接口；<br>其实我们的Lambda表达式就是对函数式接口的一种简写方式，所以只有是函数式接口，我们才能用Lambda表达式；再换句话说，Lambda表达式需要函数式接口的支持，那函数式接口我们可以自己定义，当然JDK1.8也给我们提供了一些现成的函数式接口；<br><img src="/../java8_pic/2.png"></li></ul><p> 首先，都是接口；  其次，接口中有且只有一个接口，才可以使用lambda表达式</p><p>​    1.接口中只有一个抽象方法的接口，叫做函数式接口</p><p>​    2.如果是函数式接口，那么就可以用@FunctionalInterface注解标识</p><p><img src="/../java8_pic/1.png"></p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>先来看一下什么是方法引用：</p><ul><li>方法引用其实是Lambda表达式的另一种写法，当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用；</li></ul><p>注意： 实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致！<br>方法引用：使用操作符<code>::</code>将方法名和对象或类的名字分隔开来，三种主要使用情况为：</p><p>对象::实例方法<br>类::静态方法<br>类::实例方法</p><p><strong>对象::实例方法</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">function</span>.<span class="hljs-property">Consumer</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-title class_">String</span>&gt; consumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-title class_">String</span>&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">accept</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>) &#123;<br>                <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(s);<br>            &#125;<br>        &#125;;<br>        consumer.<span class="hljs-title function_">accept</span>(<span class="hljs-string">&quot;aaaaaaaaaaaaaa&quot;</span>);<br>        <span class="hljs-comment">//aaaaaaaaaaaaaa</span><br><br>        <span class="hljs-comment">//简写1：</span><br>        <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-title class_">String</span>&gt; consumer1 = (<span class="hljs-title class_">String</span> s) -&gt; &#123;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(s);<br>        &#125;;<br>        consumer1.<span class="hljs-title function_">accept</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>        <span class="hljs-comment">//abc</span><br><br>        <span class="hljs-comment">//简写2：</span><br>        <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-title class_">String</span>&gt; consumer2 = (s) -&gt; <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(s);<br>        consumer2.<span class="hljs-title function_">accept</span>(<span class="hljs-string">&quot;bcd&quot;</span>);<br>        <span class="hljs-comment">//bcd</span><br><br>        <span class="hljs-comment">//简写3：</span><br>        <span class="hljs-title class_">Consumer</span>&lt;<span class="hljs-title class_">String</span>&gt; consumer3 = <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>::println;<br>        consumer3.<span class="hljs-title function_">accept</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>        <span class="hljs-comment">//abc</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>类::静态方法</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.<span class="hljs-keyword">function</span>.BinaryOperator;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MyTest1 &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        BinaryOperator&lt;<span class="hljs-type">Double</span>&gt; <span class="hljs-keyword">operator</span> = <span class="hljs-built_in">new</span> BinaryOperator&lt;<span class="hljs-type">Double</span>&gt;()&#123;<br>            @Override<br>            <span class="hljs-built_in">public</span> <span class="hljs-type">Double</span> apply(<span class="hljs-type">Double</span> o, <span class="hljs-type">Double</span> o2) &#123;<br>                <span class="hljs-keyword">return</span> Math.max(o,o2);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">operator</span>.apply(<span class="hljs-number">2.13</span>, <span class="hljs-number">3.12</span>));//<span class="hljs-number">3.12</span><br><br>        BinaryOperator&lt;<span class="hljs-type">Double</span>&gt; operator2 = (o, o2) -&gt; Math.max(o,o2);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(operator2.apply(<span class="hljs-number">2.13</span>, <span class="hljs-number">3.12</span>));//<span class="hljs-number">3.12</span><br><br>        BinaryOperator&lt;<span class="hljs-type">Double</span>&gt; operator3 = Math::max;<br><br>        <span class="hljs-type">Double</span> max = operator3.apply(<span class="hljs-number">5.0</span>, <span class="hljs-number">20.0</span>);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(max);//<span class="hljs-number">20.0</span><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>因为Math.max()所需要的参数以及返回值与重写的accpet()一样，因此可以简写为<code>类::静态方法</code>；</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MyTest2 &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        Comparator&lt;<span class="hljs-type">Integer</span>&gt; comparator = <span class="hljs-built_in">new</span> Comparator&lt;<span class="hljs-type">Integer</span>&gt;() &#123;<br>            @Override<br>            <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> compare(<span class="hljs-type">Integer</span> o1, <span class="hljs-type">Integer</span> o2) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-type">Integer</span>.compare(o1,o2);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(comparator.compare(<span class="hljs-number">20</span>, <span class="hljs-number">12</span>));//<span class="hljs-number">1</span><br><br>        Comparator&lt;<span class="hljs-type">Integer</span>&gt; comparator1 = <span class="hljs-type">Integer</span>::compareTo;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(comparator1.compare(<span class="hljs-number">20</span>, <span class="hljs-number">12</span>));//<span class="hljs-number">1</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>类::实例方法</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Comparator</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-title class_">String</span>&gt; comparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-title class_">String</span>&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> int <span class="hljs-title function_">compare</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> o1, <span class="hljs-built_in">String</span> o2</span>) &#123;<br>                <span class="hljs-keyword">return</span> o1.<span class="hljs-title function_">compareTo</span>(o2);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(comparator.<span class="hljs-title function_">compare</span>(<span class="hljs-string">&quot;20&quot;</span>, <span class="hljs-string">&quot;12&quot;</span>));<span class="hljs-comment">//1</span><br><br>        <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-title class_">String</span>&gt; comparator1 = <span class="hljs-title class_">String</span>::compareTo;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(comparator1.<span class="hljs-title function_">compare</span>(<span class="hljs-string">&quot;20&quot;</span>, <span class="hljs-string">&quot;12&quot;</span>));<span class="hljs-comment">//1</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>为什么可以这样写？、<br>传递过来的两个参数，一个作为调用者，一个作为参数，这时候，使用<code>类::实例方法</code>简写</p><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p><strong>现有一个需求：</strong></p><p>将list集合中姓张的元素过滤到一个新的集合中</p><p>然后将过滤出来的姓张的元素中，再过滤出来长度为3的元素，存储到一个新的集合中</p><p><strong>1.用常规方法解决需求</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 已知的知识来解决需求</span><br>List&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list1.add(<span class="hljs-string">&quot;张老三&quot;</span>);<br>list1.add(<span class="hljs-string">&quot;张小三&quot;</span>);<br>list1.add(<span class="hljs-string">&quot;李四&quot;</span>);<br>list1.add(<span class="hljs-string">&quot;赵五&quot;</span>);<br>list1.add(<span class="hljs-string">&quot;张六&quot;</span>);<br>list1.add(<span class="hljs-string">&quot;王八&quot;</span>);<br> <br>ArrayList&lt;String&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">// 1.将list集合中姓张的元素过滤到一个新的集合中</span><br><span class="hljs-keyword">for</span>(String name : list1)&#123;<br>    <span class="hljs-keyword">if</span>(name.startsWith(<span class="hljs-string">&quot;张&quot;</span>))&#123;<br>        list2.add(name);<br>    &#125;<br>&#125;<br><span class="hljs-type">ArrayList</span> <span class="hljs-variable">list3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><span class="hljs-keyword">for</span> (String name : list2) &#123;<br>    <span class="hljs-keyword">if</span> (name.length() == <span class="hljs-number">3</span>)&#123;<br>        list3.add(name);<br>    &#125;<br>&#125;<br>System.out.println(list3);<br> <br>输出结果：<br>    [张老三, 张小三]<br></code></pre></td></tr></table></figure><p> <strong>2.用Stream流操作集合，获取流，过滤操作，打印输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">list1.stream().filter((String name)-&gt;name.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).filter((String name)-&gt;name.length()==<span class="hljs-number">3</span>).forEach((String name)-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;符合条件的姓名：&quot;</span> + name);<br>        &#125;);<br></code></pre></td></tr></table></figure><p>( 看不懂没关系，下面会讲到该方法，这里只是用来引入的）</p><h3 id="Stream流的格式"><a href="#Stream流的格式" class="headerlink" title="Stream流的格式"></a>Stream流的格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;T&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; predicate)</span>;<br>            -----&gt; 参数：<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Predicate</span>&lt;T&gt;  (函数式接口)<br>                    ----&gt; 抽象方法：<span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;<br>            -----&gt; 参数：<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Consumer</span>&lt;T&gt;  (函数式接口)<br>                    ----&gt; 抽象方法：<span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;<br></code></pre></td></tr></table></figure><h3 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h3><p>  Collection接口中有一个stream()方法，可以获取流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">stream</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><p>代码演示</p><p> 1.根据List集合获取流</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><br>// 创建List集合<br>List&lt;String&gt; list <span class="hljs-operator">=</span> new ArrayList&lt;&gt;()<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;张老三&quot;</span>)<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;张小三&quot;</span>)<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;李四&quot;</span>)<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;赵五&quot;</span>)<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;张六&quot;</span>)<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;王八&quot;</span>)<span class="hljs-comment">;</span><br>Stream&lt;String&gt; stream1 <span class="hljs-operator">=</span> list.stream()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>2.根据Set集合获取流</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 创建List集合<br>Set&lt;String&gt; set <span class="hljs-operator">=</span> new HashSet&lt;&gt;()<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;张老三&quot;</span>)<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;张小三&quot;</span>)<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;李四&quot;</span>)<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;赵五&quot;</span>)<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;张六&quot;</span>)<span class="hljs-comment">;</span><br>list.add(<span class="hljs-string">&quot;王八&quot;</span>)<span class="hljs-comment">;</span><br>Stream&lt;String&gt; stream2 <span class="hljs-operator">=</span> set.stream()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p> 3.根据Map集合获取流</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">// 创建Map集合</span><br><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">Integer</span>,<span class="hljs-built_in">String</span>&gt; <span class="hljs-built_in">map</span> = <span class="hljs-literal">new</span> HashMap&lt;&gt;();<br><span class="hljs-built_in">map</span>.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;张老三&quot;</span>);<br><span class="hljs-built_in">map</span>.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;张小三&quot;</span>);<br><span class="hljs-built_in">map</span>.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;李四&quot;</span>);<br><span class="hljs-built_in">map</span>.put(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;赵五&quot;</span>);<br><span class="hljs-built_in">map</span>.put(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;张六&quot;</span>);<br><span class="hljs-built_in">map</span>.put(<span class="hljs-number">6</span>,<span class="hljs-string">&quot;王八&quot;</span>);<br> <br><span class="hljs-comment">// 3.1根据Map集合的键获取流</span><br><span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">Integer</span>&gt; map1 = <span class="hljs-built_in">map</span>.keySet();<br>Stream&lt;<span class="hljs-built_in">Integer</span>&gt; stream3 = map1.stream();<br><span class="hljs-comment">// 3.2根据Map集合的值获取流</span><br>Collection&lt;<span class="hljs-built_in">String</span>&gt; map2 = <span class="hljs-built_in">map</span>.values();<br>Stream&lt;<span class="hljs-built_in">String</span>&gt; stream4 = map2.stream();<br><span class="hljs-comment">// 3.3根据Map集合的键值对对象获取瑞</span><br><span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">Map</span>.Entry&lt;<span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">String</span>&gt;&gt; map3 = <span class="hljs-built_in">map</span>.entrySet();<br>Stream&lt;<span class="hljs-built_in">Map</span>.Entry&lt;<span class="hljs-built_in">Integer</span>, <span class="hljs-built_in">String</span>&gt;&gt; stream5 = map3.stream();<br></code></pre></td></tr></table></figure><p>​    4.根据数组获取流</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 根据数组获取流</span><br><span class="hljs-type">String</span>[] arr = &#123;<span class="hljs-string">&quot;张颜宇&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;赵五&quot;</span>,<span class="hljs-string">&quot;刘六&quot;</span>,<span class="hljs-string">&quot;王七&quot;</span>&#125;;<br><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-type">String</span>&gt; stream6 = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(arr);<br></code></pre></td></tr></table></figure><h3 id="Stream流的常用方法"><a href="#Stream流的常用方法" class="headerlink" title="Stream流的常用方法"></a>Stream流的常用方法</h3><p><strong>终结方法</strong>：返回值类型不再是Stream接口本身类型的方法，例如：forEach方法和count方法</p><p><strong>非终结方法&#x2F;延迟方法</strong>：返回值类型仍然是Stream接口自身类型的方法，除了终结方法都是延迟方法。例如：filter,limit,skip,map,conat</p><table><thead><tr><th>方法名称</th><th>方法作用</th><th>方法种类</th><th>是否支持链式调用</th></tr></thead><tbody><tr><td>count</td><td>统计个数</td><td>终结方法</td><td>否</td></tr><tr><td>forEach</td><td>逐一处理</td><td>终结方法</td><td>否</td></tr><tr><td>filter</td><td>过滤</td><td>函数拼接</td><td>是</td></tr><tr><td>limit</td><td>取用前几个</td><td>函数拼接</td><td>是</td></tr><tr><td>skip</td><td>跳过前几个</td><td>函数拼接</td><td>是</td></tr><tr><td>map</td><td>映射</td><td>函数拼接</td><td>是</td></tr><tr><td>concat</td><td>组合</td><td>函数拼接</td><td>是</td></tr></tbody></table><h3 id="方法演示"><a href="#方法演示" class="headerlink" title="方法演示"></a>方法演示</h3><p><strong>1.count方法</strong>：long count (); 统计流中的元素，返回long类型数据</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">List&lt;String&gt; list = new ArrayList&lt;&gt;();<br>list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张老三&quot;</span>);<br>list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张小三&quot;</span>);<br>list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;李四&quot;</span>);<br>list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;赵五&quot;</span>);<br>list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;张六&quot;</span>);<br>list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;王八&quot;</span>);<br>long count = list.stream().count();<br>System.out.println(<span class="hljs-string">&quot;集合中的元素个数是：&quot;</span> + count);<br>输出结果：<br>集合中的元素个数是：6<br></code></pre></td></tr></table></figure><p><strong>2.filter方法</strong></p><p>Stream<T> filter(Predicate<? super ?> predicate); 过滤出满足条件的元素</p><p>参数Predicate：函数式接口，抽象方法：boolean test （T  t)</p><p> Predicate接口：是一个判断接口</p><pre><code class="hljs">    // 获取stream流    Stream&lt;String&gt; stream = Stream.of(&quot;张老三&quot;, &quot;张小三&quot;, &quot;李四&quot;, &quot;赵五&quot;, &quot;刘六&quot;, &quot;王七&quot;);    // 需求：过去出姓张的元素    stream.filter((String name)-&gt;&#123;        return name.startsWith(&quot;张&quot;);    &#125;).forEach((String name)-&gt;&#123;        System.out.println(&quot;流中的元素&quot; + name);    &#125;);          </code></pre><p> (上面引入Stream流时，就用到了这个方法）</p><p><strong>3.forEach方法</strong></p><p>  void forEach(Consumer&lt;? super T&gt; action)：逐一处理流中的元素<br>            参数 Consumer&lt;? super T&gt; action：函数式接口，只有一个抽象方法：void accept（T t)；</p><p>注意：<br>1.此方法并不保证元素的逐一消费动作在流中是有序进行的（元素可能丢失）<br>2.Consumer是一个消费接口（可以获取流中的元素进行遍历操作，输出出去），可以使用Lambda表达式</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">List&lt;String&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>list.<span class="hljs-keyword">add</span>(&quot;张老三&quot;);<br>list.<span class="hljs-keyword">add</span>(&quot;张小三&quot;);<br>list.<span class="hljs-keyword">add</span>(&quot;李四&quot;);<br>list.<span class="hljs-keyword">add</span>(&quot;赵五&quot;);<br>list.<span class="hljs-keyword">add</span>(&quot;张六&quot;);<br>list.<span class="hljs-keyword">add</span>(&quot;王八&quot;);<br> <br>// 函数模型：获取流 <span class="hljs-comment">--&gt; 注意消费流中的元素</span><br>list.stream().<span class="hljs-keyword">forEach</span>((String <span class="hljs-type">name</span>)-&gt;&#123;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">name</span>);<br>&#125;);<br> <br>输出结果：<br>    张老三<br>    张小三<br>    李四<br>    赵五<br>    张六<br>    <br></code></pre></td></tr></table></figure><p><strong>4.limit方法</strong></p><p> Stream<T> limit(long maxSize);  取用前几个元素</p><p> 注意：参数是一个long 类型，如果流的长度大于参数，则进行截取；否则不进行操作</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 获取流的长度</span><br><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-type">String</span>&gt; stream1 = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张老三&quot;</span>, <span class="hljs-string">&quot;张小三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;赵五&quot;</span>, <span class="hljs-string">&quot;刘六&quot;</span>, <span class="hljs-string">&quot;王七&quot;</span>);<br><span class="hljs-comment">// 需求：保留前三个元素</span><br>stream1.<span class="hljs-built_in">limit</span>(<span class="hljs-number">3</span>).forEach((<span class="hljs-type">String</span> name)-&gt;&#123;<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;流中的前三个元素是：&quot;</span> + name);<br>&#125;);D<br>输出结果：<br>    流中的前三个元素是：张老三<br>    流中的前三个元素是：张小三<br>流中的前三个元素是：李四<br></code></pre></td></tr></table></figure><p><strong>5.map方法</strong></p><p><r> Stream <R> map(Function&lt;? super T,? exception R&gt; mapper;<br>                            参数Function&lt;T,R&gt;：函数式接口，抽象方法：R apply(T t);<br>                                Function&lt;T,R&gt;：其实就是一个类型转换接口（T和R的类型可以一致，也可以不一致）</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> 获取Stream流<br>Stream&lt;<span class="hljs-built_in">String</span>&gt; stream1 = Stream.<span class="hljs-keyword">of</span>(<span class="hljs-string">&quot;11&quot;</span>,<span class="hljs-string">&quot;22&quot;</span>,<span class="hljs-string">&quot;33&quot;</span>,<span class="hljs-string">&quot;44&quot;</span>,<span class="hljs-string">&quot;55&quot;</span>);<br><span class="hljs-regexp">//</span> 需求：把stream1流中的元素转换为int类型<br>stream1.map(<span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">String</span> s)</span>-&gt;</span>&#123;<br>   <span class="hljs-keyword">return</span> Integer.<span class="hljs-built_in">parseInt</span>(s); <span class="hljs-regexp">//</span> 将<span class="hljs-built_in">String</span>类型的s进行转换为Integer类型的元素，并返回<br>&#125;).forEach(<span class="hljs-function"><span class="hljs-params">(Integer i)</span>-&gt;</span>&#123;<br>    System.out.println(i);  <span class="hljs-regexp">//</span> 将转换后的int类型的元素逐一输出<br>&#125;);<br>输出结果：<br>    <span class="hljs-number">11</span><br>    <span class="hljs-number">22</span><br>    <span class="hljs-number">33</span><br>    <span class="hljs-number">44</span><br>    <span class="hljs-number">55</span><br></code></pre></td></tr></table></figure><p><strong>6.skip方法</strong></p><p>Stream<T> skip(long n);   跳过前几个元素<br>          注意： 如果流的当前长度大于n，则跳过前n个，否则将会得到一个长度为0的空流</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 获取stream流</span><br><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-type">String</span>&gt; stream = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张老三&quot;</span>, <span class="hljs-string">&quot;张小三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;赵五&quot;</span>, <span class="hljs-string">&quot;刘六&quot;</span>, <span class="hljs-string">&quot;王七&quot;</span>);<br> <br>stream.<span class="hljs-built_in">skip</span>(<span class="hljs-number">3</span>).forEach((<span class="hljs-type">String</span> name)-&gt;&#123;<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;跳过前三个，打印剩下的&quot;</span> + name);<br>&#125;);<br> <br>输出结果：<br>    跳过前三个，打印剩下的赵五<br>    跳过前三个，打印剩下的刘六<br>   跳过前三个，打印剩下的王七<br></code></pre></td></tr></table></figure><p><strong>7.concat方法</strong></p><p> public static <T> Stream<T> concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)<br>      –&gt; 合并两个流</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-type">String</span>&gt; stream1 = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;11&quot;</span>,<span class="hljs-string">&quot;22&quot;</span>,<span class="hljs-string">&quot;33&quot;</span>,<span class="hljs-string">&quot;44&quot;</span>,<span class="hljs-string">&quot;55&quot;</span>);<br><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-type">String</span>&gt; stream2 = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;张颜宇&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;赵五&quot;</span>, <span class="hljs-string">&quot;刘六&quot;</span>, <span class="hljs-string">&quot;王七&quot;</span>);<br> <br><span class="hljs-comment">// 需求：合并两个流</span><br><span class="hljs-built_in">Stream</span>&lt;<span class="hljs-type">String</span>&gt; stream = <span class="hljs-built_in">Stream</span>.<span class="hljs-built_in">concat</span>(stream1,stream2);<br>stream.forEach((<span class="hljs-type">String</span> name)-&gt;&#123;<br>    System.out.<span class="hljs-built_in">print</span>(name);<br>输出结果：<span class="hljs-number">1122334455</span>张颜宇张三李四赵五刘六王七<br></code></pre></td></tr></table></figure><p><strong>收集Stream流</strong></p><p>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);     把流中的数据收集到单列集合中<br>                    返回值类型是R。R指定为什么类型，就是手机到什么类型的集合<br>                    参数Collector&lt;? super T, A, R&gt;中的R类型，决定把流中的元素收集到哪个集合中<br>                    参数Collector如何得到 ？，可以使用 java.util.stream.Collectors工具类中的静态方法：</p><pre><code class="hljs">                    - public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()：转换为List集合                                            - public static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet() ：转换为Set集合</code></pre><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>List&lt;String&gt; list2 = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>list2.<span class="hljs-keyword">add</span>(&quot;张老三&quot;);<br>list2.<span class="hljs-keyword">add</span>(&quot;张小三&quot;);<br>list2.<span class="hljs-keyword">add</span>(&quot;李四&quot;);<br>list2.<span class="hljs-keyword">add</span>(&quot;赵五&quot;);<br>list2.<span class="hljs-keyword">add</span>(&quot;张六&quot;);<br>list2.<span class="hljs-keyword">add</span>(&quot;王八&quot;);<br>// 需求：过滤出姓张的并且长度为<span class="hljs-number">3</span>的元素<br><br>Stream&lt;String&gt; stream = list2.stream().<span class="hljs-keyword">filter</span>((String <span class="hljs-type">name</span>) -&gt; &#123;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-type">name</span>.startsWith(&quot;张&quot;);<br>&#125;).<span class="hljs-keyword">filter</span>((String <span class="hljs-type">name</span>) -&gt; &#123;   <br>    <span class="hljs-keyword">return</span> <span class="hljs-type">name</span>.length() == <span class="hljs-number">3</span>;<br>&#125;);<br> <br>// stream 收集到单列集合中<br>List&lt;String&gt; list = stream.collect(Collectors.toList());<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(list);<br><br>// stream 手机到单列集合中<br><span class="hljs-keyword">Set</span>&lt;String&gt; <span class="hljs-keyword">set</span> = stream.collect(Collectors.toSet());<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">set</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2023/04/13/MySQL/"/>
    <url>/2023/04/13/MySQL/</url>
    
    <content type="html"><![CDATA[<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>如果设计到多表查询，那么首先应该确定设计哪几张表，然后分析他们之间的连接条件，最后确定查询字段。</strong></p><p>多表查询就是指从多张表中查询数据。</p><p>原来查询单表数据，执行的SQL形式为：select * from emp;</p><p>那么我们要执行多表查询，就只需要使用逗号分隔多张表即可，如： select * from emp(17条记录) , dept(6条记录) ;</p><p>此时,我们看到查询结果中包含了大量的结果集，总共102条记录，而这其实就是员工表emp所有的记录 (17) 与 部门表dept所有记录(6) 的所有组合情况，这种现象称之为笛卡尔积。接下来，就来简单 介绍下笛卡尔积。</p><p>笛卡尔积: 笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况。</p><p><img src="/../mysql_pic/98.png"></p><p>而在多表查询中，我们是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。</p><p><img src="/../mysql_pic/99.png"></p><p>在SQL语句中，如何来去除无效的笛卡尔积呢？ 我们可以给多表查询加上连接查询的条件即可</p><p>select * from emp , dept where emp.dept_id &#x3D; dept.id;</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>连接查询</p><ul><li><p>内连接：相当于查询A、B交集部分数据</p><ul><li><p>隐式内连接</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">SELECT</span> 字段列表 FROM 表<span class="hljs-number">1</span> , 表<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 条件 <span class="hljs-params">...</span> ;<br><br></code></pre></td></tr></table></figure></li><li><p>显式内连接</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [ <span class="hljs-keyword">INNER</span> ] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 连接条件 ... ;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>外连接：</p></li><li><p>左外连接：查询左表所有数据，以及两张表交集部分数据</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">LEFT</span> [ <span class="hljs-keyword">OUTER</span> ] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 条件 ... ;<br></code></pre></td></tr></table></figure><p>eg: 查询emp表的所有数据, 和对应的部门信息</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.*, d.name <span class="hljs-keyword">from</span> emp <span class="hljs-built_in">e</span> <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> <span class="hljs-built_in">e</span>.dept_id = d.id;<br></code></pre></td></tr></table></figure></li><li><p>右外连接：查询右表所有数据，以及两张表交集部分数据</p></li><li><p>自连接：当前表与自身的连接查询，自连接必须使用表别名</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">SELECT 字段列表 <span class="hljs-selector-tag">FROM</span> 表<span class="hljs-selector-tag">A</span> 别名<span class="hljs-selector-tag">A</span> JOIN 表<span class="hljs-selector-tag">A</span> 别名<span class="hljs-selector-tag">B</span> ON 条件 ... ;<br></code></pre></td></tr></table></figure><p>eg:查询员工 及其 所属领导的名字</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> a.name , b.name <span class="hljs-keyword">from</span> emp a , emp b <span class="hljs-keyword">where</span> a.managerid = b.id;(内连接)<br></code></pre></td></tr></table></figure><p>eg:查询所有员工 emp 及其领导的名字 emp , <strong>如果员工没有领导, 也需要查询出来</strong> -&gt; 外连接 表结构: emp a , emp b</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> a.name <span class="hljs-string">&#x27;员工&#x27;</span>, b.name <span class="hljs-string">&#x27;领导&#x27;</span> <span class="hljs-keyword">from</span> emp a <span class="hljs-keyword">left join</span> emp b <span class="hljs-keyword">on</span> a.managerid = b.id;<br></code></pre></td></tr></table></figure></li><li><p>子查询：SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> column1 = ( <span class="hljs-keyword">SELECT</span> column1 <span class="hljs-keyword">FROM</span> t2 ) <br></code></pre></td></tr></table></figure><ul><li>标量子查询（子查询结果为单个值）eg:查询 “销售部” 的所有员工信息</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id = (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;销售部&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>列子查询(子查询结果为一列) eg: 查询 “销售部” 和 “市场部” 的所有员工信息</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;销售部&#x27;</span> <span class="hljs-keyword">or</span><br><span class="hljs-type">name</span> = <span class="hljs-string">&#x27;市场部&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>行子查询(子查询结果为一行) eg:查询与 “张无忌” 的薪资及直属领导相同的员工信息 ;</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> (salary,managerid) = (<span class="hljs-keyword">select</span> salary, managerid <span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;张无忌&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>表子查询(子查询结果为多行多列) eg: 查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">e</span>.*, d.* <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> entrydate &gt; <span class="hljs-string">&#x27;2006-01-01&#x27;</span>) <span class="hljs-built_in">e</span> <span class="hljs-keyword">left</span><br><span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> <span class="hljs-built_in">e</span>.dept_id = d.id ;<br></code></pre></td></tr></table></figure></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h3><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><p>上述就是事务的四大特性，简称ACID。</p><h3 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h3><ul><li>赃读：一个事务读到另外一个事务还没有提交的数据。</li></ul><p><img src="/../mysql_pic/37.png"></p><ul><li>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</li></ul><p><img src="/../mysql_pic/38.png"></p><p>事务A两次读取同一条记录，但是读取到的数据却是不一样的.</p><ul><li>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 “幻影”</li></ul><p><img src="/../mysql_pic/39.png"></p><p>为什么会出现幻读？因为已经解决了上面的不可重复度，所以两次查询的结果是一样的，误以为没有数据，其实事务B已经插入了。</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：</p><p><img src="/../mysql_pic/40.png"></p><ul><li>查看事务隔离级别</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">SELECT</span> @<span class="hljs-symbol">@TRANSACTION_ISOLATION</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>设置事务隔离级别</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SET</span> [ <span class="hljs-keyword">SESSION</span> | <span class="hljs-keyword">GLOBAL</span> ] <span class="hljs-keyword">TRANSACTION</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> &#123; <span class="hljs-keyword">READ</span> <span class="hljs-keyword">UNCOMMITTED</span> |<br><span class="hljs-keyword">READ</span> <span class="hljs-keyword">COMMITTED</span> | <span class="hljs-keyword">REPEATABLE</span> <span class="hljs-keyword">READ</span> | <span class="hljs-keyword">SERIALIZABLE</span> &#125;<br></code></pre></td></tr></table></figure><p>事务隔离级别越高，数据越安全，但是性能越低</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是帮助MySQL高效获取数据的数据结构(有序)。</p><p><img src="/../mysql_pic/1.png"></p><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p><strong>聚簇索引（Clustered Index）即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引</strong></p><p>聚簇索引（Clustered Index）一般指的是主键索引（如果存在主键索引的话），聚簇索引也被称之为聚集索引。</p><p>聚簇索引在 InnoDB 中是使用 B+ 树实现的，比如我们创建一张 student 表，它的构建 SQL 如下：</p><p><img src="/../mysql_pic/2.png"></p><p>以上 student 表中有一个聚簇索引（也就是主键索引）id，和一个非聚簇索引 class_id。</p><p>聚簇索引 id 对应的 B+ 树如下图所示：</p><p><img src="/../mysql_pic/3.png"></p><p>在聚簇索引的叶子节点的data区直接存储用户信息的内存地址，我们使用内存地址可以直接找到相应的行数据。</p><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>非聚簇索引在 InnoDB 引擎中，也叫二级索引，以上面 student 表为例，在 student 中非聚簇索引 class_id 对应 B+ 树如下图所示：</p><p><img src="/../mysql_pic/4.png"></p><p>从上图我们可以看出，<strong>在非聚簇索引的叶子节点上的data存储的并不是真正的行数据，而是主键 ID，所以当我们使用非聚簇索引进行查询时，首先会得到一个主键 ID，然后再使用主键 ID 去聚簇索引上找到真正的行数据，我们把这个过程称之为回表查询。</strong></p><p><strong>总结：</strong></p><p>在 MySQL 的 InnoDB 引擎中，每个索引都会对应一颗 B+ 树，而聚簇索引和非聚簇索引最大的区别在于叶子节点存储的数据不同，聚簇索引叶子节点存储的是行数据，因此通过聚簇索引可以直接找到真正的行数据；而非聚簇索引叶子节点存储的是主键信息，所以使用非聚簇索引还需要回表查询，因此我们可以得出聚簇索引和非聚簇索引的区别主要有以下几个：</p><ul><li>聚簇索引叶子节点data存储的是行数据；而非聚簇索引叶子节点data存储的是聚簇索引（通常是主键 ID）。</li><li>聚簇索引查询效率更高，而非聚簇索引需要进行回表查询，因此性能不如聚簇索引。</li><li>聚簇索引一般为主键索引，而主键一个表中只能有一个，因此聚簇索引一个表中也只能有一个，而非聚簇索引则没有数量上的限制。</li></ul><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><h4 id="对索引使用左或者左右模糊匹配"><a href="#对索引使用左或者左右模糊匹配" class="headerlink" title="对索引使用左或者左右模糊匹配"></a>对索引使用左或者左右模糊匹配</h4><p>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效。</p><p>比如下面的 like 语句，查询 name 后缀为「林」的用户，执行计划中的 type&#x3D;ALL 就代表了全表扫描，而没有走索引。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-type">name</span> 字段为二级索引<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%林&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/85.png"></p><p>如果是查询 name 前缀为林的用户，那么就会走索引扫描，执行计划中的 type&#x3D;range 表示走索引扫描，key&#x3D;index_name 看到实际走了 index_name 索引：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-type">name</span> 字段为二级索引<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;林%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/86.png"></p><p><strong>为什么 like 关键字左或者左右模糊匹配无法走索引呢？</strong></p><p><strong>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</strong></p><p>举个例子，下面这张二级索引图是以 name 字段有序排列存储的。</p><p><img src="/../mysql_pic/87.png"></p><p>假设我们要查询 name 字段前缀为「林」的数据，也就是 <code>name like &#39;林%&#39;</code>，扫描索引的过程：</p><ul><li>首节点查询比较：林这个字的拼音大小比首节点的第一个索引值中的陈字大，但是比首节点的第二个索引值中的周字小，所以选择去节点2继续查询；</li><li>节点 2 查询比较：节点2的第一个索引值中的陈字的拼音大小比林字小，所以继续看下一个索引值，发现节点2有与林字前缀匹配的索引值，于是就往叶子节点查询，即叶子节点4；</li><li>节点 4 查询比较：节点4的第一个索引值的前缀符合林字，于是就读取该行数据，接着继续往右匹配，直到匹配不到前缀为林的索引值。</li></ul><p>如果使用 <code>name like &#39;%林&#39;</code> 方式来查询，因为查询的结果可能是「陈林、张林、周林」等之类的，所以不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。</p><h4 id="对索引使用函数"><a href="#对索引使用函数" class="headerlink" title="对索引使用函数"></a>对索引使用函数</h4><p>有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。</p><p>比如下面这条语句查询条件中对 name 字段使用了 LENGTH 函数，执行计划中的 type&#x3D;ALL，代表了全表扫描：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-type">name</span> 为二级索引<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> length(<span class="hljs-type">name</span>)=<span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/88.png"></p><p><code>为什么对索引使用函数，就无法走索引了呢？</code></p><p><strong>因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</strong></p><p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p><p>举个例子，我通过下面这条语句，对 length(name) 的计算结果建立一个名为 idx_name_length 的索引。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t_user <span class="hljs-keyword">add</span> key idx_name_length ((length(<span class="hljs-type">name</span>)));<br></code></pre></td></tr></table></figure><p>然后我再用下面这条查询语句，这时候就会走索引了。</p><p><img src="/../mysql_pic/89.png"></p><h4 id="对索引进行表达式计算"><a href="#对索引进行表达式计算" class="headerlink" title="对索引进行表达式计算"></a>对索引进行表达式计算</h4><p>在查询条件中对索引进行表达式计算，也是无法走索引的。</p><p>比如，下面这条查询语句，执行计划中 type &#x3D; ALL，说明是通过全表扫描的方式查询数据的：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id + <span class="hljs-number">1</span> = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>但是，如果把查询语句的条件改成 where id &#x3D; 10 - 1，这样就不是在索引字段进行表达式计算了，于是就可以走索引查询了。</p><p><code>为什么对索引进行表达式计算，就无法走索引了呢？</code></p><p>原因跟对索引使用函数差不多。</p><p>因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。</p><h4 id="对索引隐式类型转换"><a href="#对索引隐式类型转换" class="headerlink" title="对索引隐式类型转换"></a>对索引隐式类型转换</h4><p>如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。</p><p>我在原本的 t_user 表增加了 phone 字段，是二级索引且类型是 varchar。</p><p><img src="/../mysql_pic/90.png"></p><p>然后我在条件查询中，用整型作为输入参数，此时执行计划中 type &#x3D; ALL，所以是通过全表扫描来查询数据的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">select * from t_user where phone = 1300000001;<br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/91.png"></p><p><strong>但是如果索引字段是整型类型，查询条件中的输入参数即使字符串，是不会导致索引失效，还是可以走索引扫描。</strong></p><p>我们再看第二个例子，id 是整型，但是下面这条语句还是走了索引扫描的。</p><p><img src="/../mysql_pic/92.png"></p><p><code>为什么第一个例子会导致索引失效，而第二例子不会呢？</code></p><p>要明白这个原因，首先我们要知道 MySQL 的数据类型转换规则是什么？就是看 MySQL 是会将字符串转成数字处理，还是将数字转换成字符串处理。</p><p>我在看《mysql45讲的时候》看到一个简单的测试方式，就是通过 select “10” &gt; 9 的结果来知道MySQL 的数据类型转换规则是什么：</p><ul><li>如果规则是 MySQL 会将自动「字符串」转换成「数字」，就相当于 select 10 &gt; 9，这个就是数字比较，所以结果应该是 1；</li><li>如果规则是 MySQL 会将自动「数字」转换成「字符串」，就相当于 select “10” &gt; “9”，这个是字符串比较，字符串比较大小是逐位从高位到低位逐个比较（按ascii码） ，那么”10”字符串相当于 “1”和“0”字符的组合，所以先是拿 “1” 字符和 “9” 字符比较，因为 “1” 字符比 “9” 字符小，所以结果应该是 0。</li></ul><p>在 MySQL 中，执行的结果如下图：</p><p><img src="/../mysql_pic/93.png"></p><p>上面的结果为 1，说明 <strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong>。</p><p>前面的例子一中的查询语句，我也跟大家说了是会走全表扫描：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//例子一的查询语句</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> phone = <span class="hljs-number">1300000001</span>;<br></code></pre></td></tr></table></figure><p>这是因为 phone 字段为字符串，所以 MySQL 要会自动把字符串转为数字，所以这条语句相当于：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> CAST(phone <span class="hljs-keyword">AS</span> signed <span class="hljs-type">int</span>) = <span class="hljs-number">1300000001</span>;<br></code></pre></td></tr></table></figure><p>可以看到，<strong>CAST 函数是作用在了 phone 字段，而 phone 字段是索引，也就是对索引使用了函数！而前面我们也说了，对索引使用函数是会导致索引失效的</strong>。</p><p>例子二中的查询语句，我跟大家说了是会走索引扫描：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//例子二的查询语句</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id = <span class="hljs-string">&quot;1&quot;</span>;<br></code></pre></td></tr></table></figure><p>这时因为字符串部分是输入参数，也就需要将字符串转为数字，所以这条语句相当于：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id = CAST(&quot;1&quot; <span class="hljs-keyword">AS</span> signed <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><p>可以看到，索引字段并没有用任何函数，CAST 函数是用在了输入参数，因此是可以走索引扫描的</p><h4 id="联合索引非最左匹配"><a href="#联合索引非最左匹配" class="headerlink" title="联合索引非最左匹配"></a>联合索引非最左匹配</h4><p>对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。</p><p>那么<strong>多个普通字段组合在一起创建的索引就叫做联合索引</strong>，也叫组合索引。</p><p>创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。</p><p>联合索引要能正确使用需要遵循<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。</p><p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p><ul><li>where a&#x3D;1；</li><li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li><li>where a&#x3D;1 and b&#x3D;2；</li></ul><p><strong>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</strong></p><p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p><ul><li>where b&#x3D;2；</li><li>where c&#x3D;3；</li><li>where b&#x3D;2 and c&#x3D;3；</li></ul><p>有一个比较特殊的查询条件：where a &#x3D; 1 and c &#x3D; 3 ，符合最左匹配吗？</p><p>MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。</p><p>从 MySQL 5.6 之后，有一个<strong>索引下推功能</strong>，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。</p><p>索引下推的大概原理是：截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 <code>(a, b, c)</code> 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。</p><p>比如下面这条 where a &#x3D; 1 and c &#x3D; 0 语句，我们可以从执行计划中的 Extra&#x3D;Using index condition 使用了索引下推功能。</p><p><img src="/../mysql_pic/94.png"></p><p><code>为什么联合索引不遵循最左匹配原则就会失效？</code></p><p>原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</p><p>也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。</p><h4 id="WHERE-子句中的-OR"><a href="#WHERE-子句中的-OR" class="headerlink" title="WHERE 子句中的 OR"></a>WHERE 子句中的 OR</h4><p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p><p>举个例子，比如下面的查询语句，id 是主键，age 是普通列，从执行计划的结果看，是走了全表扫描。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">select * from t_user where id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> or age <span class="hljs-operator">=</span> <span class="hljs-number">18</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/95.png"></p><p>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</p><p>要解决办法很简单，将 age 字段设置为索引即可。</p><p><img src="/../mysql_pic/96.png"></p><p>可以看到 type&#x3D;index merge， index merge 的意思就是对 id 和 age 分别进行了扫描，然后将这两个结果集进行了合并，这样做的好处就是避免了全表扫描</p><p><strong>总结</strong></p><p>今天给大家介绍了 6 种会发生索引失效的情况：</p><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li><li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;tom&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;cat&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;jerry&#x27;</span>);<br>.....<br></code></pre></td></tr></table></figure><ul><li>优化方案一</li></ul><p><strong>批量插入数据</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">Insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>优化方案二</li></ul><p><strong>手动控制事务</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">begine;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">7</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><ul><li>优化方案三</li></ul><p>主键顺序插入，性能要高于乱序插入。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">主键乱序插入 :<span class="hljs-number"> 8 </span>1<span class="hljs-number"> 9 </span>21<span class="hljs-number"> 88 </span>2<span class="hljs-number"> 4 </span>15<span class="hljs-number"> 89 </span>5<span class="hljs-number"> 7 </span>3<br>主键顺序插入 :<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 5 </span>7<span class="hljs-number"> 8 </span>9<span class="hljs-number"> 15 </span>21<span class="hljs-number"> 88 </span>89<br></code></pre></td></tr></table></figure><h4 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h4><p>如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使 用MySQL数据库提供的load指令进行插入。操作如下：</p><p><img src="/../mysql_pic/61.png"></p><p>可以执行如下指令，将数据脚本文件中的数据加载到表结构中：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 客户端连接服务端时，加上参数 -–local-infile</span><br>mysql –-<span class="hljs-keyword">local</span>-infile -u root -p<br><br><span class="hljs-comment">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> local_infile = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">-- 执行load指令将准备好的数据，加载到表结构中</span><br><span class="hljs-keyword">load</span> data <span class="hljs-keyword">local</span> infile <span class="hljs-string">&#x27;/root/sql1.log&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> tb_user fields<br>terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;,&#x27;</span> lines terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\n&#x27;</span> ;<br></code></pre></td></tr></table></figure><p><code>主键顺序插入性能高于乱序插入</code></p><p>演示：</p><ul><li>创建表结构</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE <span class="hljs-symbol">`tb_user`</span> (<br><span class="hljs-symbol">`id`</span> INT(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,<br><span class="hljs-symbol">`username`</span> VARCHAR(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br><span class="hljs-symbol">`password`</span> VARCHAR(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br><span class="hljs-symbol">`name`</span> VARCHAR(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br><span class="hljs-symbol">`birthday`</span> DATE DEFAULT <span class="hljs-literal">NULL</span>,<br><span class="hljs-symbol">`sex`</span> CHAR(<span class="hljs-number">1</span>) DEFAULT <span class="hljs-literal">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-symbol">`id`</span>),<br><span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">KEY</span> <span class="hljs-symbol">`unique_user_username`</span> (<span class="hljs-symbol">`username`</span>)<br>) ENGINE=INNODB DEFAULT CHARSET=utf8 ;<br></code></pre></td></tr></table></figure><ul><li>设置参数</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">-- 客户端连接服务端时，加上参数 -–<span class="hljs-keyword">local</span>-<span class="hljs-keyword">infile</span><br>mysql –-<span class="hljs-keyword">local</span>-<span class="hljs-keyword">infile</span> -<span class="hljs-keyword">u</span> root -p<br><br>-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> local_infile = 1;<br></code></pre></td></tr></table></figure><ul><li>load加载数据</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">load</span> data <span class="hljs-keyword">local</span> infile <span class="hljs-string">&#x27;/root/load_user_100w_sort.sql&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> tb_user<br>fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;,&#x27;</span> lines terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\n&#x27;</span> ;<br></code></pre></td></tr></table></figure><p>我们看到，插入100w的记录，17s就完成了，性能很好。</p><p><code>在load时，主键顺序插入性能高于乱序插入</code></p><h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p>在上一小节，我们提到，主键顺序插入的性能是要高于乱序插入的。 这一小节，就来介绍一下具体的 原因，然后再分析一下主键又该如何设计。</p><ul><li>数据组织方式</li></ul><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表 (index organized table IOT)。</p><p><img src="/../mysql_pic/62.png"></p><p>行数据，都是存储在聚集索引的叶子节点上的。而我们之前也讲解过InnoDB的逻辑结构图：</p><p><img src="/../mysql_pic/63.png"></p><p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。 那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储 到下一个页中，页与页之间会通过指针连接。</p><h4 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h4><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行 溢出)，根据主键排列。</p><p> 主键顺序插入效果：</p><ul><li>从磁盘中申请页， 主键顺序插入</li></ul><p><img src="/../mysql_pic/64.png"></p><ul><li>第一个页没有满，继续往第一页插入</li></ul><p><img src="/../mysql_pic/65.png"></p><ul><li>当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</li></ul><p><img src="/../mysql_pic/66.png"></p><ul><li>当第二页写满了，再往第三页写入</li></ul><p><img src="/../mysql_pic/67.png"></p><p>主键乱序插入效果：</p><ul><li>加入1#,2#页都已经写满了，存放了如图所示的数据</li></ul><p><img src="/../mysql_pic/68.png"></p><ul><li>此时再插入id为50的记录，我们来看看会发生什么现象</li></ul><p>会再次开启一个页，写入新的页中吗？</p><p><img src="/../mysql_pic/69.png"></p><p>不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在47之后。</p><p><img src="/../mysql_pic/70.png"></p><p>但是47所在的1#页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 3#。</p><p><img src="/../mysql_pic/71.png"></p><p>上述的这种现象，称之为 “页分裂”，是比较耗费性能的操作。</p><h4 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h4><p>目前表中已有数据的索引结构(叶子节点)如下：</p><p><img src="/../mysql_pic/72.png"></p><p>当我们对已有数据进行删除时，具体的效果如下:</p><p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间 变得允许被其他记录声明使用。</p><p><img src="/../mysql_pic/73.png"></p><p>当我们继续删除2#的数据记录</p><p><img src="/../mysql_pic/74.png"></p><p>这个里面所发生的合并页的这个现象，就称之为 “页合并”。</p><p><code>知识小贴士： MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</code></p><h4 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h4><ul><li>满足业务需求的情况下，尽量降低主键的长度</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li><li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li><li>业务操作时，避免对主键的修改。</li></ul><h3 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h3><p>MySQL的排序，有两种方式(explain分析时看extra字段)：</p><ul><li>Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</li><li>Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要 额外排序，操作效率高。</li></ul><p>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序 操作时，尽量要优化为 Using index。</p><p>接下来，我们来做一个测试：</p><ul><li>数据准备</li></ul><p>把之前测试时，为tb_user表所建立的部分索引直接删除掉</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_user_phone <span class="hljs-keyword">on</span> tb_user;<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_user_phone_name <span class="hljs-keyword">on</span> tb_user;<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_user_name <span class="hljs-keyword">on</span> tb_user;<br></code></pre></td></tr></table></figure><ul><li>执行排序SQL</li></ul><p>explain select id,age,phone from tb_user order by age ;</p><p><img src="/../mysql_pic/75.png"></p><p>explain select id,age,phone from tb_user order by age, phone ;</p><p><img src="/../mysql_pic/76.png"></p><p>由于 age, phone 都没有索引，所以此时再排序时，出现Using filesort， 排序性能较低。</p><ul><li>创建索引</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 创建索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_user_age_phone_aa <span class="hljs-keyword">on</span> tb_user(age,phone);<br></code></pre></td></tr></table></figure><ul><li>创建索引后，根据age, phone进行升序排序</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age;<br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/77.png"></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age , phone;<br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/77.png"></p><p>建立索引之后，再次进行排序查询，就由原来的Using filesort， 变为了 Using index，性能 就是比较高的了。</p><p>E. 创建索引后，根据age, phone进行降序排序</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">desc</span> , phone <span class="hljs-keyword">desc</span> ;<br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/78.png"></p><p>也出现 Using index， 但是此时Extra中出现了 Backward index scan，这个代表反向扫描索 引，因为在MySQL中我们创建的索引，默认索引的叶子节点是从小到大排序的，而此时我们查询排序 时，是从大到小，所以，在扫描时，就是反向扫描，就会出现 Backward index scan。 在 MySQL8版本中，支持降序索引，我们也可以创建降序索引。</p><ul><li>根据phone，age进行升序排序，phone在前，age在后。</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> phone , age;<br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/79.png"></p><p>排序时,也需要满足最左前缀法则,否则也会出现 filesort。因为在创建索引的时候， age是第一个 字段，phone是第二个字段，所以排序时，也就该按照这个顺序来，否则就会出现 Using filesort。</p><ul><li>创建联合索引(age 升序排序，phone 倒序排序)</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_user_age_phone_ad <span class="hljs-keyword">on</span> tb_user(age <span class="hljs-keyword">asc</span> ,phone <span class="hljs-keyword">desc</span>);<br></code></pre></td></tr></table></figure><p>升序&#x2F;降序联合索引结构图示:</p><p><img src="/../mysql_pic/80.png"></p><p><img src="/../mysql_pic/81.png"></p><p>由上述的测试,我们得出order by优化原则:</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li><li>尽量使用覆盖索引。</li><li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）。</li><li>果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)。</li></ul><h3 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h3><p>分组操作，我们主要来看看索引对于分组操作的影响。</p><p>首先我们先将 tb_user 表的索引全部删除掉.</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_user_pro_age_sta <span class="hljs-keyword">on</span> tb_user;<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_email_5 <span class="hljs-keyword">on</span> tb_user;<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_user_age_phone_aa <span class="hljs-keyword">on</span> tb_user;<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> idx_user_age_phone_ad <span class="hljs-keyword">on</span> tb_user;<br></code></pre></td></tr></table></figure><p>接下来，在没有索引的情况下，执行如下SQL，查询执行计划：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> profession , <span class="hljs-built_in">count</span>(*) <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> profession<br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/82.png"></p><p>使用临时表，性能较低</p><p>然后，我们在针对于 profession ， age， status 创建一个联合索引。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">create index idx_user_pro_age_sta on tb<span class="hljs-constructor">_user(<span class="hljs-params">profession</span> , <span class="hljs-params">age</span> , <span class="hljs-params">status</span>)</span>;<br></code></pre></td></tr></table></figure><p>紧接着，再执行前面相同的SQL查看执行计划。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> profession , <span class="hljs-built_in">count</span>(*) <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> profession <br></code></pre></td></tr></table></figure><p><img src="/../mysql_pic/83.png"></p><p>我们发现，如果仅仅根据age分组，就会出现 Using temporary ；而如果是 根据 profession,age两个字段同时分组，则不会出现 Using temporary。原因是因为对于分组操作， 在联合索引中，也是符合最左前缀法则的。</p><p>所以，在分组操作中，我们需要通过以下两点进行优化，以提升性能：</p><ul><li>在分组操作时，可以通过索引来提高效率。</li><li>分组操作时，索引的使用也是满足最左前缀法则的。</li></ul><h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h3><p><code>select count(*) from tb_user</code></p><p>在之前的测试中，我们发现，如果数据量很大，在执行count操作时，是非常耗时的。</p><ul><li><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个 数，效率很高； 但是如果是带条件的count，MyISAM也慢。</p></li><li><p>InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出 来，然后累积计数。</p></li></ul><p>如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数 据库进行,但是如果是带条件的count又比较麻烦了)。</p><p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加，最后返回累计值。 用法：count（*）、count（主键）、count（字段）、count（数字）</p><p><img src="/../mysql_pic/84.png"></p><h3 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h3><p>我们主要需要注意一下update语句执行时的注意事项。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span> course <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;javaEE&#x27;</span> <span class="hljs-keyword">where</span> id = <span class="hljs-number">1</span> ;<br></code></pre></td></tr></table></figure><p>当我们在执行删除的SQL语句时，会锁定id为1这一行的数据，然后事务提交之后，行锁释放。</p><p>但是当我们在执行如下SQL时。</p> <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span> course <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;SpringBoot&#x27;</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;PHP&#x27;</span> ;<br></code></pre></td></tr></table></figure><p>当我们开启多个事务，在执行上述的SQL时，我们发现行锁升级为了表锁。 导致该update语句的性能 大大降低</p><p><code>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁 升级为表锁 。</code></p><p><strong>所以我们应该给条件创建索引，不然行锁会升级为表锁，并发性能降低</strong></p><h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p><p>越往后，分页查询效率越低，这就是分页查询的问题所在。</p><p>因为，当在进行分页查询时，如果执行 limit 2000000,10 ，此时需要MySQL排序前2000010 记 录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p><p>优化思路: <strong>一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查 询形式进行优化</strong>。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_sku t , (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_sku <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id<br><span class="hljs-keyword">limit</span> <span class="hljs-number">2000000</span>,<span class="hljs-number">10</span>) a <span class="hljs-keyword">where</span> t.id = a.id;<br></code></pre></td></tr></table></figure><h3 id="平时写SQL时该注意什么？有什么经验可谈？"><a href="#平时写SQL时该注意什么？有什么经验可谈？" class="headerlink" title="平时写SQL时该注意什么？有什么经验可谈？"></a>平时写SQL时该注意什么？有什么经验可谈？</h3><ul><li><p>统计时尽量使用count(*)</p></li><li><p>如果明确查找一条语句，请使用<code>limit 1</code>,因为找到一条符合条件的记录就不会继续查找了</p></li><li><p>避免使用select * ，用到什么字段就具体写什么字段，原因除了select * 查询所有字段会多出网络开销之外，还有更重要的一点就是select * 无法使用覆盖索引。</p></li><li><p>对于使用索引方面</p><ul><li><p>对索引字段做函数操作或者做运算操作，都不能使用上索引。<br>所以针对这一点，除了我们索引的字段不要加函数之外。</p></li><li><p>还要注意一些隐式转换，比如，交易日志表（tradelog），tradeid 的字段类型是 varchar(32)，字段有索引，但是当你执行 <code>select * from tradelog where tradeid=110717;</code>语句，你发现走的还是全索引扫描。这是因为它其实做了类型转换，相当于这么执行<code>mysql&gt; select * from tradelog where  CAST(tradid AS signed int) = 110717;</code>。</p></li><li><p>隐式字符编码转换</p><p>如果两张表使用的编码集不一致，比如一个是utf8mb4，一个是utf8，那么这两个字段连接后，相当于做了一次<code>CONVERT(traideid USING utf8mb4)</code>,这样也用不了索引。其实字符集不同只是条件之一，连接过程中要求在被驱动表的索引字段上加函数操作，是直接导致对被驱动表做全表扫描的原因。</p></li></ul></li><li><p>如果设计到多表查询查询，那么首先应该确定设计哪几张表，然后分析他们之间的连接条件，最后确定查询字段。</p></li></ul><h3 id="MySQL执行计划分析-EXPLAIN"><a href="#MySQL执行计划分析-EXPLAIN" class="headerlink" title="MySQL执行计划分析(EXPLAIN)"></a>MySQL执行计划分析(EXPLAIN)</h3><p>优化 SQL 的第一步应该是读懂 SQL 的执行计划。本篇文章，我们一起来学习下 MySQL <code>EXPLAIN</code> 执行计划相关知识。</p><h4 id="什么是执行计划？"><a href="#什么是执行计划？" class="headerlink" title="什么是执行计划？"></a>什么是执行计划？</h4><p><strong>执行计划</strong> 是指一条 SQL 语句在经过 <strong>MySQL 查询优化器</strong> 的优化会后，具体的执行方式。</p><p>执行计划通常用于 SQL 性能分析、优化等场景。通过 <code>EXPLAIN</code> 的结果，可以了解到如数据表的查询顺序、数据查询操作的操作类型、哪些索引可以被命中、哪些索引实际会命中、每个数据表有多少行记录被查询等信息。</p><h4 id="如何获取执行计划？"><a href="#如何获取执行计划？" class="headerlink" title="如何获取执行计划？"></a>如何获取执行计划？</h4><p>MySQL 为我们提供了 <code>EXPLAIN</code> 命令，来获取执行计划的相关信息。</p><p>需要注意的是，<code>EXPLAIN</code> 语句并不会真的去执行相关的语句，而是通过查询优化器对语句进行分析，找出最优的查询方案，并显示对应的信息。</p><p><code>EXPLAIN</code> 执行计划支持 <code>SELECT</code>、<code>DELETE</code>、<code>INSERT</code>、<code>REPLACE</code> 以及 <code>UPDATE</code> 语句。我们一般多用于分析 <code>SELECT</code> 查询语句，使用起来非常简单，语法如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">EXPLAIN</span> + <span class="hljs-keyword">SELECT</span> 查询语句；<br></code></pre></td></tr></table></figure><p>我们简单来看下一条查询语句的执行计划：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; explain SELECT <span class="hljs-symbol">*</span> FROM dept_emp WHERE emp_no IN (SELECT emp_no FROM dept_emp GROUP BY emp_no HAVING COUNT(emp_no)&gt;1);<br>+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+<br>|<span class="hljs-string"> id </span>|<span class="hljs-string"> select_type </span>|<span class="hljs-string"> table    </span>|<span class="hljs-string"> partitions </span>|<span class="hljs-string"> type  </span>|<span class="hljs-string"> possible_keys   </span>|<span class="hljs-string"> key     </span>|<span class="hljs-string"> key_len </span>|<span class="hljs-string"> ref  </span>|<span class="hljs-string"> rows   </span>|<span class="hljs-string"> filtered </span>|<span class="hljs-string"> Extra       </span>|<br>+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+<br>|<span class="hljs-string">  1 </span>|<span class="hljs-string"> PRIMARY     </span>|<span class="hljs-string"> dept_emp </span>|<span class="hljs-string"> NULL       </span>|<span class="hljs-string"> ALL   </span>|<span class="hljs-string"> NULL            </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string"> NULL </span>|<span class="hljs-string"> 331143 </span>|<span class="hljs-string">   100.00 </span>|<span class="hljs-string"> Using where </span>|<br>|<span class="hljs-string">  2 </span>|<span class="hljs-string"> SUBQUERY    </span>|<span class="hljs-string"> dept_emp </span>|<span class="hljs-string"> NULL       </span>|<span class="hljs-string"> index </span>|<span class="hljs-string"> PRIMARY,dept_no </span>|<span class="hljs-string"> PRIMARY </span>|<span class="hljs-string"> 16      </span>|<span class="hljs-string"> NULL </span>|<span class="hljs-string"> 331143 </span>|<span class="hljs-string">   100.00 </span>|<span class="hljs-string"> Using index </span>|<br>+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+<br><br></code></pre></td></tr></table></figure><p>可以看到，执行计划结果中共有 12 列，各列代表的含义总结如下表：</p><p><img src="/../mysql_pic/97.png"></p><h4 id="如何分析-EXPLAIN-结果？"><a href="#如何分析-EXPLAIN-结果？" class="headerlink" title="如何分析 EXPLAIN 结果？"></a>如何分析 EXPLAIN 结果？</h4><p>为了分析 <code>EXPLAIN</code> 语句的执行结果，我们需要搞懂执行计划中的重要字段。</p><h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>SELECT 标识符，是查询中 SELECT 的序号，用来标识整个查询中 SELELCT 语句的顺序。</p><p>id 如果相同，从上往下依次执行。id 不同，id 值越大，执行优先级越高，如果行引用其他行的并集结果，则该值可以为 NULL.</p><h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h5><p>查询的类型，主要用于区分<strong>普通查询</strong>、<strong>联合查询</strong>、<strong>子查询</strong>等复杂的查询，常见的值有：</p><ul><li><strong>SIMPLE</strong>：简单查询，不包含 UNION 或者子查询。</li><li><strong>PRIMARY</strong>：查询中如果包含子查询或其他部分，外层的 SELECT 将被标记为 PRIMARY。</li><li><strong>SUBQUERY</strong>：子查询中的第一个 SELECT。</li><li><strong>UNION</strong>：在 UNION 语句中，UNION 之后出现的 SELECT。</li><li><strong>DERIVED</strong>：在 FROM 中出现的子查询将被标记为 DERIVED。</li><li><strong>UNION RESULT</strong>：UNION 查询的结果。</li></ul><h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><p>查询用到的表名，每行都有对应的表名，表名除了正常的表之外，也可能是以下列出的值：</p><ul><li><strong><code>&lt;unionM,N&gt;</code></strong> : 本行引用了 id 为 M 和 N 的行的 UNION 结果</li><li><strong><code>&lt;derivedN&gt;</code></strong> : 本行引用了 id 为 N 的表所产生的的派生表结果。派生表有可能产生自 FROM 语句中的子查询。 </li><li><strong><code>&lt;subqueryN&gt;</code></strong> : 本行引用了 id 为 N 的表所产生的的物化子查询结果。</li></ul><h5 id="type（重要）"><a href="#type（重要）" class="headerlink" title="type（重要）"></a>type（重要）</h5><p><strong>查询执行的类型</strong>，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p>常见的几种类型具体含义如下：</p><ul><li><p><strong>system</strong>：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。</p></li><li><p><strong>const</strong>：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。</p></li><li><p><strong>eq_ref</strong>：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。</p></li><li><p><strong>ref</strong>：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</p></li><li><p><strong>index_merge</strong>：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。</p></li><li><p><strong>range</strong>：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。</p></li><li><p><strong>index</strong>：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</p></li><li><p><strong>ALL</strong>：全表扫描。</p></li></ul><h4 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h4><p>possible_keys 列表示 MySQL 执行查询时可能用到的索引。如果这一列为 NULL ，则表示没有可能用到的索引；这种情况下，需要检查 WHERE 语句中所使用的的列，看是否可以通过给这些列中某个或多个添加索引的方法来提高查询性能.</p><h4 id="key（重要）"><a href="#key（重要）" class="headerlink" title="key（重要）"></a>key（重要）</h4><p>key 列表示 MySQL 实际使用到的索引。如果为 NULL，则表示未用到索引。</p><h4 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h4><p>key_len 列表示 MySQL 实际使用的索引的最大长度；当使用到联合索引时，有可能是多个列的长度和。在满足需求的前提下越短越好。如果 key 列显示 NULL ，则 key_len 列也显示 NULL 。</p><h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h4><p>rows 列表示根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。</p><h4 id="Extra（重要）"><a href="#Extra（重要）" class="headerlink" title="Extra（重要）"></a>Extra（重要）</h4><p>这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：</p><ul><li><p><strong>Using filesort</strong>：在排序时使用了外部的索引排序，没有用到表内索引进行排序。</p></li><li><p><strong>Using temporary</strong>：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY</p></li><li><p><strong>Using index</strong>：表明查询使用了覆盖索引，不用回表，查询效率非常高。</p></li><li><p><strong>Using index condition</strong>：表示查询优化器选择使用了索引条件下推这个特性。</p></li><li><p><strong>Using where</strong>：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。</p></li><li><p>**Using join buffer (Block Nested Loop)**：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。</p></li></ul><p>这里提醒下，当 Extra 列包含 Using filesort 或 Using temporary 时，MySQL 的性能可能会存在问题，需要尽可能避免。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、 RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有 效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个 角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ul><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据。</li></ul><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语 句，已经更新操作的事务提交语句都将被阻塞。</p><p>其典型的使用场景是做**全库的逻辑备份(把表转为SQL文件)**，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p><p>为什么全库逻辑备份，就需要加全就锁呢？</p><p>下个单总不能表A库存没扣减，表B多了一条订单记录吧。</p><p><strong>加全局锁语法</strong></p><ul><li>加全局锁</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">flush <span class="hljs-keyword">tables</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">lock</span>;<br></code></pre></td></tr></table></figure><ul><li>数据备份</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">mysqldump -uroot –p1234 <span class="hljs-built_in">itcast</span>(数据库名) &gt; itcast<span class="hljs-selector-class">.sql</span><br></code></pre></td></tr></table></figure><p>也可以利用可视化软件直接备份</p><ul><li>释放锁</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">unlock tables<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>特点</strong></p><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ul><li><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</p></li><li><p>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</p></li></ul><p>在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致 性数据备份。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mysqldump <span class="hljs-comment">--single-transaction -uroot –p123456 itcast &gt; itcast.sql</span><br></code></pre></td></tr></table></figure><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、 InnoDB、BDB等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><ul><li>表锁</li><li>元数据锁（meta data lock，MDL）</li><li>意向锁</li></ul><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><ul><li>表共享读锁（read lock）</li><li>表独占写锁（write lock）</li></ul><p><strong>表锁语法</strong></p><ul><li>加锁：lock tables 表名… read&#x2F;write。</li><li>释放锁：unlock tables &#x2F; 客户端断开连接 。</li></ul><hr><p><strong>特点</strong></p><ul><li>读锁(表共享读锁)</li></ul><p><img src="/../mysql_pic/17.png"></p><p><strong>对指定表加了读锁，不会影响自己和其他客户端的读，但是自己进行DML&#x2F;DDL操作会报错，而其他客户端会阻塞</strong></p><ul><li>写锁(表独占写锁)</li></ul><p><img src="/../mysql_pic/18.png"></p><p><strong>对指定表加了写锁，不会影响自己的读写操作，但是会阻塞其他客户端的读写操作。</strong></p><h4 id="元数据锁-MDL-meta-data-lock"><a href="#元数据锁-MDL-meta-data-lock" class="headerlink" title="元数据锁(MDL,meta data lock)"></a>元数据锁(MDL,meta data lock)</h4><p>meta data lock , 元数据锁，简写MDL。</p><p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维 护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML(增删改)与 DDL  (Data Definition Language，即数据定义语言，例如建数据库、建表等，都属于数据定义语言)  冲突，保证读写的正确性。</strong></p><p>这里的元数据，大家可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务 时，是不能够修改这张表的表结构的。</p><p>在MySQL5.5中引入了MDL，<strong>当对一张表进行增删改查的时候，加MDL读锁(共享)<strong>；</strong>当对表结构进行变 更操作的时候，加MDL写锁(排他)。</strong></p><p><strong>常见的SQL操作时，所添加的元数据锁：</strong></p><p><img src="/../mysql_pic/19.png"></p><p><img src="/../mysql_pic/20.png"></p><p>可以看到2个客户端交叉执行DML操作是没问题的，因为DML加的是共享锁。</p><p><img src="/../mysql_pic/21.png"></p><p>当左侧执行一个DML语句，右侧执行一个DDL语句时，右侧操作被阻塞，因为DDL加的是DML写锁(与DML读锁互斥)，直到左侧提交事务，右侧才能执行。</p><p>我们可以通过下面的SQL，来查看数据库中的元数据锁的情况：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">select <span class="hljs-keyword">object</span><span class="hljs-number">_</span>type,<span class="hljs-keyword">object</span><span class="hljs-number">_</span>schema,<span class="hljs-keyword">object</span><span class="hljs-number">_n</span>ame,lock<span class="hljs-number">_</span>type,lock<span class="hljs-number">_</span>duration from<br>performance<span class="hljs-number">_</span>schema.metadata<span class="hljs-number">_</span>locks ;<br></code></pre></td></tr></table></figure><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一 下：</p><p><img src="/../mysql_pic/22.png"></p><p>首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。</p><p>当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，它的判断方式是每一行都检查一遍看是否有行锁，效率较低。(加了行锁之后是不能加表锁的)。</p><p><img src="/../mysql_pic/23.png"></p><p>有了意向锁之后 ：</p><p>客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁</p><p><img src="/../mysql_pic/24.png"></p><p>而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而 不用逐行判断行锁情况了。</p><p><img src="/../mysql_pic/25.png"></p><p><strong>介绍</strong></p><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行 数据是否加锁，使用意向锁来减少表锁的检查。</p><p><strong>分类</strong></p><ul><li>意向共享锁(IS): 由语句select … lock in share mode添加 。 与 表锁-共享锁 (read)(读锁)兼容，与表锁-排他锁(write)(写锁)互斥。</li><li>意向排他锁(IX): 由insert、update、delete、select…for update添加 。与表锁共 享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</li></ul><p><code>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</code></p><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><p><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;</code></p><p><img src="/../mysql_pic/26.png"></p><p>当客户端1对某条记录加上行锁并且给全表加上意向共享锁时，客户端2可以对表加上表读锁，但是当客户端2给表加上表写锁时，会阻塞。很好理解，线程1要读某条数据，客户端2也可以读，反正没影响，但是客户端2不能修改这条数据吧，客户端2修改了那我客户端1不是读了错的数据吗？</p><hr><p><img src="/../mysql_pic/27.png"></p><p>当客户端1使用DML语句时，给某条记录加上了行锁并且给全表加上了意向排他锁，此时客户端2无论是加表读锁还是表写锁都会阻塞，这也很好理解，我客户端1要修改某条数据，客户端1还未提交事务，数据还不确定，客户端2读取肯定是错的，那没必要读啊，那客户端2写就更不用说了，我客户端1都还没改完，你客户端2更别想改了(加表写锁)。</p><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p><strong>介绍</strong></p><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的 锁。对于行级锁，主要分为以下三类：</p><ul><li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在 RC、RR隔离级别下都支持。</li></ul><p><img src="/../mysql_pic/28.png"></p><ul><li>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事 务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</li></ul><p><img src="/../mysql_pic/29.png"></p><ul><li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。 在RR隔离级别下支持。</li></ul><p><img src="/../mysql_pic/30.png"></p><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>InnoDB实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li></ul><p>（共享锁与共享锁不冲突，共享锁与排他锁冲突，排他锁与排他锁冲突).</p><ul><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li></ul><p>两种行锁的兼容情况如下:</p><p><img src="/../mysql_pic/31.png"></p><p>常见的SQL语句，在执行时，所加的行锁如下：</p><p><img src="/../mysql_pic/32.png"></p><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁(临键锁)进行搜 索和索引扫描，以防止幻读。</p><ul><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li><li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记 录加锁，此时 就会<strong>升级为表锁</strong>。</li></ul><p><img src="/../mysql_pic/33.png"></p><p>因为行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记 录加锁，此时 就会升级为表锁，name没有索引，所以使用update会加上表锁，客户端2就无法使用更新操作了，会阻塞。</p><p>那么我们给name字段创建一个索引就不会升级为表锁了。create index xxx(名字) on table(name);</p><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="hljs-keyword">from</span><br>performance_schema.data_locks;<br></code></pre></td></tr></table></figure><h4 id="间隙锁-amp-临键锁"><a href="#间隙锁-amp-临键锁" class="headerlink" title="间隙锁&amp;临键锁"></a>间隙锁&amp;临键锁</h4><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜 索和索引扫描，以防止幻读。</p><ul><li>索引上的等值查询(唯一索引)，给<strong>不存在</strong>的记录加锁时, 优化为间隙锁 。</li></ul><p><img src="/../mysql_pic/34.png"></p><p>当给id为5的数据进行修改操作时，表中没有id为5的数据，那么会给id为3与8之间的间隙加间隙锁，当右侧客户端插入一条id为7的数据时，操作被阻塞。</p><ul><li>索引上的等值查询(<strong>非唯一普通索引</strong>)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁(间隙锁唯一的目的是防止其他事务插入间隙，<strong>间隙锁可以共存</strong>，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁)。</li></ul><p><img src="/../mysql_pic/35.png"></p><p>我们知道InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引查询值 为18的数据，并加上共享锁，我们是只锁定18这一行就可以了吗？ 并不是，因为是非唯一索引，这个 结构中可能有多个18的存在(<strong>非唯一普通索引</strong>)，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也 就是29）。此时会对18加临键锁，并对29之前的间隙加锁。</p><ul><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li></ul><p><img src="/../mysql_pic/36.png"></p><p>查询的条件为id&gt;&#x3D;19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部 分：</p><ul><li>[19]</li><li>(19,25]</li><li>(25,+∞]</li></ul><p>所以数据库数据在加锁时，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临 键锁(正无穷及之前的间隙)。</p><h4 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h4><p>插入意向锁 Insert Intention Locks，代表当前事务准备插入一行数据。使用INSERT语句会获得插入意向锁。(是指一段空间，比如(0，5])表示我要对这段空间进行插入了。</p><p><strong>插入意向锁和插入意向锁之间是兼容的，只要插入的键值不同，就不会相互阻塞</strong>(注意，键值一定不能相同，否则阻塞)</p><p><img src="/../mysql_pic/100.png"></p><p>但如果两个事务插入同一个key，那就会阻塞。</p><p><img src="/../mysql_pic/101.png"></p><p>插入意向锁可以保证两个事务插入key不同的数据的时候不冲突，提升并发性。</p><p><strong>但是间隙锁会阻塞插入意向锁</strong>！这也可以理解，因为InnoDB想在RR隔离级别就解决幻读问题。<strong>所以A事务用SELECT语句获取了一个间隙锁</strong>，自然不希望B事务在这个期间往这个间隙插入一条新的记录。(图错了，应该是for updata)</p><p><img src="/../mysql_pic/102.png"></p><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h3><p><img src="/../mysql_pic/5.png"></p><ul><li>表空间</li></ul><p>表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在 8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空 间，用于存储记录、索引等数据。</p><ul><li>段</li></ul><p>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段 （Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的 非叶子节点。段用来管理多个Extent（区）。</p><ul><li>区</li></ul><p>区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一 个区中一共有64个连续的页。</p><ul><li>页</li></ul><p>页，是InnoDB 存储引擎磁盘管理的最小单元，每次查寻是读取一个页的数据到内存中，每个页的大小默认为 16KB。为了保证页的连续性， InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p><ul><li>行</li></ul><p>行，InnoDB 存储引擎数据是按行进行存放的。</p><p>在行中，默认有两个隐藏字段： </p><p>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。 Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个 隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发 中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p><p><img src="/../mysql_pic/6.png"></p><h3 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h3><p>先看左边的内存架构</p><p><img src="/../mysql_pic/7.png"></p><p>在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。 接下来介绍一下这四个部分。</p><ul><li>Buffer pool</li></ul><p>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能 弥补这两者之间的I&#x2F;O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁 盘I&#x2F;O。</p><p>在InnoDB的缓冲池中不仅缓存了<strong>索引页</strong>和<strong>数据页</strong>，还包含了undo页、插入缓存、自适应哈希索引以及 InnoDB的锁信息等等。</p><p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增 删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频 率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p><ul><li><p>free page：空闲page，未被使用。</p></li><li><p>clean page：被使用page，数据没有被修改过。</p></li><li><p>dirty page：脏页，被使用page，数据被修改过，页中数据与磁盘的数据产生了不一致。</p></li><li><p>Change Buffer</p></li></ul><p>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML(增删改)语句时，如果这些数据Page 没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer 中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p><p><img src="/../mysql_pic/9.png"></p><p><img src="/../mysql_pic/10.png"></p><p>先来看一幅图，这个是二级索引的结构图：</p><p><img src="/../mysql_pic/8.png"></p><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新 可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了 Change Buffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p><p>写缓冲区为什么仅适用于非唯一普通索引页？</p><p>如上图所示，如果是唯一索引时，是直接去磁盘加载的数据，并不涉及到change Buffer，理由如下。</p><p>这是因为如果对索引设置唯一性，在进行修改操作时，InnoDB必须要做唯一性校验，因此必须得查询磁盘，做一次IO操作。这样就会直接将记录查询到Buffer Pool中，然后在缓冲池修改，就不会在change Buffer中操作了。</p><ul><li>Adaptive Hash Index</li></ul><p>自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持 hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在 进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需 要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。 InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度， 则建立hash索引，称之为自适应hash索引。 自适应哈希索引，无需人工干预，是系统根据情况自动完成。 参数： adaptive_hash_index</p><ul><li>Log Buffer</li></ul><p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log）， 默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事 务，增加日志缓冲区的大小可以节省磁盘 I&#x2F;O。</p><p>参数: </p><p>innodb_log_buffer_size：缓冲区大小</p><p>innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：</p><p> 1: 日志在每次事务提交时写入并刷新到磁盘，默认值。</p><p> 0: 每秒将日志写入并刷新到磁盘一次。 </p><p>  2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。</p><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><p>再看右边的磁盘结构：</p><p><img src="/../mysql_pic/11.png"></p><ul><li>System TableSpace</li></ul><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建 的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)</p><ul><li>File-Per-Table Tablespaces</li></ul><p>如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索 引 ，并存储在文件系统上的单个数据文件中(xxx.idb)。</p><p>开关参数：innodb_file_per_table ，该参数默认开启。</p><p>那也就是说，我们每创建一个表，都会产生一个表空间文件</p><ul><li>General Tablespaces(了解)</li></ul><p>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空 间。</p><ul><li>Undo Tablespaces</li></ul><p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储 undo log日志。</p><ul><li>Temporary Tablespaces</li></ul><p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p><ul><li>Doublewrite Buffer Files</li></ul><p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件 中，便于系统异常时恢复数据。</p><p><img src="/../mysql_pic/12.png"></p><ul><li>Redo Log</li></ul><p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当<strong>事务提交之后</strong>会把所 有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。 以循环方式写入Redo Log日志文件，涉及两个文件：</p><p><img src="/../mysql_pic/13.png"></p><h3 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h3><ul><li>事务</li></ul><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><ul><li>特性<ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。(不仅数据要保持一致状态，约束也要保持一致状态)</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环 境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul></li></ul><p>而对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久性，实际上是由InnoDB中的 两份日志来保证的，一份是redo log日志，一份是undo log日志。 而隔离性是通过数据库的锁， 加上MVCC来保证的。</p><p><img src="/../mysql_pic/14.png"></p><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>redo log是如何保证事务的持久性的呢？</p><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p><p>redo log 是物理日志，记录了某个数据页做了什么修改，比如<strong>对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新</strong>，每当执行一个事务就会产生这样的一条或者多条物理日志。</p><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用 于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><p>脏页：当客户端对buffer pool进行DML时，没有找到相关数据页，buffer pool从磁盘读取相关数据页到buffer pool，再对数据进行修改，此时buffer pool里的数据页和磁盘的数据不一致，这就是脏页。</p><p>如果没有redo log，可能会存在什么问题的？ 我们一起来分析一下。</p><p>我们知道，在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数 据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果 缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中 的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘 中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后 将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却 没有持久化下来，这就出现问题了，没有保证事务的持久性。</p><p><img src="/../mysql_pic/15.png"></p><p>那么，如何解决上述的问题呢？ 在InnoDB中提供了一份日志 redo log，接下来我们再来分析一 下，通过redo log如何解决这个问题。</p><p><img src="/../mysql_pic/16.png"></p><p>有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。在事务提交时，会将redolog buffer中的数据刷新到redo log磁盘文件中。 过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据 恢复，这样就保证了事务的持久性。 而<strong>如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此 时redolog就没有作用了，就可以删除了</strong>，所以存在的两个redolog文件是循环写的.</p><p>那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新 到磁盘呢 ?</p><p> 因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在 往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这 种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</p><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和 MVCC(多版本并发控制) 。</p><p>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的 update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p><p>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些 日志可能还用于MVCC。</p><p>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个undo log segment。</p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>当前读</li></ul><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加 锁。对于我们日常的操作，如：<strong>select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读</strong>。</p><p><img src="/../mysql_pic/41.png"></p><p>事务1首先查询了一次数据，事务2对表进行了一次修改，事务1再查询，但是数据还是和第一次一样，因为当前的隔离级别是默认的可重复读，第一次和第二次的结果是一样的。</p><p><img src="/../mysql_pic/42.png"></p><p>但是在查询语句后面加上lock in share mode的话就是当前读，数据是最新版本。</p><ul><li>快照读</li></ul><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据， 不加锁，是非阻塞读。</p><ul><li><ul><li>Read Committed：每次select，都生成一个快照读。</li><li>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li><li>Serializable：快照读会退化为当前读。</li></ul></li></ul><h4 id="MVCC基本概念"><a href="#MVCC基本概念" class="headerlink" title="MVCC基本概念"></a>MVCC基本概念</h4><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本， 使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需 要依赖于数据库记录中的<strong>三个隐式字段(也有可能是两个)<strong>、</strong>undo log日志</strong>、<strong>readView</strong>。</p><h5 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h5><p><img src="/../mysql_pic/43.png"></p><p>当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。 实际上除了 这三个字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：</p><p><img src="/../mysql_pic/44.png"></p><p>而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键， 如果有主键，则不会添加该隐藏字段。</p><p>进入服务器中的 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;itcast&#x2F; , 查看stu的表结构信息, 通过如下指令：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ibd2sdi</span> stu.ibd<br></code></pre></td></tr></table></figure><h5 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h5><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p><p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p><p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即 被删除。</p><h5 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h5><p>有一张原始数据为:</p><p><img src="/../mysql_pic/45.png"></p><p><code>DB_TRX_ID : 代表最近修改事务的ID，记录插入这条记录或最后一次修改该记录的事务ID，是 自增的。</code> </p><p><code>DB_ROLL_PTR ：回滚指针，由于这条数据是才插入的，没有被更新过，所以该字段值为null。</code></p><p>然后，有四个并发事务同时在访问这张表。</p><p><strong>第一步</strong></p><p><img src="/../mysql_pic/46.png"></p><p>当事务2执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/../mysql_pic/47.png"></p><p><strong>第二步</strong></p><p><img src="/../mysql_pic/48.png"></p><p>当事务3执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记 录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/../mysql_pic/49.png"></p><p><strong>第三步</strong></p><p><img src="/../mysql_pic/50.png"></p><p>当事务4执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记 录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/../mysql_pic/51.png"></p><p><code>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条 记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</code></p><h5 id="readview"><a href="#readview" class="headerlink" title="readview"></a>readview</h5><p>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务 （未提交的）id。</p><p>ReadView中包含了四个核心字段：            </p><ul><li>m_ids  : 当前活跃的事务ID集合</li><li>min_trx_id : 最小活跃事务ID</li><li>max_trx_id : 预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</li><li>creator_trx_id : ReadView创建者的事务ID</li></ul><p>而在readview中就规定了版本链数据的访问规则：</p><p><strong>trx_id 代表当前undolog版本链对应事务ID。</strong></p><p><img src="/../mysql_pic/45.png"></p><p><img src="/../mysql_pic/52.png"></p><p><img src="/../mysql_pic/53.png"></p><p>不同的隔离级别，生成ReadView的时机不同：</p><ul><li>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</li><li>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</li></ul><h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><h6 id="RC隔离级别-读已提交"><a href="#RC隔离级别-读已提交" class="headerlink" title="RC隔离级别(读已提交)"></a>RC隔离级别(读已提交)</h6><p><strong>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</strong></p><p>我们就来分析事务5中，两次快照读读取数据，是如何获取数据的?</p><p>在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读 都会生成一个ReadView，那么两次生成的ReadView如下。</p><p><img src="/../mysql_pic/54.png"></p><p>那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则， 到undolog版本链中匹配数据，最终决定此次快照读返回的数据。</p><ul><li>先来看第一次快照读具体的读取过程：</li></ul><p><img src="/../mysql_pic/55.png"></p><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><ul><li>先匹配最上面这条记录，这条记录对应的 trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ， 都不满足，则继续匹配undo log版本链的下一条。</li><li>再匹配第二条 ，这条 记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②不满足 ③不满足 ④也 不满足 ，都不满足，则继续匹配undo log版本链的下一条。</li><li>再匹配第三条 ，这条记 录对应的trx_id为2，也就是将2带入右侧的匹配规则中。①不满足 ②满足 终止匹配，此次快照 读，返回的数据就是版本链中记录的这条数据。</li></ul><p><strong>本质就是当前事务操作的最早已经提交的事务的数据。</strong></p><hr><p> 再来看第二次快照读具体的读取过程:</p><p>先不看答案，按照上面说的本质，答案应该是事务3修改后的数据。</p><p><img src="/../mysql_pic/56.png"></p><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><ul><li>先匹配最上面 这条记录，这条记录对应的 trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ， 都不满足，则继续匹配undo log版本链的下一条。</li><li>再匹配第二条 ，这条 记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②满足 。终止匹配，此次 快照读，返回的数据就是版本链中记录的这条数据。</li></ul><h6 id="RR隔离级别-可重复读"><a href="#RR隔离级别-可重复读" class="headerlink" title="RR隔离级别(可重复读)"></a>RR隔离级别(可重复读)</h6><p><strong>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可 重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</strong></p><p>那MySQL是如何做到可重复读的呢? 我们简单分析一下就知道了</p><p><img src="/../mysql_pic/57.png"></p><p>我们看到，在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该 ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返 回的结果也是一样的。</p><p>所以呢，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。 而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</p><p><img src="/../mysql_pic/58.png"></p><h2 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h2><p> 主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这 些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。</p><p>MySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状 复制。</p><p><img src="/../mysql_pic/59.png"></p><p>MySQL 复制的优点主要包含以下三个方面：</p><ul><li>主库出现问题，可以快速切换到从库提供服务。</li><li>实现读写分离，降低主库的访问压力。(主库DML,从库DQL)</li><li>可以在从库中执行备份，以避免备份期间影响主库服务。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>MySQL主从复制的核心就是 二进制日志，具体的过程如下：</p><p><img src="/../mysql_pic/60.png"></p><p>从上图来看，复制分成三步：</p><ul><li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li><li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</li><li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2023/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="键入网址到网页显示，期间发生了什么？"><a href="#键入网址到网页显示，期间发生了什么？" class="headerlink" title="键入网址到网页显示，期间发生了什么？"></a>键入网址到网页显示，期间发生了什么？</h1><h2 id="一-浏览器的第一步工作是解析URL"><a href="#一-浏览器的第一步工作是解析URL" class="headerlink" title="一.浏览器的第一步工作是解析URL"></a>一.浏览器的第一步工作是解析URL</h2><p>首先浏览器做的第一步工作就是要对URL进行解析，从而生成发送给Web服务器的请求信息。</p><p><img src="/../Intnet_pic/1.png"></p><p>所以图中的长长的 URL 实际上是请求服务器里的文件资源。</p><p><strong>要是上图中的蓝色部分 URL 元素都省略了，那应该是请求哪个文件呢？</strong></p><p>当没有路径名是，就代表访问目录下事先设置的默认文件，也就是&#x2F;index.html或者&#x2F;default.html这些文件，这样就不会发送混乱了。</p><h2 id="二-生产HTTP请求信息"><a href="#二-生产HTTP请求信息" class="headerlink" title="二.生产HTTP请求信息"></a>二.生产HTTP请求信息</h2><p>对URL进行解析之后，浏览器确定了Web服务器和文件名，接下来就是根据这些信息生成HTTP请求消息了。</p><p><img src="/../Intnet_pic/2.png"></p><p><strong>一个孤单 HTTP 数据包表示：“我这么一个小小的数据包，没亲没友，直接发到浩瀚的网络，谁会知道我呢？谁能载我一程呢？谁能保护我呢？我的目的地在哪呢？”。充满各种疑问的它，没有停滞不前，依然踏上了征途！</strong></p><h2 id="三-真实地址查询——–DNS"><a href="#三-真实地址查询——–DNS" class="headerlink" title="三.真实地址查询——–DNS"></a>三.真实地址查询——–DNS</h2><p>通过浏览器解析URL并生成HTTP消息后，需要委托操作系统将消息发送给Web服务器。</p><p>但在发送之前还有一项工作需要完成，那就是查询服务器域名对应的IP地址，因为委托操作系统发送消息时，必须提供通信对象的IP地址。</p><p>所以有一种服务器专门保存了Web服务器域名与IP的对应关系，他就是<strong>DNS服务器</strong></p><h3 id="域名的层级关系"><a href="#域名的层级关系" class="headerlink" title="域名的层级关系"></a>域名的层级关系</h3><p>DNS中的域名都是用句号来分隔的，比如<a href="http://www.server.com/">www.server.com</a> ,这里的句点代表了不同层次之间的界限。</p><p><strong>在域名中，越靠右的位置表示其层级越高</strong></p><p>实际上域名最后还有一个点，比如<a href="http://www.server.com/">www.server.com</a>.       这最后个点代表根域名</p><p>也就是，<code>.</code> 根域是在最顶层，它的下一层就是 <code>.com</code> 顶级域，再下面是 <code>server.com</code>。</p><p>所以域名的层级关系类似一个树状结构：</p><ul><li>根 DNS 服务器（.）</li><li>顶级域 DNS 服务器（.com）</li><li>权威 DNS 服务器（server.com）</li></ul><p><img src="/../Intnet_pic/3.png"></p><p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。</p><p>这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。</p><p>因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p><h3 id="域名解析的工作流程"><a href="#域名解析的工作流程" class="headerlink" title="域名解析的工作流程"></a>域名解析的工作流程</h3><ol><li>客户端首先会发出一个 DNS 请求，问 <a href="http://www.server.com/">www.server.com</a> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP&#x2F;IP 设置中填写的 DNS 服务器地址）。</li><li>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a href="http://www.server.com,则它直接返回/">www.server.com，则它直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li><li>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“<a href="http://www.server.com/">www.server.com</a> 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</li><li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？”</li><li>顶级域名服务器说：“我给你负责 <a href="http://www.server.com/">www.server.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</li><li>本地 DNS 于是转向问权威 DNS 服务器：“老三，<a href="http://www.server.com对应的IP是啥呀？”">www.server.com对应的IP是啥呀？”</a> server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li></ol><p>至此，我们完成了 DNS 的解析过程。现在总结一下，整个过程我画成了一个图。</p><p><img src="/../Intnet_pic/4.png"></p><h3 id="那是不是每次解析域名都要经过那么多的步骤呢？"><a href="#那是不是每次解析域名都要经过那么多的步骤呢？" class="headerlink" title="那是不是每次解析域名都要经过那么多的步骤呢？"></a>那是不是每次解析域名都要经过那么多的步骤呢？</h3><p>当然不是了，还有缓存这个东西的嘛。</p><p>浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。</p><h3 id="数据包表示：“DNS-老大哥厉害呀，找到了目的地了！我还是很迷茫呀，我要发出去，接下来我需要谁的帮助呢-”"><a href="#数据包表示：“DNS-老大哥厉害呀，找到了目的地了！我还是很迷茫呀，我要发出去，接下来我需要谁的帮助呢-”" class="headerlink" title="数据包表示：“DNS 老大哥厉害呀，找到了目的地了！我还是很迷茫呀，我要发出去，接下来我需要谁的帮助呢?”"></a>数据包表示：“DNS 老大哥厉害呀，找到了目的地了！我还是很迷茫呀，我要发出去，接下来我需要谁的帮助呢?”</h3><h2 id="指南好帮手——协议栈"><a href="#指南好帮手——协议栈" class="headerlink" title="指南好帮手——协议栈"></a>指南好帮手——协议栈</h2><p>通过DNS获取到IP后，就可以把HTTP请求的传输工作交给操作系统中的<strong>协议栈</strong>。</p><p>协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则，上面的部分会向下的部分委托工作，下面的部分收到委托的工作并执行。</p><p><img src="/../Intnet_pic/5.png"></p><p>应用程序(浏览器)通过调用Socket库，来委托协议栈工作。协议栈的上半部分有两块，分别是<strong>TCP</strong>和<strong>UDP</strong>协议，这两个传输协议会接受应用层的委托执行收发数据的操作。</p><p>协议栈的下面一半是用<strong>IP</strong>协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包， 而将网络包发送给对方的操作就是由IP负责的。</p><p>此外IP中还包括<strong>ICMP协议</strong>和<strong>ARP协议</strong>。</p><ul><li><strong>ICMP</strong>用于告知网络包传送过程中产生的错误以及各种控制信息。</li><li><strong>ARP</strong>用于根据IP地址查询相应的以太网MAC地址</li></ul><p>IP下面的网卡驱动程序负责控制网卡硬件，而最下面的物理硬件网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p><h3 id="数据包看了这份指南表示：“原来我需要那么多大佬的协助啊，那我先去找TCP大佬！”"><a href="#数据包看了这份指南表示：“原来我需要那么多大佬的协助啊，那我先去找TCP大佬！”" class="headerlink" title="数据包看了这份指南表示：“原来我需要那么多大佬的协助啊，那我先去找TCP大佬！”"></a>数据包看了这份指南表示：“原来我需要那么多大佬的协助啊，那我先去找TCP大佬！”</h3><h2 id="可靠传输——-TCP"><a href="#可靠传输——-TCP" class="headerlink" title="可靠传输——-TCP"></a>可靠传输——-TCP</h2><p>HTTP是基于TCP协议传输的，所以在这我们先了解TCP协议。</p><h3 id="TCP包头格式"><a href="#TCP包头格式" class="headerlink" title="TCP包头格式"></a>TCP包头格式</h3><p>先看看TCP报文头部格式</p><p><img src="/../Intnet_pic/6.png"></p><p><strong>源端口号</strong>和<strong>目的端口号</strong>是必不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</p><p>接下来的<strong>序号</strong>，这个是为了解决乱码问题。</p><p>还有应该有的是<strong>确认序列</strong>，目的是确认发送出去对方是否有收到。如果没有收到就应该重新发送，直到送到，<strong>确认序列是为了解决丢包问题</strong>。</p><p>接下来还有一些<strong>状态位(第四行蓝色部分)<strong>。例如</strong>SYN</strong>是发起一个连接，<strong>ACK</strong>是回复，<strong>RST</strong>是重新连接，<strong>FIN</strong>是结束连接等。TCP是面向连接的，因而双方要维护连接的状态，这些状态位的包的发送，会引起双方的状态变化。</p><p>还有一个重要的是<strong>窗口大小</strong>。TCP要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送太快也别发送太慢。</p><p>除了做流量控制以外，TCP还会做<strong>拥塞控制</strong>，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。</p><h3 id="TCP传输数据之前，要先三次握手建立连接"><a href="#TCP传输数据之前，要先三次握手建立连接" class="headerlink" title="TCP传输数据之前，要先三次握手建立连接"></a>TCP传输数据之前，要先三次握手建立连接</h3><p>在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为<strong>三次握手</strong>。</p><p>这个所谓的「连接」，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。</p><p><img src="/../Intnet_pic/7.png"></p><ul><li>一开始，客户端和服务端都处于<strong>closed</strong>状态。先是服务端主动监听某个端口，处于<strong>listen</strong>状态。’</li><li>然后客户端主动发起连接<strong>SYN</strong>，之后处于<strong>SYN-SENT</strong>状态。</li><li>服务端收到发起的连接，返回<strong>SYN</strong>，并且<strong>ACK</strong>客户端的<strong>SYN</strong>，之后处于<strong>SYN-REVD</strong>状态，</li><li>客户端收到服务端发送的<strong>SYN</strong>和<strong>ACK</strong>之后，发送对<strong>SYN</strong>确认的<strong>ACK</strong>，之后客户端处于<strong>ESTABLISHED</strong>状态，因为它一发一收成功了。</li><li>服务端收到自己<strong>ACK</strong>的<strong>ACK</strong>之后，处于<strong>ESTABLISHED</strong>状态，因为它也一发一收成功了。</li></ul><p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p><h3 id="如何查看TCP的连接状态？"><a href="#如何查看TCP的连接状态？" class="headerlink" title="如何查看TCP的连接状态？"></a>如何查看TCP的连接状态？</h3><p>TCP的连接状态可以在Linux通过<strong>netstat -napt</strong>命令查看</p><p><img src="/../Intnet_pic/8.png"></p><h3 id="TCP分割数据"><a href="#TCP分割数据" class="headerlink" title="TCP分割数据"></a>TCP分割数据</h3><p>如果HTTP请求消息比较长，超过了<strong>MSS</strong>的长度，这时TCP就需要把HTTP的数据拆解成一块块的数据发送，而不是一次性发送所有数据。</p><p><img src="/../Intnet_pic/9.png"></p><ul><li>MTU：一个网络包的最大长度，以太网中一般位1500字节。</li><li>MSS：除去IP和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度。</li></ul><p>数据会被以<strong>MSS</strong>的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据上加上TCP头信息，然后交给IP模块来发送数据。</p><p><img src="/../Intnet_pic/10.png"></p><h3 id="TCP报文生成"><a href="#TCP报文生成" class="headerlink" title="TCP报文生成"></a>TCP报文生成</h3><p>TCP协议里面会有两个端口，一个是浏览器监听的端口(通常是随机生成)，一个是Web服务器监听的端口(HTTP默认端口号是80，HTTPS默认端口号是443).</p><p>双方建立连接之后，TCP报文中的数据部分就是存放HTTP头部+数据，组装好TCP报文之后，就需要交给下面的网络层处理。</p><p>至此，网络包的报文如下图。</p><p><img src="/../Intnet_pic/11.png"></p><p><strong>此时，遇上了 TCP 的 数据包激动表示：“太好了，碰到了可靠传输的 TCP 传输，它给我加上 TCP 头部，我不再孤单了，安全感十足啊！有大佬可以保护我的可靠送达！但我应该往哪走呢？”</strong></p><h2 id="远程定位—-IP"><a href="#远程定位—-IP" class="headerlink" title="远程定位—-IP"></a>远程定位—-IP</h2><p>TCP模块在执行连接，收发，断开等各阶段操作时，都需要委托IP模块将数据封装成<strong>网络包</strong>发送给通信对象</p><h3 id="IP包格式"><a href="#IP包格式" class="headerlink" title="IP包格式"></a>IP包格式</h3><p><img src="/../Intnet_pic/12.png"></p><p>在IP协议里面需要有<strong>源地址IP</strong>和<strong>目的地址IP</strong>：</p><ul><li>源地址IP，即是客户端输出的IP地址；</li><li>目标地址，即通过DNS域名解析得到的Web服务器IP。</li></ul><p>因为HTTP是经过TCP传输的，所以在IP包头的协议号要填写为06（十六进制），表示为TCP协议。</p><h3 id="假设客户端有多个网卡，就会有多个IP地址，那IP头部的源地址应该选择哪个呢？"><a href="#假设客户端有多个网卡，就会有多个IP地址，那IP头部的源地址应该选择哪个呢？" class="headerlink" title="假设客户端有多个网卡，就会有多个IP地址，那IP头部的源地址应该选择哪个呢？"></a>假设客户端有多个网卡，就会有多个IP地址，那IP头部的源地址应该选择哪个呢？</h3><p>当存在多个网卡，在填写源地址IP时，就需要判断应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪一个网卡来发送包。</p><p>这个时候就需要根据<strong>路由表</strong>规则，来判断哪一个网卡作为源地址IP。</p><p>在Linux操作系统中，我们可以使用<strong>route -n</strong>查看当前系统的路由表。</p><p><img src="/../Intnet_pic/13.png"></p><p>举个例子，根据上面的路由表，我们假设 Web 服务器的目标地址是 <code>192.168.10.200</code>。</p><p><img src="/../Intnet_pic/14.png"></p><ol><li>首先先和第一条目的子网掩码（<code>Genmask</code>）进行 <strong>与运算</strong>，得到结果为 <code>192.168.10.0</code>，但是第一个条目的 <code>Destination</code> 是 <code>192.168.3.0</code>，两者不一致所以匹配失败。</li><li>再与第二条目的子网掩码进行 <strong>与运算</strong>，得到的结果为 <code>192.168.10.0</code>，与第二条目的 <code>Destination 192.168.10.0</code> 匹配成功，所以将使用 <code>eth1</code> 网卡的 IP 地址作为 IP 包头的源地址。</li></ol><p>那么假设 Web 服务器的目标地址是 <code>10.100.20.100</code>，那么依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。</p><p>第三条目比较特殊，它目标地址和子网掩码都是 <code>0.0.0.0</code>，这表示<strong>默认网关</strong>，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，<code>Gateway</code> 即是路由器的 IP 地址。</p><h3 id="IP报文生成"><a href="#IP报文生成" class="headerlink" title="IP报文生成"></a>IP报文生成</h3><p>至此，网络包的报文如下图。</p><p><img src="/../Intnet_pic/15.png"></p><p><strong>此时，加上了 IP 头部的数据包表示 ：“有 IP 大佬给我指路了，感谢 IP 层给我加上了 IP 包头，让我有了远程定位的能力！不会害怕在浩瀚的互联网迷茫了！可是目的地好远啊，我下一站应该去哪呢？”</strong></p><h3 id="两点传输——-MAC"><a href="#两点传输——-MAC" class="headerlink" title="两点传输——-MAC"></a>两点传输——-MAC</h3><p>生成了IP头部之后，接下来网络包还需要在IP头部的前面加上<strong>MAC头部</strong></p><h3 id="MAC包头信息"><a href="#MAC包头信息" class="headerlink" title="MAC包头信息"></a>MAC包头信息</h3><p>MAC头部是以太网使用的头部，它包含了接收方和发送方的MAC地址等信息。</p><p><img src="/../Intnet_pic/16.png"></p><p>在 MAC 包头里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>。</p><p>一般在 TCP&#x2F;IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p><ul><li><code>0800</code> ： IP 协议</li><li><code>0806</code> ： ARP 协议</li></ul><p>ARP：地址解析协议，即ARP（Address Resolution Protocol），是根据<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80?fromModule=lemma_inlink">IP地址</a>获取<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/2129?fromModule=lemma_inlink">物理地址</a>的一个<a href="https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE?fromModule=lemma_inlink">TCP&#x2F;IP协议</a>。</p><h3 id="MAC-发送方和接收方如何确认"><a href="#MAC-发送方和接收方如何确认" class="headerlink" title="MAC 发送方和接收方如何确认?"></a>MAC 发送方和接收方如何确认?</h3><p><strong>发送方</strong>的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。</p><p><strong>接收方</strong>的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。</p><h2 id="TCP超时重传"><a href="#TCP超时重传" class="headerlink" title="TCP超时重传"></a>TCP超时重传</h2><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230619161935569.png" alt="image-20230619161935569"></p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230619161956519.png" alt="image-20230619161956519"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2023/03/20/RabbitMQ/"/>
    <url>/2023/03/20/RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h2 id="1-1-MQ概述"><a href="#1-1-MQ概述" class="headerlink" title="1.1 MQ概述"></a>1.1 MQ概述</h2><p>MQ全称 Message Queue(消息队列)，是在消息传输的过程中保存消息的容器。多用于分布式系统之间进行通信</p><p><img src="/../mq_pic/1.png"></p><ul><li>MQ,消息队列，储存消息的中间件</li><li>分布式系统通信有两种方式：<strong>直接远程调用</strong>和<strong>借助第三方完成间接通信</strong>(MQ)</li><li>发送方称为生产者，接收方称为消费者</li></ul><p>参照：<a href="https://developer.aliyun.com/article/769883">超详细的RabbitMQ入门，看这篇就够了！-阿里云开发者社区 (aliyun.com)</a></p><h2 id="1-2-MQ的优势"><a href="#1-2-MQ的优势" class="headerlink" title="1.2 MQ的优势"></a>1.2 MQ的优势</h2><p><strong>优势：</strong></p><ul><li><strong>应用解耦</strong></li><li><strong>异步提速</strong></li><li><strong>削峰填谷</strong></li></ul><p><strong>劣势</strong>：</p><ul><li><strong>系统可用性降低</strong></li><li><strong>系统复杂性提高</strong></li><li><strong>一致性问题</strong></li></ul><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p>不使用MQ：</p><p><img src="/../mq_pic/2.png"></p><p><strong>系统的耦合性越高，容错性越低，可维护性就越低</strong></p><p>一个模块的服务失败，那么整个服务流程都将失败，容错性低。</p><p>如果还要增加X模块,Y模块的话，还需修改订单系统的代码，耦合性太高，不方便维护。</p><p>使用MQ：</p><p><img src="/../mq_pic/3.png"></p><p>订单系统发出消息给MQ，返回下单成功，那么用户体验会很好，不再管理后续服务是否成功。</p><p>如果一个服务模块失败了，那么这个模块一定时间后恢复正常会重新取得消息，完成服务，容错性提高了。</p><p>如果还要增加服务模块的话，无需修改订单系统的代码，直接增加模块获取MQ信息，可维护性提高。</p><h3 id="异步提速"><a href="#异步提速" class="headerlink" title="异步提速"></a>异步提速</h3><p>不使用MQ：</p><p><img src="/../mq_pic/4.png"></p><p>订单系统与各服务模块间的调用是同步的，总耗费时间是300+300+300+20&#x3D;920ms</p><p>用户点击完成下单按钮后，需要等待920ms才能得到下单响应，太慢，用户体验差。</p><p>使用MQ：</p><p><img src="/../mq_pic/5.png"></p><p>用户点击完成下单按钮后，只需得到25ms(20+5)就能得到下单响应。</p><p>提升用户体验和系统吞吐量(单位时间内处理请求的数目)。</p><h3 id="削谷填峰"><a href="#削谷填峰" class="headerlink" title="削谷填峰"></a>削谷填峰</h3><p>不使用rabbitmq:</p><p><img src="/../mq_pic/6.png"></p><p>无法承受那么高的访问量，宕机。</p><p>使用rabbitmq:</p><p><img src="/../mq_pic/7.png"></p><p><img src="/../mq_pic/8.png"></p><h2 id="1-4MQ的劣势"><a href="#1-4MQ的劣势" class="headerlink" title="1.4MQ的劣势"></a>1.4MQ的劣势</h2><p><img src="/../mq_pic/9.png"></p><h3 id="MQ的几个常见问题"><a href="#MQ的几个常见问题" class="headerlink" title="MQ的几个常见问题"></a>MQ的几个常见问题</h3><ul><li><p><strong>系统的可用性降低</strong></p><p>系统引入的外部依赖越多，系统稳定性越差。一旦MQ宕机，就会对业务造成影响。如何保证MQ的高可用？</p></li><li><p><strong>系统复杂度提高</strong></p><p>MQ的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过MQ进行异步调用。如何保证消息没有被重复消费？怎么处理消息丢失情况？怎么保证消息传递的顺序性？</p></li><li><p>一致性问题</p><p>A系统处理完业务，通过MQ给B，C, D三个系统发消息数据，如果B系统，C系统处理成功，D系统失败。如何保证消息数据处理的一致性？</p></li></ul><h3 id="MQ的使用场景"><a href="#MQ的使用场景" class="headerlink" title="MQ的使用场景"></a>MQ的使用场景</h3><ul><li>生产者不需要从消费者处获取反馈。引入消息队列之前的直接调用，其接口的返回值应该为空，这才让明明下层的动作还没做完，上层却当成功做完了继续往后走，即所谓异步成为了可能。</li><li>容许短暂不一致性</li><li>解耦，提速，削峰这方面的收益超过了加入MQ，管理MQ这些成本。</li></ul><h2 id="1-5-常见的MQ产品"><a href="#1-5-常见的MQ产品" class="headerlink" title="1.5 常见的MQ产品"></a>1.5 常见的MQ产品</h2><p>RabbitMQ,ActiveMQ,RocketMQ,Kafka.</p><p><img src="/../mq_pic/10.png"></p><h2 id="1-6-AMQP"><a href="#1-6-AMQP" class="headerlink" title="1.6 AMQP"></a>1.6 AMQP</h2><p>AMQP，即Advanced Message Queuing Protocol(高级消息队列协议),一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件同产品，不同的开发语言等条件的限制。类比HTTP。</p><p><img src="/../mq_pic/11.png"></p><h3 id="RabbitMQ基础架构"><a href="#RabbitMQ基础架构" class="headerlink" title="RabbitMQ基础架构"></a>RabbitMQ基础架构</h3><p><img src="/../mq_pic/12.png"></p><h3 id="RabbitMQ的核心概念"><a href="#RabbitMQ的核心概念" class="headerlink" title="RabbitMQ的核心概念"></a>RabbitMQ的核心概念</h3><p><strong>Connection（连接）、Channel（信道）、Exchange（交换机）、Queue（队列）、Virtual host（虚拟主机）</strong></p><p>其中，中间的Broker表示RabbitMQ服务，每个Broker里面至少有一个Virtual host虚拟主机，每个虚拟主机中有自己的Exchange交换机、Queue队列以及Exchange交换机与Queue队列之间的绑定关系Binding。producer（生产者）和consumer（消费者）通过与Broker建立Connection来保持连接，然后在Connection的基础上建立若干Channel信道，用来发送与接收消息。</p><p><strong>Connection（连接）</strong><br>每个producer（生产者）或者consumer（消费者）要通过RabbitMQ发送与消费消息，首先就要与RabbitMQ建立连接，这个连接就是Connection。Connection是一个TCP长连接。</p><p><strong>Channel（信道）</strong><br>Channel是在Connection的基础上建立的虚拟连接，RabbitMQ中大部分的操作都是使用Channel完成的，比如：声明Queue、声明Exchange、发布消息、消费消息等。</p><p>看到此处，你是否有这样一个疑问：既然已经有了Connection，我们完全可以使用Connection完成Channel的工作，为什么还要引入Channel这样一个虚拟连接的概念呢？因为现在的程序都是支持多线程的，如果没有Channel，那么每个线程在访问RabbitMQ时都要建立一个Connection这样的TCP连接，对于操作系统来说，建立和销毁TCP连接是非常大的开销，在系统访问流量高峰时，会严重影响系统性能。</p><p>Channel就是为了解决这种问题，通常情况下，每个线程创建单独的Channel进行通讯，每个Channel都有自己的channel id帮助Broker和客户端识别Channel，所以Channel之间是完全隔离的。</p><p>Connection与Channel之间的关系可以比作光纤电缆，如果把Connection比作一条光纤电缆，那么Channel就相当于是电缆中的一束光纤。</p><p><strong>Virtual host（虚拟主机）</strong></p><p>Virtual host是一个虚拟主机的概念，一个Broker中可以有多个Virtual host，每个Virtual host都有一套自己的Exchange和Queue，同一个Virtual host中的Exchange和Queue不能重名，不同的Virtual host中的Exchange和Queue名字可以一样。这样，不同的用户在访问同一个RabbitMQ Broker时，可以创建自己单独的Virtual host，然后在自己的Virtual host中创建Exchange和Queue，很好地做到了不同用户之间相互隔离的效果。</p><p><strong>Queue（队列）</strong><br>Queue是一个用来存放消息的队列，生产者发送的消息会被放到Queue中，消费者消费消息时也是从Queue中取走消息。</p><p><strong>Exchange（交换机）</strong><br>Exchange是一个比较重要的概念，它是消息到达RabbitMQ的第一站，主要负责根据不同的分发规则将消息分发到不同的Queue，供订阅了相关Queue的消费者消费到指定的消息。那Exchange有哪些分发消息的规则呢？这就要说到Exchange的5种类型了：简单模式，work queues, publish&#x2F;Subscribe发布与订阅模式， Routing路由模式， Topics主题模式 ，RPC远程调用模式(不太算)</p><p><strong>Binding</strong>(绑定)</p><p>exchange和queue之间的虚拟连接，binging中可以包含routing key。Binding信息被保存到exchange中的查询表中，用于message的分发依据。</p><p><strong>Broker</strong></p><p>接收和分发消息的应用，RabbitMQ Server就是Message Broker</p><h2 id="1-7-JMS"><a href="#1-7-JMS" class="headerlink" title="1.7 JMS"></a>1.7 JMS</h2><ul><li>JMS即Java消息服务(JavaMessage Service)应用程序接口，是一个Java平台中关于面向中间件的API。</li><li>JMS是Java EE规范中的一种，类比JDBC。</li><li>很多消息中间件都实现了JMS规范，例如ActiveMQ。RabbitMQ官方没有提供JMS的实现包，但是开源社区有。</li></ul><h2 id="1-8-在linux上安装下载RabbitMQ"><a href="#1-8-在linux上安装下载RabbitMQ" class="headerlink" title="1.8 在linux上安装下载RabbitMQ"></a>1.8 在linux上安装下载RabbitMQ</h2><p>我们在Centos7虚拟机中使用Docker来安装。</p><p>在线拉取镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull rabbitmq:<span class="hljs-number">3</span>-management<br></code></pre></td></tr></table></figure><p>执行下面的命令来运行MQ容器：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">docker run <span class="hljs-string">\</span><br> -e RABBITMQ_DEFAULT_USER=pjf <span class="hljs-string">\</span><br> -e RABBITMQ_DEFAULT_PASS=<span class="hljs-number">123456</span> <span class="hljs-string">\</span><br> --name mq <span class="hljs-string">\</span><br> --hostname mq1 <span class="hljs-string">\</span><br> -p <span class="hljs-number">15672</span>:<span class="hljs-number">15672</span> <span class="hljs-string">\</span><br> -p <span class="hljs-number">5672</span>:<span class="hljs-number">5672</span> <span class="hljs-string">\</span><br> -d <span class="hljs-string">\</span><br> rabbitmq:<span class="hljs-number">3</span>-management<br></code></pre></td></tr></table></figure><h2 id="1-9-RabbitMQ工作模式"><a href="#1-9-RabbitMQ工作模式" class="headerlink" title="1.9 RabbitMQ工作模式"></a>1.9 RabbitMQ工作模式</h2><h3 id="基本消息队列（BasicQueue）"><a href="#基本消息队列（BasicQueue）" class="headerlink" title="基本消息队列（BasicQueue）"></a>基本消息队列（BasicQueue）</h3><p><img src="/../mq_pic/13.png"></p><ul><li>P：生产者,也就是发送消息的程序</li><li>C：消费者，消息的接收者，会一直等待消息的到来</li><li>queue:消息队列，图中红色的部分，类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中获取消息</li></ul><h3 id="工作消息队列（WorkQueue）"><a href="#工作消息队列（WorkQueue）" class="headerlink" title="工作消息队列（WorkQueue）"></a>工作消息队列（WorkQueue）</h3><p><img src="/../mq_pic/14.png"></p><p>两个或者多个消费者是竞争关系，只有一个可以得到消息</p><p>应用场景:对于任务过重或者任务较多的情况使用工作队列可以提高任务处理的速度</p><p>通过在yml中设置prefetch来控制消费者预取的消息数量（先把消息拿过来，不一定马上处理）</p><h3 id="发布订阅（Publish-Subscribe）"><a href="#发布订阅（Publish-Subscribe）" class="headerlink" title="发布订阅（Publish Subscribe）"></a>发布订阅（Publish Subscribe）</h3><p>发布订阅模式与之前案例的区别就是允许将同一消息发给多个消费者。实现方式是加入了交换机Exchange。</p><p>交换机负责消息路由，而不是存储，路由失败则消息丢失。</p><p><strong>SpringAMQP提供了声明交换机，队列，绑定关系的API</strong></p><p><img src="/../mq_pic/22.png"></p><p>根据交换机类型不同分为三种</p><ul><li>Fanout Exchange:广播</li><li>Direct Exchange:路由</li><li>Topic Exchange:主题</li></ul><p><img src="/../mq_pic/15.png"></p><p>实现思路：</p><p>1.在consumer服务中，利用代码声明队列，交换机，并将两者绑定</p><p>2.在consumer服务中，编写两个消费者方法，分别监听fanout.queue1和fanout.queue2</p><p>3.在publisher中编写测试方法，向it.fanout(交换机)中发送消息</p><p>编写一个配置类，把交换机，队列，绑定关系声明为Bean</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAMQPconfig</span> &#123;<br>    <span class="hljs-comment">//声明交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">FanoutExchange</span> <span class="hljs-title function_">fanoutExchange</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FanoutExchange</span>(<span class="hljs-string">&quot;fanout.exchange&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Queue</span> <span class="hljs-title function_">fanoutQueue1</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;fanout.queue1&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Binding</span> <span class="hljs-title function_">binding1</span>(<span class="hljs-params">FanoutExchange fanoutExchange,Queue fanoutQueue1</span>)&#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-title class_">BindingBuilder</span>.<span class="hljs-title function_">bind</span>(fanoutQueue1).<span class="hljs-title function_">to</span>(fanoutExchange);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Queue</span> <span class="hljs-title function_">fanoutQueue2</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;fanout.queue2&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Binding</span> <span class="hljs-title function_">binding2</span>(<span class="hljs-params">FanoutExchange fanoutExchange,Queue fanoutQueue2</span>)&#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-title class_">BindingBuilder</span>.<span class="hljs-title function_">bind</span>(fanoutQueue2).<span class="hljs-title function_">to</span>(fanoutExchange);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript">监听<br><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">&quot;fanout.queue1&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">fanoutlistener1</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> msg</span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;fanout.queue1收到消息队列得消息:&quot;</span>+msg);<br>    &#125;<br>    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">&quot;fanout.queue2&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">fanoutlistener2</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> msg</span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;fanout.queue2收到消息队列得消息:&quot;</span>+msg);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript">发送消息<br><span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">fanoutsend</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-title class_">String</span> fanoutName =<span class="hljs-string">&quot;fanout.exchange&quot;</span>;<br>       <span class="hljs-title class_">String</span> msg =<span class="hljs-string">&quot;hello,fanout!!&quot;</span>;<br>       rabbitTemplate.<span class="hljs-title function_">convertAndSend</span>(fanoutName,<span class="hljs-string">&quot;&quot;</span>,msg);<br>   &#125;<br></code></pre></td></tr></table></figure><p><img src="/../mq_pic/16.png"></p><p><img src="/../mq_pic/17.png"></p><p>发现用Bean声明队列，交换机和绑定太麻烦</p><p>可以使用@RabbitListener注解声明队列，交换机和绑定</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RabbitListener</span>(bindings = <span class="hljs-variable">@QueueBinding</span>(<br>            value = <span class="hljs-variable">@Queue</span>(name = <span class="hljs-string">&quot;direct.queue1&quot;</span>),<br>            exchange = <span class="hljs-variable">@Exchange</span>(name = <span class="hljs-string">&quot;it.direct&quot;</span>,type = ExchangeTypes.DIRECT),<br>            key = &#123;<span class="hljs-string">&quot;red&quot;</span>,<span class="hljs-string">&quot;blue&quot;</span>&#125;<br>    ))<br>public void <span class="hljs-built_in">directlistener1</span>(String msg)&#123;<br>       <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;direct.queue1收到消息队列得消息:&quot;</span>+msg);<br>    &#125;<br><br>@<span class="hljs-selector-tag">RabbitListener</span>(bindings = <span class="hljs-variable">@QueueBinding</span>(<br>            value = <span class="hljs-variable">@Queue</span>(name = <span class="hljs-string">&quot;direct.queue2&quot;</span>),<br>            exchange = <span class="hljs-variable">@Exchange</span>(name = <span class="hljs-string">&quot;it.direct&quot;</span>,type = ExchangeTypes.DIRECT),<br>            key = &#123;<span class="hljs-string">&quot;red&quot;</span>,<span class="hljs-string">&quot;yellow&quot;</span>&#125;<br>    ))<br><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">directlistener2</span>(String msg)&#123;<br>        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;direct.queue2收到消息队列得消息:&quot;</span>+msg);<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到it.direct已经被创建，并且绑定了2个队列，各有2个Routinkey</p><p><img src="/../mq_pic/23.png"></p><p><img src="/../mq_pic/24.png"></p><p><img src="/../mq_pic/18.png"></p><p><img src="/../mq_pic/19.png"></p><p>TopicExchange与DirectExchange类似，区别在于routingkey必须是多个单词的列表，并且以 “.”分割、eg:china.news     china.weather</p><p><strong>TopicExchange指定BingdingKey时可以指定通配符</strong></p><ul><li>‘**’符号：有且只匹配一个词。比如 a.*可以匹配到”a.b”、”a.c”，但是匹配不了”a.b.c”。</li><li>#符号：匹配一个或多个词。比如”rabbit.#”既可以匹配到”rabbit.a.b”、”rabbit.a”，也可以匹配到”rabbit.a.b.c”。</li></ul><p>TopicExchange与DirectExchange代码几乎一样，只有routingkey是包含通配符的，交换机类型是Topic的。</p><h2 id="生产者与消费者流程"><a href="#生产者与消费者流程" class="headerlink" title="生产者与消费者流程"></a>生产者与消费者流程</h2><p><strong>生产者：</strong></p><p>1.建立Connection</p><p>2.创建channel</p><p>3.利用channel声明队列</p><p>4.利用channel向队列发送消息</p><p><strong>消费者：</strong></p><p>1.建立Connection</p><p>2.创建channel</p><p>3.利用channel声明队列</p><p>4.定义consumer的消费行为handleDelivery()</p><p>5.利用channel将消费者与队列绑定</p><h2 id="2-0-SpringAMQP"><a href="#2-0-SpringAMQP" class="headerlink" title="2.0 SpringAMQP"></a>2.0 SpringAMQP</h2><p><img src="/../mq_pic/20.png"></p><p><img src="/../mq_pic/21.png"></p><p>传统的利用AMQP代码复杂，所以用SpringAMQP简化开发</p><h2 id="利用SpringAMQP完成简单通信"><a href="#利用SpringAMQP完成简单通信" class="headerlink" title="利用SpringAMQP完成简单通信"></a>利用SpringAMQP完成简单通信</h2><h3 id="1-引入AMQP依赖"><a href="#1-引入AMQP依赖" class="headerlink" title="1.引入AMQP依赖"></a>1.引入AMQP依赖</h3><p>因为publisher和consumer服务都需要amqp依赖，因此这里把依赖直接放到父工程中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-在publisher中编写测试方法，向消息队列中发送信息"><a href="#2-在publisher中编写测试方法，向消息队列中发送信息" class="headerlink" title="2.在publisher中编写测试方法，向消息队列中发送信息"></a>2.在publisher中编写测试方法，向消息队列中发送信息</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.234</span><span class="hljs-number">.132</span> <span class="hljs-comment"># rabbitMQ的ip地址</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">pjf</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br></code></pre></td></tr></table></figure><h3 id="3-编写生产者测试代码"><a href="#3-编写生产者测试代码" class="headerlink" title="3.编写生产者测试代码"></a>3.编写生产者测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAMQPTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">springamqpsend</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queuename</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;hello amqp&quot;</span>;<br>        rabbitTemplate.convertAndSend(queuename,msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><p>要先有这个队列才行，没有这个队列的记得创建队列哦</p><p>空队列没有消息的，记得自己创建队列，因为这个不会主动创建队列</p><p><strong>所以得自己去管理界面先创建simple.queue</strong></p><h3 id="4-编写消费者测试代码"><a href="#4-编写消费者测试代码" class="headerlink" title="4. 编写消费者测试代码"></a>4. 编写消费者测试代码</h3><p>同样需要引入依赖，编写配置信息</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAMQPListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">&quot;simple.queue&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">listener</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> msg</span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;收到消息队列得消息&quot;</span>+msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动启动文件后收到消息</p><p>实在太优雅了！！！</p><h2 id="2-1消息转换器"><a href="#2-1消息转换器" class="headerlink" title="2.1消息转换器"></a>2.1消息转换器</h2><p>AMQP原生API发送消息是字节形式，但是SpringAMQP的rabbitTemplate.convertAndSend中的参数是Object类型，</p><p>Spring的对消息对象的处理是由org.springframework.amqp.support.converter.MessageConveter来处理的，默认实现是SimpleMessageConverter,基于JDK的ObjectOutPutStream完成序列化，效率和安全性低。</p><p>解决方法：</p><p>我们在publisher服务中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在生产者服务声明MessageConverter:覆盖原有转换器</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Bean</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title class_">MessageConverter</span> <span class="hljs-title function_">messageConversionException</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>   &#125;<br></code></pre></td></tr></table></figure><p>注意，在生产者和消费者都需要做以上步骤，引依赖和写转换器。</p><h2 id="3-0-消息的可靠性投递"><a href="#3-0-消息的可靠性投递" class="headerlink" title="3.0 消息的可靠性投递"></a>3.0 消息的可靠性投递</h2><p>在使用 RabbitMQ 的时候，作为消息发送方希望杜绝任何消息丢失或者投递失败场景。RabbitMQ 为我们提 供了两种方式用来控制消息的投递可靠性模式。</p><ul><li><p>confirm 确认模式 </p></li><li><p>return 退回模式</p></li></ul><p><img src="/../mq_pic/25.png"></p><p>大致的流程就是这样，所以要确保消息发送的可靠性，主要从两方面去确认：</p><ul><li><p>消息成功到达 Exchange (依靠confirm 确认模式)</p></li><li><p>消息成功到达 Queue (依靠return 退回模式)</p></li></ul><p>如果能确认这两步，那么我们就可以认为消息发送成功了。</p><ol><li>确认消息到达 Exchange。</li><li>确认消息到达 Queue。</li></ol><p><strong>如何打开confirm 确认模式和return 退回模式呢？</strong></p><p>在 application.properties 中配置开启消息发送方确认机制，如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">spring.rabbitmq.publisher-confirm-type</span>=correlated<br><span class="hljs-attr">spring.rabbitmq.publisher-returns</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="Confirm确认模式"><a href="#Confirm确认模式" class="headerlink" title="Confirm确认模式"></a>Confirm确认模式</h3><p><strong>Confirm确认模式：不管publisher发给exchange是否成功都会调用回调函数confirm</strong></p><p>publisher-confirm-type有三个属性：</p><ol><li>none：表示禁用发布确认模式，默认即此。</li><li>correlated：表示成功发布消息到交换器后会触发的回调方法。</li><li>simple：类似 correlated，并且支持 <code>waitForConfirms()</code> 和 <code>waitForConfirmsOrDie()</code> 方法的调用。</li></ol><p>开启后，我们需要自定义<strong>confirm 确认模式</strong>的回调方法 <strong>confirm</strong>,不管是否成功都会调用</p><p>消费者：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RabbitListener</span>(bindings = <span class="hljs-variable">@QueueBinding</span>(<br>            value = <span class="hljs-variable">@Queue</span>(name = <span class="hljs-string">&quot;simple.queue&quot;</span>),<br>            exchange = <span class="hljs-variable">@Exchange</span>(name = <span class="hljs-string">&quot;comfirm.exchange&quot;</span>,type = ExchangeTypes.DIRECT),<br>            key = &#123;<span class="hljs-string">&quot;confirm&quot;</span>&#125;<br>    ))<br>    public void <span class="hljs-built_in">confirm</span>(String msg)&#123;<br>        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;comfirm.exchange收到消息队列得消息:&quot;</span>+msg);<br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simple</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        rabbitTemplate.setConfirmCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RabbitTemplate</span>.ConfirmCallback() &#123;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 确认</span><br><span class="hljs-comment">             *</span><br><span class="hljs-comment">             * <span class="hljs-doctag">@param</span> correlationData 相关配置数据</span><br><span class="hljs-comment">             * <span class="hljs-doctag">@param</span> b               ack，是否成功</span><br><span class="hljs-comment">             * <span class="hljs-doctag">@param</span> s               失败原因</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-type">boolean</span> b, String s)</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;回调方法confirm被执行了&quot;</span>);<br>                <span class="hljs-keyword">if</span>(b)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;交换机接受消息成功&quot;</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;交换机接受消息失败:&quot;</span>+s);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你好confirm&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">exchange</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;comfirm.exchange&quot;</span>;<br>        rabbitTemplate.convertAndSend(exchange,<span class="hljs-string">&quot;confirm&quot;</span>,msg);<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">回调方法<span class="hljs-keyword">confirm</span>被执行了<br>交换机接受消息成功<br></code></pre></td></tr></table></figure><p>故意改错交换机名字</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">回调方法confirm被执行了<br>交换机接受消息失败:channel error<span class="hljs-punctuation">;</span> protocol <span class="hljs-keyword">method</span>: #<span class="hljs-keyword">method</span>&lt;<span class="hljs-title function_">channel</span>.<span class="hljs-title function_">close</span>&gt;<span class="hljs-params">(reply-code=404, reply-text=NOT_FOUND - no exchange <span class="hljs-string">&#x27;comfirm.exchange1&#x27;</span> <span class="hljs-keyword">in</span> vhost <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">class</span>-id=60, <span class="hljs-keyword">method</span>-id=40)</span><br></code></pre></td></tr></table></figure><p>这里我们发现最后加一个Thread.sleep(100)才会显示调用信息？</p><p>原因分析：<br>个人猜测：回调函数虽然被调用了但是，主线程已经结束，来不及输出日志？</p><p>这里我们在主程序和回调函数里分别加一段代码获取当前线程id</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Id()</span>);<br></code></pre></td></tr></table></figure><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">1<br>20<br>回调方法<span class="hljs-keyword">confirm</span>被执行了<br>交换机接受消息成功<br></code></pre></td></tr></table></figure><p>发现回调函数会另外开启一个线程.所以以上猜测应该是正确的。</p><h3 id="Return-回退模式"><a href="#Return-回退模式" class="headerlink" title="Return 回退模式"></a>Return 回退模式</h3><p>return 退回模式：消息发给Exchange后，Exchange路由到Queue失败时才会触发ReturnCallBack</p><p>步骤：</p><p>1.开启回退模式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">publisher<span class="hljs-operator">-</span><span class="hljs-keyword">returns</span>: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>2.设置ReturnCallBack</p><p>3.设置Exchange处理消息的模式</p><p>​      3.1 如果消息没有路由到Queue，则丢弃消息(默认)(默认丢弃也不会触发回调函数)</p><p>​  3.2 如果消息没有路由到Queue,则返回给消息发送方ReturnCallBack</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//设置消息处理失败消息的模式</span><br>        rabbitTemplate.set<span class="hljs-constructor">Mandatory(<span class="hljs-params">true</span>)</span>;<br>        rabbitTemplate.set<span class="hljs-constructor">ReturnCallback(<span class="hljs-params">new</span> RabbitTemplate.ReturnCallback()</span> &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 返回消息</span><br><span class="hljs-comment">             *</span><br><span class="hljs-comment">             * @param message 消息</span><br><span class="hljs-comment">             * @param i       错误码</span><br><span class="hljs-comment">             * @param s       错误信息</span><br><span class="hljs-comment">             * @param s1      交换机</span><br><span class="hljs-comment">             * @param s2      路由键</span><br><span class="hljs-comment">             */</span><br>            @Override<br>            public void returned<span class="hljs-constructor">Message(Message <span class="hljs-params">message</span>, <span class="hljs-params">int</span> <span class="hljs-params">i</span>, String <span class="hljs-params">s</span>, String <span class="hljs-params">s1</span>, String <span class="hljs-params">s2</span>)</span> &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;return回调方法执行了&quot;</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(message);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(i);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(s);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(s1);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(s2);<br>            &#125;<br>        &#125;);<br>        String msg = <span class="hljs-string">&quot;你好return&quot;</span>;<br>        String exchange =<span class="hljs-string">&quot;comfirm.exchange&quot;</span>;<br>        rabbitTemplate.convert<span class="hljs-constructor">AndSend(<span class="hljs-params">exchange</span>,<span class="hljs-string">&quot;confirm&quot;</span>,<span class="hljs-params">msg</span>)</span>;<br>    &#125;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>默认方法是丢弃发送失败的消息，不会触发Return模式，我们需要</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">rabbitTemplate.set<span class="hljs-constructor">Mandatory(<span class="hljs-params">true</span>)</span>;<br></code></pre></td></tr></table></figure><p>将模式设置为返回给发送方，这样才会调用ReturnCallBack</p><p>我们故意将路由键改成错误的，输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">return回调方法执行了<br>(Body:<span class="hljs-string">&#x27;&quot;你好return&quot;&#x27;</span> MessageProperties [headers=&#123;<span class="hljs-attribute">__TypeId__</span>=java.lang.String&#125;, <span class="hljs-attribute">contentType</span>=application/json, <span class="hljs-attribute">contentEncoding</span>=UTF-8, <span class="hljs-attribute">contentLength</span>=0, <span class="hljs-attribute">receivedDeliveryMode</span>=PERSISTENT, <span class="hljs-attribute">priority</span>=0, <span class="hljs-attribute">deliveryTag</span>=0])<br>312<br>NO_ROUTE<br>comfirm.exchange<br>confirm1<br></code></pre></td></tr></table></figure><h3 id="Consumer-ACK"><a href="#Consumer-ACK" class="headerlink" title="Consumer ACK"></a>Consumer ACK</h3><p>ack指Acknowledge,确认。表示消费端收到消息后的确认方式。</p><p>有三种确认方式：</p><ul><li><p>自动确认：acknowledge &#x3D; “none”</p></li><li><p>手动确认：acknowledge &#x3D; “manual”</p></li><li><p>根据异常情况确认：acknowledge &#x3D;“auto” (这种方式使用麻烦，不做讲解)</p></li></ul><p>其中自动确认是指，当消息一旦被Consumer接收到，则自动确认收到，并将相应 message 从 RabbitMQ 的 消息缓存中移除。但是在实际业务处理中，很可能消息接收到，业务处理出现异常，那么该消息就会丢失。如 果设置了手动确认方式，则需要在业务处理成功后，调用channel.basicAck()，手动签收，如果出现异常，则 调用channel.basicNack()方法，让MQ自动重新发送消息。</p><p>basicAck()的参数：deliveryTag：该消息的index；multiple：是否批量处理.true:将一次性ack所有小于deliveryTag的消息</p><p>开启手动签收模式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">xxxxxxxx</span> <span class="hljs-comment"># rabbitMQ的ip地址</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">direct:</span><br>        <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">manual</span><br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RabbitListener</span>(bindings = <span class="hljs-meta">@QueueBinding</span>(<br>            value = <span class="hljs-meta">@Queue</span>(name = <span class="hljs-string">&quot;simple.queue&quot;</span>),<br>            exchange = <span class="hljs-meta">@Exchange</span>(name = <span class="hljs-string">&quot;comfirm.exchange&quot;</span>,type = ExchangeTypes.DIRECT),<br>            key = &#123;<span class="hljs-string">&quot;confirm&quot;</span>&#125;<br><br>    ))<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">confirm</span><span class="hljs-params">( Channel channel, Message message)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//获取收获标签</span><br>        <span class="hljs-keyword">long</span> deliveryTag = message.getMessageProperties().getDeliveryTag();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//模拟处理业务逻辑</span><br>            System.out.println(<span class="hljs-string">&quot;处理业务&quot;</span>);<br>            <span class="hljs-comment">//接收转换消息</span><br>            System.out.println(<span class="hljs-string">&quot;comfirm.exchange收到消息队列得消息:&quot;</span>+<span class="hljs-keyword">new</span> String(message.getBody()));<br>            <span class="hljs-comment">//伪造一个错误</span><br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span> / <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//手动签收</span><br>            channel.basicAck(deliveryTag,<span class="hljs-keyword">true</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">//如果出现异常，可以拒接签收，让消息重回队列</span><br>            channel.basicNack(deliveryTag,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到不断重试</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">处理业务<br>处理业务<br>处理业务<br>处理业务<br></code></pre></td></tr></table></figure><h2 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h2><h3 id="MQ有一个非常重要的作用：削峰添谷"><a href="#MQ有一个非常重要的作用：削峰添谷" class="headerlink" title="MQ有一个非常重要的作用：削峰添谷"></a>MQ有一个非常重要的作用：削峰添谷</h3><p><img src="/../mq_pic/6.png"></p><p>如果请求并发量特别大会让系统宕机,这时我们把并发量全部存到MQ中,然后再每秒从MQ中拉取一些请求进行处理,保证了系统的安全性,从MQ中拉的请求数就是所谓的限流处理,在消费消息的时候做了限流操作</p><p>还有一种业务场景,如果系统有一天要维护,由于生产者一直在发消息,但是系统在维护,那么等系统维护好了之后,所有生产者生产的消息会一直堆积在MQ中,那么等系统维护好了之后,之前生产的消息一次性打到系统,系统也会宕机,所以为了保证系统稳定性,做限流是非常有必要性的！</p><p>在SpringBoot整合RabbitMQ后，限流的关键代码为(但是这个方法貌似不起作用)，所以目前只在yml文件中配置</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">channel.<span class="hljs-keyword">basic</span>Q<span class="hljs-keyword">os</span>();<br></code></pre></td></tr></table></figure><p>该方法的作用是：进行消费端的限流</p><p>param1：prefetchSize，消息本身的大小 如果设置为0 那么表示对消息本身的大小不限制<br>param2：prefetchCount，告诉rabbitmq不要一次性给消费者推送大于N个消息<br>param3：global，是否将上面的设置应用于整个通道<br>false：表示只应用于当前消费者<br>true：表示当前通道的所有消费者都应用这个限流策略<br><strong>注意</strong>：<strong>限流情况 ack 不能设置自动签收，一定要手动签收</strong></p><p>1.在yml文件中设置</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol">  rabbitmq:</span><br><span class="hljs-symbol">     listener:</span><br><span class="hljs-symbol">      simple:</span><br><span class="hljs-symbol">        prefetch:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>2.在监听器中设置手动签收</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">channel.basic<span class="hljs-constructor">Ack(<span class="hljs-params">deliveryTag</span>,<span class="hljs-params">true</span>)</span>;<br></code></pre></td></tr></table></figure><p>只有手动签收了才会消费所有的消息，如果没有手动签收会认为还没有消费完，不会继续消费了，因此只消费了一条消息。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2023/03/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/03/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h2><p><img src="/../os_pic/1.png"></p><p><strong>操作系统(OS)</strong> 是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件</p><p><img src="/../os_pic/2.png"></p><p>补充：进程是一个程序的执行过程。执行前需要将该程序放到内存中，才能被CPU处理。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="/../os_pic/4.png"></p><h2 id="系统资源管理"><a href="#系统资源管理" class="headerlink" title="系统资源管理"></a>系统资源管理</h2><p><img src="/../os_pic/3.png"></p><ul><li><p>Step1—&gt;文件管理</p></li><li><p>Step2—&gt;存储器管理(内存管理)</p></li><li><p>Step3—&gt;处理机管理</p></li><li><p>Step4—&gt;设备管理</p></li></ul><h2 id="作为用户和计算机硬件之间的接口"><a href="#作为用户和计算机硬件之间的接口" class="headerlink" title="作为用户和计算机硬件之间的接口"></a>作为用户和计算机硬件之间的接口</h2><p><img src="/../os_pic/5.png"></p><p><img src="/../os_pic/6.png"></p><h3 id="联机命令接口"><a href="#联机命令接口" class="headerlink" title="联机命令接口"></a>联机命令接口</h3><p><img src="/../os_pic/7.png"></p><p>联机命令接口&#x3D;交互式命令接口</p><h3 id="脱机命令接口"><a href="#脱机命令接口" class="headerlink" title="脱机命令接口"></a>脱机命令接口</h3><p><img src="/../os_pic/8.png"></p><h3 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h3><p>程序接口(允许用户通过程序<strong>间接</strong>使用)：由一组<strong>系统调用组成</strong>(程序接口&#x3D;系统调用)</p><h2 id="接口总结"><a href="#接口总结" class="headerlink" title="接口总结"></a>接口总结</h2><p><img src="/../os_pic/9.png"></p><p><img src="/../os_pic/10.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/../os_pic/11.png"></p><h2 id="操作系统的四大特征"><a href="#操作系统的四大特征" class="headerlink" title="操作系统的四大特征"></a>操作系统的四大特征</h2><p><img src="/../os_pic/12.png"></p><p>四大特征：并发,共享，虚拟，异步</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="并发的概念及与并行的区别"><a href="#并发的概念及与并行的区别" class="headerlink" title="并发的概念及与并行的区别"></a>并发的概念及与并行的区别</h3><p><img src="/../os_pic/13.png"></p><p><img src="/../os_pic/14.png"></p><h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p><img src="/../os_pic/15.png"></p><p>但是同时共享访问也有“同时”访问的，不是微观上的交替，比如扬声器一边播放游戏声音一边播放音乐声音</p><h2 id="并发与共享的关系"><a href="#并发与共享的关系" class="headerlink" title="并发与共享的关系"></a>并发与共享的关系</h2><p><img src="/../os_pic/16.png"></p><h2 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h2><h3 id="虚拟-空分复用技术"><a href="#虚拟-空分复用技术" class="headerlink" title="虚拟-空分复用技术"></a>虚拟-空分复用技术</h3><p><img src="/../os_pic/17.png"></p><h3 id="虚拟-时分复用"><a href="#虚拟-时分复用" class="headerlink" title="虚拟-时分复用"></a>虚拟-时分复用</h3><p><img src="/../os_pic/18.png"></p><p>显然，如果失去了并发性，则一个时间段内系统中只需要运行一道程序，那么就失去了实习虚拟性的意义了。因此，没有并发性，就谈不上虚拟性。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p><img src="/../os_pic/19.png"></p><p>这点在Java高并发中体现明显，需要用到锁🔒解决</p><h2 id="操作系统四大特征总结"><a href="#操作系统四大特征总结" class="headerlink" title="操作系统四大特征总结"></a>操作系统四大特征总结</h2><p><img src="/../os_pic/20.png"></p><h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h2><p><img src="/../os_pic/21.png"></p><h3 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h3><p><img src="/../os_pic/22.png"></p><p>CPU计算快，但纸带输入太慢，造成CPU浪费</p><h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h3><p><img src="/../os_pic/23.png"></p><p>提前把程序输入到磁带中，提高输入输出速度</p><h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><p><img src="/../os_pic/24.png"></p><h3 id="单道批处理与多道批处理对比"><a href="#单道批处理与多道批处理对比" class="headerlink" title="单道批处理与多道批处理对比"></a>单道批处理与多道批处理对比</h3><p><img src="/../os_pic/25.png"></p><p><img src="/../os_pic/26.png"></p><h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3><p><img src="/../os_pic/27.png"></p><h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><p><img src="/../os_pic/28.png"></p><h3 id="其他几种操作系统-了解即可"><a href="#其他几种操作系统-了解即可" class="headerlink" title="其他几种操作系统(了解即可)"></a>其他几种操作系统(了解即可)</h3><p><img src="/../os_pic/29.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C/C++的五个区</title>
    <link href="/2023/02/28/CC++%E7%9A%84%E4%BA%94%E4%B8%AA%E5%8C%BA/"/>
    <url>/2023/02/28/CC++%E7%9A%84%E4%BA%94%E4%B8%AA%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="c语言中的5大内存分区"><a href="#c语言中的5大内存分区" class="headerlink" title="c语言中的5大内存分区"></a><a href="https://www.cnblogs.com/souhaite/p/10941824.html">c语言中的5大内存分区</a></h1><p>在C&#x2F;C++中，内存分成5个区，他们分别是<strong>堆、栈、自由存储区、全局&#x2F;静态存储区和常量存储区</strong>。</p><p>1.<strong>栈</strong>，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量存储区。里面的变量通常是局部变量、函数参数等。</p><p>2.<strong>堆</strong>，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p><p>3.<strong>自由存储区</strong>，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。</p><p>4.<strong>全局&#x2F;静态存储区</strong>，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。</p><p>5.<strong>常量存储区</strong>，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多）</p><p>明确区分堆与栈<br>在bbs上，堆与栈的区分问题，似乎是一个永恒的话题，由此可见，初学者对此往往是混淆不清的，所以我决定拿他第一个开刀。</p><p>首先，我们举一个例子：<br>void f() { int* p&#x3D;new int[5]; }<br>这条短短的一句话就包含了堆与栈，看到new，我们首先就应该想到，我们分配了一块堆内存，那么指针p呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针p。在程序会先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块内存的首地址，放入栈中，他在VC6下的汇编代码如下：</p><p>00401028 push 14h<br>0040102A call operator new (00401060)<br>0040102F add esp,4<br>00401032 mov dword ptr [ebp-8],eax<br>00401035 mov eax,dword ptr [ebp-8]<br>00401038 mov dword ptr [ebp-4],eax</p><p>这里，我们为了简单并没有释放内存，那么该怎么去释放呢？是delete p么？澳，错了，应该是delete []p，这是为了告诉编译器：我删除的是一个数组，VC6就会根据相应的Cookie信息去进行释放内存的工作。<br>好了，我们回到我们的主题：堆和栈究竟有什么区别？<br>主要的区别由以下几点：<br>1、管理方式不同；<br>2、空间大小不同；<br>3、能否产生碎片不同；<br>4、生长方向不同；<br>5、分配方式不同；<br>6、分配效率不同；</p><p>管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。<br>空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：<br>打开工程，依次操作菜单如下：Project-&gt;Setting-&gt;Link，在Category 中选中Output，然后在Reserve中设定堆栈的最大值和commit。<br>注意：reserve最小值为4Byte；commit是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。</p><p>碎片问题：对于堆来讲，频繁的new&#x2F;delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。</p><p>生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。</p><p>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p><p>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C&#x2F;C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构&#x2F;操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p><p>从这里我们可以看到，堆和栈相比，由于大量new&#x2F;delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。</p><p>虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。<br>无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果,就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候debug可是相当困难的：）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯</title>
    <link href="/2023/02/26/%E5%9B%9E%E6%BA%AF/"/>
    <url>/2023/02/26/%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="回朔法的思想："><a href="#回朔法的思想：" class="headerlink" title="回朔法的思想："></a>回朔法的思想：</h3><p>回朔法的重要思想在于： 通过枚举法，对所有可能性进行遍历。 但是枚举的顺序是 一条路走到黑，发现黑之后，退一步，再向前尝试没走过的路。直到所有路都试过。因此回朔法可以简单的理解为： 走不通就退一步的方枚举法就叫回朔法。而这里回退点也叫做回朔点。</p><h3 id="回朔关键点"><a href="#回朔关键点" class="headerlink" title="回朔关键点"></a>回朔关键点</h3><p>通过分析发现，回朔法实现的三大技术关键点分别是：</p><ol><li>一条路走到黑</li><li>回退一步</li><li>另寻他路</li></ol><h3 id="关键点的实现"><a href="#关键点的实现" class="headerlink" title="关键点的实现"></a>关键点的实现</h3><p>那么如何才能用代码实现上述三个关键点呢？</p><ol><li>for 循环</li><li>递归</li></ol><h4 id="解释如下"><a href="#解释如下" class="headerlink" title="解释如下"></a>解释如下</h4><ul><li>for循环的作用在于另寻他路： 你可以用for循环可以实现一个路径选择器的功能，该路径选择器可以逐个选择当前节点下的所有可能往下走下去的分支路径。 例如： 现在你走到了节点a，a就像个十字路口，你从上面来到达了a，可以继续向下走。若此时向下走的路有i条，那么你肯定要逐个的把这i条都试一遍才行。而for的作用就是可以让你逐个把所有向下的i个路径既不重复，也不缺失的都试一遍</li><li>递归可以实现一条路走到黑和回退一步： 一条路走到黑： 递归意味着继续向着for给出的路径向下走一步。 如果我们把递归放在for循环内部，那么for每一次的循环，都在给出一个路径之后，进入递归，也就继续向下走了。直到递归出口（走无可走）为止。 那么这就是一条路走到黑的实现方法。 递归从递归出口出来之后，就会实现回退一步。</li></ul><p>因此for循环和递归配合可以实现回朔： 当递归从递归出口出来之后。上一层的for循环就会继续执行了。而for循环的继续执行就会给出当前节点下的下一条可行路径。而后递归调用，就顺着这条从未走过的路径又向下走一步。这就是回朔</p><p>说了这么多，回朔法的通常模板是什么呢？ 递归和for又是如何配合的呢？</p><h4 id="回朔代码模板"><a href="#回朔代码模板" class="headerlink" title="回朔代码模板"></a>回朔代码模板</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>():<br>    <br>    <span class="hljs-keyword">if</span> (回朔点）：<span class="hljs-comment"># 这条路走到底的条件。也是递归出口</span><br>        保存该结果<br>        <span class="hljs-keyword">return</span>   <br>    <br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> route <span class="hljs-keyword">in</span> all_route_set :  逐步选择当前节点下的所有可能route<br>            <br>            <span class="hljs-keyword">if</span> 剪枝条件：<br>                剪枝前的操作<br>                <span class="hljs-keyword">return</span>   <span class="hljs-comment">#不继续往下走了，退回上层，换个路再走</span><br>            <br>            <span class="hljs-keyword">else</span>：<span class="hljs-comment">#当前路径可能是条可行路径</span><br>            <br>                保存当前数据  <span class="hljs-comment">#向下走之前要记住已经走过这个节点了。例如push当前节点</span><br>        <br>                self.backward() <span class="hljs-comment">#递归发生，继续向下走一步了。</span><br>                <br>                回朔清理     <span class="hljs-comment"># 该节点下的所有路径都走完了，清理堆栈，准备下一个递归。例如弹出当前节点</span><br></code></pre></td></tr></table></figure><p>这里剪枝操作指的是： 对于有些问题，你走着走着，若某种情况发生了，你就已经直到不能继续往下走了，再走也没有用了。而这个情况就被称之为剪枝条件。</p><p>而DFS就是一个最典型的回朔法的应用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum</span>(<span class="hljs-params">self, candidates: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(candidates) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        candidates.sort()<br>        path = []<br>        res = []<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        ！！！重点！！！</span><br><span class="hljs-string">        在python中，如果传参是mutable var, 那么传参相当于引用，因此调用后，如果调用函数的内部对该传入变量进行修改，就会导致直接改变原始对象。这就是典型的privacy leak！！发生了。</span><br><span class="hljs-string">        例如在这个，list就是该mutable var，而如果以path或res 为传参，放在__DFS 中， 那么就相当于在__DFS内部，实际上用的都是一个物理地址下的res和path，类似于全局变量。</span><br><span class="hljs-string">        因此combinationSum下的局部变量path和res也在——DFS运行的过程中发生了改变。</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        利用这个性质，我们可以把mutable var当成传入参数，从而实现全局变量的效果。</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        self.__DFS(candidates, target, <span class="hljs-number">0</span>, path, res)<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        DFS的实现</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__DFS</span>(<span class="hljs-params">self, candidates, target, begin, path, res</span>):<br>        path = path.copy()<br>        <span class="hljs-comment"># 递归出口 就是余数为0</span><br>        <span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span>:<br>            res.append(path)   <span class="hljs-comment">#记录该符合条件的结果</span><br>            <span class="hljs-keyword">return</span><br>        <br>        <span class="hljs-comment">#若当前路径有可能可行。</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(begin, <span class="hljs-built_in">len</span>(candidates)):  <span class="hljs-comment"># 我们现在到begin的节点上了</span><br>            <span class="hljs-keyword">if</span> target - candidates[i] &lt; <span class="hljs-number">0</span>:  <span class="hljs-comment"># 剪枝条件</span><br>                <span class="hljs-keyword">return</span>                      <span class="hljs-comment"># 如果当前节点就不行了，就不用继续了,这里到不用继续了即包括该depth不用继续了，也包括该节点更大到child也不用继续了，该节点pop出来</span><br>            <br>            path.append(candidates[i])  <span class="hljs-comment">#记录当前为止</span><br>            self.__DFS(candidates, target - candidates[i], i, path, res)<span class="hljs-comment"># 向下继续走，记住递归不是return，递归到实现是调用！一旦return发生，递归停止。</span><br>            path.pop()  <span class="hljs-comment"># 回朔清理。当前节点下的所有情况都进行完了，该节点也不应该在path里面了。</span><br></code></pre></td></tr></table></figure><h2 id="排列和组合"><a href="#排列和组合" class="headerlink" title="排列和组合"></a>排列和组合</h2><p>举例子：[1,2] [2,1]</p><p>对于排列来说，这俩不同，所以下标i从0开始</p><p>对于组合来说，这俩是相同的，下标从startIndex(i+1)</p><h2 id="去重逻辑"><a href="#去重逻辑" class="headerlink" title="去重逻辑"></a>去重逻辑</h2><p>如果给出的数组内有重复元素，那么需要去重</p><p>先定义一个用来标识的int[] 或者 boolen[]数组,进行数层去重，统一格式！！！！<strong>注意！！！！一定要对数组进行排序Arrays.sort(nums)！！！</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">if(i&gt;0 &amp;&amp; nums<span class="hljs-comment">[i-1]</span>==nums<span class="hljs-comment">[i]</span> &amp;&amp;flag<span class="hljs-comment">[i-1]</span>==0)&#123;<br>       continue;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="排列注意点"><a href="#排列注意点" class="headerlink" title="排列注意点"></a>排列注意点</h2><p>跳过上一次使用过的</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">//上一步已经用过的直接跳过<br>if(flag[i]<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>)&#123;<br>    continue<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; res = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>    LinkedList&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span> = <span class="hljs-built_in">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-type">int</span>[] flag = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">20</span>];<br>    <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; permuteUnique(<span class="hljs-type">int</span>[] nums) &#123;<br>        Arrays.sort(nums);<br>        permuteHelper(nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> permuteHelper(<span class="hljs-type">int</span>[] nums)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-type">path</span>.size() == nums.length)&#123;<br>            res.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;(<span class="hljs-type">path</span>));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>        //去重重复元素<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i<span class="hljs-number">-1</span>]==nums[i] &amp;&amp;flag[i<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            //上一步已经用过的直接跳过<br>            <span class="hljs-keyword">if</span>(flag[i]==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">path</span>.<span class="hljs-keyword">add</span>(nums[i]);<br>            flag[i] = <span class="hljs-number">1</span>;<br>            permuteHelper(nums);<br>            <span class="hljs-type">path</span>.removeLast();<br>            flag[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/2023/02/23/Docker/"/>
    <url>/2023/02/23/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="1-初识Docker"><a href="#1-初识Docker" class="headerlink" title="1.初识Docker"></a>1.初识Docker</h1><h2 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1.什么是Docker"></a>1.1.什么是Docker</h2><p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p><ul><li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li><li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li></ul><h3 id="1-1-1-应用部署的环境问题"><a href="#1-1-1-应用部署的环境问题" class="headerlink" title="1.1.1.应用部署的环境问题"></a>1.1.1.应用部署的环境问题</h3><p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p><ul><li><p>依赖关系复杂，容易出现兼容性问题</p></li><li><p>开发、测试、生产环境有差异</p></li></ul><p><img src="/../docker_pic/image-20210731141907366.png" alt="image-20210731141907366"></p><p>例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</p><h3 id="1-1-2-Docker解决依赖兼容问题"><a href="#1-1-2-Docker解决依赖兼容问题" class="headerlink" title="1.1.2.Docker解决依赖兼容问题"></a>1.1.2.Docker解决依赖兼容问题</h3><p>而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？</p><p>Docker为了解决依赖的兼容问题的，采用了两个手段：</p><ul><li><p>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</p></li><li><p>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</p></li></ul><p><img src="/../docker_pic/image-20210731142219735.png" alt="image-20210731142219735"></p><p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p><p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p><h3 id="1-1-3-Docker解决操作系统环境差异"><a href="#1-1-3-Docker解决操作系统环境差异" class="headerlink" title="1.1.3.Docker解决操作系统环境差异"></a>1.1.3.Docker解决操作系统环境差异</h3><p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下：</p><p><img src="/../docker_pic/image-20210731143401460.png" alt="image-20210731143401460"></p><p>结构包括：</p><ul><li>计算机硬件：例如CPU、内存、磁盘等</li><li>系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供<strong>内核指令</strong>，用于操作计算机硬件。</li><li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li></ul><p>应用于计算机交互的流程如下：</p><p>1）应用调用操作系统应用（函数库），实现各种功能</p><p>2）系统函数库是对内核指令集的封装，会调用内核指令</p><p>3）内核指令操作计算机硬件</p><p>Ubuntu和CentOSpringBoot都是基于Linux内核，无非是系统应用不同，提供的函数库有差异：</p><p><img src="/../docker_pic/image-20210731144304990.png" alt="image-20210731144304990"></p><p>此时，如果将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了：</p><p><img src="/../docker_pic/image-20210731144458680.png" alt="image-20210731144458680"></p><p>Docker如何解决不同系统环境的问题？</p><ul><li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li><li>Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行</li></ul><p>如图：</p><p><img src="/../docker_pic/image-20210731144820638.png" alt="image-20210731144820638"></p><h3 id="1-1-4-小结"><a href="#1-1-4-小结" class="headerlink" title="1.1.4.小结"></a>1.1.4.小结</h3><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li></ul><p>Docker如何解决开发、测试、生产环境有差异的问题？</p><ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul><p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p><ul><li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li><li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li><li>启动、移除都可以通过一行命令完成，方便快捷</li></ul><h2 id="1-2-Docker和虚拟机的区别"><a href="#1-2-Docker和虚拟机的区别" class="headerlink" title="1.2.Docker和虚拟机的区别"></a>1.2.Docker和虚拟机的区别</h2><p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p><p>两者有什么差异呢？</p><p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟</strong>硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</p><p><strong>Docker</strong>仅仅是封装函数库，并没有模拟完整的操作系统，如图：</p><p><img src="/../docker_pic/image-20210731145914960.png" alt="image-20210731145914960"></p><p>对比来看：</p><p><img src="/../docker_pic/image-20210731152243765.png" alt="image-20210731152243765"></p><p>小结：</p><p>Docker和虚拟机的差异：</p><ul><li><p>docker是一个系统进程；虚拟机是在操作系统中的操作系统</p></li><li><p>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</p></li></ul><h2 id="1-3-Docker架构"><a href="#1-3-Docker架构" class="headerlink" title="1.3.Docker架构"></a>1.3.Docker架构</h2><h3 id="1-3-1-镜像和容器"><a href="#1-3-1-镜像和容器" class="headerlink" title="1.3.1.镜像和容器"></a>1.3.1.镜像和容器</h3><p>Docker中有几个重要的概念：</p><p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p><p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p><p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p><p>而<strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p><p><strong>容器</strong>呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p><p><img src="/../docker_pic/image-20210731153059464.png" alt="image-20210731153059464"></p><p>例如你下载了一个QQ，如果我们将QQ在磁盘上的运行<strong>文件</strong>及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。</p><h3 id="1-3-2-DockerHub"><a href="#1-3-2-DockerHub" class="headerlink" title="1.3.2.DockerHub"></a>1.3.2.DockerHub</h3><p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。</p><ul><li><p>DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。</p></li><li><p>国内也有类似于DockerHub 的公开服务，比如 <a href="https://c.163yun.com/hub">网易云镜像服务</a>、<a href="https://cr.console.aliyun.com/">阿里云镜像库</a>等。</p></li></ul><p>我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像：</p><p><img src="/../docker_pic/image-20210731153743354.png" alt="image-20210731153743354"></p><h3 id="1-3-3-Docker架构"><a href="#1-3-3-Docker架构" class="headerlink" title="1.3.3.Docker架构"></a>1.3.3.Docker架构</h3><p>我们要使用Docker来操作镜像、容器，就必须要安装Docker。</p><p>Docker是一个CS架构的程序，由两部分组成：</p><ul><li><p>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</p></li><li><p>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</p></li></ul><p>如图：</p><p><img src="/../docker_pic/image-20210731154257653.png" alt="image-20210731154257653"></p><h3 id="1-3-4-小结"><a href="#1-3-4-小结" class="headerlink" title="1.3.4.小结"></a>1.3.4.小结</h3><p>镜像：</p><ul><li>将应用程序及其依赖、环境、配置打包在一起</li></ul><p>容器：</p><ul><li>镜像运行起来就是容器，一个镜像可以运行多个容器</li></ul><p>Docker结构：</p><ul><li><p>服务端：接收命令或远程请求，操作镜像或容器</p></li><li><p>客户端：发送命令或者请求到Docker服务端</p></li></ul><p>DockerHub：</p><ul><li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li></ul><h2 id="1-4-安装Docker"><a href="#1-4-安装Docker" class="headerlink" title="1.4.安装Docker"></a>1.4.安装Docker</h2><p>企业部署一般都是采用Linux操作系统，而其中又数CentOS发行版占比最多，因此我们在CentOS下安装Docker。参考课前资料中的文档：</p><p><img src="/../docker_pic/image-20210731155002425.png" alt="image-20210731155002425"></p><h1 id="2-Docker的基本操作"><a href="#2-Docker的基本操作" class="headerlink" title="2.Docker的基本操作"></a>2.Docker的基本操作</h1><h2 id="2-1-镜像操作"><a href="#2-1-镜像操作" class="headerlink" title="2.1.镜像操作"></a>2.1.镜像操作</h2><h3 id="2-1-1-镜像名称"><a href="#2-1-1-镜像名称" class="headerlink" title="2.1.1.镜像名称"></a>2.1.1.镜像名称</h3><p>首先来看下镜像的名称组成：</p><ul><li>镜名称一般分两部分组成：[repository]:[tag]。</li><li>在没有指定tag时，默认是latest，代表最新版本的镜像</li></ul><p>如图：</p><p><img src="/../docker_pic/image-20210731155141362.png" alt="image-20210731155141362"></p><p>这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。</p><h3 id="2-1-2-镜像命令"><a href="#2-1-2-镜像命令" class="headerlink" title="2.1.2.镜像命令"></a>2.1.2.镜像命令</h3><p>常见的镜像操作命令如图：</p><p><img src="/../docker_pic/image-20210731155649535.png" alt="image-20210731155649535"></p><h3 id="2-1-3-案例1-拉取、查看镜像"><a href="#2-1-3-案例1-拉取、查看镜像" class="headerlink" title="2.1.3.案例1-拉取、查看镜像"></a>2.1.3.案例1-拉取、查看镜像</h3><p>需求：从DockerHub中拉取一个nginx镜像并查看</p><p>1）首先去镜像仓库搜索nginx镜像，比如<a href="https://hub.docker.com/">DockerHub</a>:</p><p><img src="/../docker_pic/image-20210731155844368.png" alt="image-20210731155844368"></p><p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p><p><img src="/../docker_pic/image-20210731155856199.png" alt="image-20210731155856199"></p><p>3）通过命令：docker images 查看拉取到的镜像</p><p><img src="/../docker_pic/image-20210731155903037.png" alt="image-20210731155903037"></p><h3 id="2-1-4-案例2-保存、导入镜像"><a href="#2-1-4-案例2-保存、导入镜像" class="headerlink" title="2.1.4.案例2-保存、导入镜像"></a>2.1.4.案例2-保存、导入镜像</h3><p>需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来</p><p>1）利用docker xx –help命令查看docker save和docker load的语法</p><p>例如，查看save命令用法，可以输入命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker save --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/../docker_pic/image-20210731161104732.png" alt="image-20210731161104732"></p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker save -o [保存的目标文件名称] [镜像名称]<br></code></pre></td></tr></table></figure><p>2）使用docker save导出镜像到磁盘 </p><p>运行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker save -o nginx.tar nginx:latest<br></code></pre></td></tr></table></figure><p>结果如图：</p><p><img src="/../docker_pic/image-20210731161354344.png" alt="image-20210731161354344"></p><p>3）使用docker load加载镜像</p><p>先删除本地的nginx镜像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker rmi nginx:latest<br></code></pre></td></tr></table></figure><p>然后运行命令，加载本地文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker load -i nginx.tar<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/../docker_pic/image-20210731161746245.png" alt="image-20210731161746245"></p><h3 id="2-1-5-练习"><a href="#2-1-5-练习" class="headerlink" title="2.1.5.练习"></a>2.1.5.练习</h3><p>需求：去DockerHub搜索并拉取一个Redis镜像</p><p>目标：</p><p>1）去DockerHub搜索Redis镜像</p><p>2）查看Redis镜像的名称和版本</p><p>3）利用docker pull命令拉取镜像</p><p>4）利用docker save命令将 redis:latest打包为一个redis.tar包</p><p>5）利用docker rmi 删除本地的redis:latest</p><p>6）利用docker load 重新加载 redis.tar文件</p><h2 id="2-2-容器操作"><a href="#2-2-容器操作" class="headerlink" title="2.2.容器操作"></a>2.2.容器操作</h2><h3 id="2-2-1-容器相关命令"><a href="#2-2-1-容器相关命令" class="headerlink" title="2.2.1.容器相关命令"></a>2.2.1.容器相关命令</h3><p>容器操作的命令如图：</p><p><img src="/../docker_pic/image-20210731161950495.png" alt="image-20210731161950495"></p><p>容器保护三个状态：</p><ul><li>运行：进程正常运行</li><li>暂停：进程暂停，CPU不再运行，并不释放内存</li><li>停止：进程终止，回收进程占用的内存、CPU等资源</li></ul><p>其中：</p><ul><li><p>docker run：创建并运行一个容器，处于运行状态</p></li><li><p>docker pause：让一个运行的容器暂停</p></li><li><p>docker unpause：让一个容器从暂停状态恢复运行</p></li><li><p>docker stop：停止一个运行的容器</p></li><li><p>docker start：让一个停止的容器再次运行</p></li><li><p>docker rm：删除一个容器</p></li></ul><h3 id="2-2-2-案例-创建并运行一个容器"><a href="#2-2-2-案例-创建并运行一个容器" class="headerlink" title="2.2.2.案例-创建并运行一个容器"></a>2.2.2.案例-创建并运行一个容器</h3><p>创建并运行nginx容器的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run --name containerName -p 80:80 -d nginx<br></code></pre></td></tr></table></figure><p>命令解读：</p><ul><li>docker run ：创建并运行一个容器</li><li>–name : 给容器起一个名字，比如叫做mn</li><li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li><li>-d：后台运行容器</li><li>nginx：镜像名称，例如nginx</li></ul><p>这里的<code>-p</code>参数，是将容器端口映射到宿主机端口。</p><p>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。</p><p>现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了：</p><p><img src="/../docker_pic/image-20210731163255863.png" alt="image-20210731163255863"></p><h3 id="2-2-3-案例-进入容器，修改文件"><a href="#2-2-3-案例-进入容器，修改文件" class="headerlink" title="2.2.3.案例-进入容器，修改文件"></a>2.2.3.案例-进入容器，修改文件</h3><p><strong>需求</strong>：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您”</p><p><strong>提示</strong>：进入容器要用到docker exec命令。</p><p><strong>步骤</strong>：</p><p>1）进入容器。进入我们刚刚创建的nginx容器的命令为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it mn bash<br></code></pre></td></tr></table></figure><p>命令解读：</p><ul><li><p>docker exec ：进入容器内部，执行一个命令</p></li><li><p>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p></li><li><p>mn ：要进入的容器的名称</p></li><li><p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p></li></ul><p>2）进入nginx的HTML所在目录 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</p><p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p><p><img src="/../docker_pic/image-20210731164159811.png" alt="image-20210731164159811"></p><p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p><p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p><p>我们执行命令，进入该目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/share/nginx/html<br></code></pre></td></tr></table></figure><p> 查看目录下文件：</p><p><img src="/../docker_pic/image-20210731164455818.png" alt="image-20210731164455818"></p><p>3）修改index.html的内容</p><p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sed -i -e <span class="hljs-string">&#x27;s#Welcome to nginx#传智教育欢迎您#g&#x27;</span> -e <span class="hljs-string">&#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27;</span> index.html<br></code></pre></td></tr></table></figure><p>在浏览器访问自己的虚拟机地址，例如我的是：<a href="http://192.168.150.101，即可看到结果：">http://192.168.150.101，即可看到结果：</a></p><p><img src="/../docker_pic/image-20210731164717604.png" alt="image-20210731164717604"></p><h3 id="2-2-4-小结"><a href="#2-2-4-小结" class="headerlink" title="2.2.4.小结"></a>2.2.4.小结</h3><p>docker run命令的常见参数有哪些？</p><ul><li>–name：指定容器名称</li><li>-p：指定端口映射</li><li>-d：让容器后台运行</li></ul><p>查看容器日志的命令：</p><ul><li>docker logs</li><li>添加 -f 参数可以持续查看日志</li></ul><p>查看容器状态：</p><ul><li>docker ps</li><li>docker ps -a 查看所有容器，包括已经停止的</li></ul><h2 id="2-3-数据卷（容器数据管理）"><a href="#2-3-数据卷（容器数据管理）" class="headerlink" title="2.3.数据卷（容器数据管理）"></a>2.3.数据卷（容器数据管理）</h2><p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。</p><p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p><p><img src="/../docker_pic/image-20210731172440275.png" alt="image-20210731172440275"></p><p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p><h3 id="2-3-1-什么是数据卷"><a href="#2-3-1-什么是数据卷" class="headerlink" title="2.3.1.什么是数据卷"></a>2.3.1.什么是数据卷</h3><p><strong>数据卷（volume）</strong>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p><p><img src="/../docker_pic/image-20210731173541846.png" alt="image-20210731173541846"></p><p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p><p>这样，我们操作宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html目录，就等于操作容器内的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html目录了</p><h3 id="2-3-2-数据集操作命令"><a href="#2-3-2-数据集操作命令" class="headerlink" title="2.3.2.数据集操作命令"></a>2.3.2.数据集操作命令</h3><p>数据卷操作的基本语法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker volume [COMMAND]<br></code></pre></td></tr></table></figure><p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p><ul><li>create 创建一个volume</li><li>inspect 显示一个或多个volume的信息</li><li>ls 列出所有的volume</li><li>prune 删除未使用的volume</li><li>rm 删除一个或多个指定的volume</li></ul><h3 id="2-3-3-创建和查看数据卷"><a href="#2-3-3-创建和查看数据卷" class="headerlink" title="2.3.3.创建和查看数据卷"></a>2.3.3.创建和查看数据卷</h3><p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p><p>① 创建数据卷</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker volume create html<br></code></pre></td></tr></table></figure><p>② 查看所有数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker volume <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/../docker_pic/image-20210731173746910.png" alt="image-20210731173746910"></p><p>③ 查看数据卷详细信息卷</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker volume inspect html<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/../docker_pic/image-20210731173809877.png" alt="image-20210731173809877"></p><p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p><p><strong>小结</strong>：</p><p>数据卷的作用：</p><ul><li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li></ul><p>数据卷操作：</p><ul><li>docker volume create：创建数据卷</li><li>docker volume ls：查看所有数据卷</li><li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li><li>docker volume rm：删除指定数据卷</li><li>docker volume prune：删除所有未使用的数据卷</li></ul><h3 id="2-3-4-挂载数据卷"><a href="#2-3-4-挂载数据卷" class="headerlink" title="2.3.4.挂载数据卷"></a>2.3.4.挂载数据卷</h3><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run \<br>  --name mn \<br>  -v html:/root/html \<br>  -p 8080:80<br>  nginx \<br></code></pre></td></tr></table></figure><p>这里的-v就是挂载数据卷的命令：</p><ul><li><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的&#x2F;root&#x2F;html这个目录中</li></ul><h3 id="2-3-5-案例-给nginx挂载数据卷"><a href="#2-3-5-案例-给nginx挂载数据卷" class="headerlink" title="2.3.5.案例-给nginx挂载数据卷"></a>2.3.5.案例-给nginx挂载数据卷</h3><p><strong>需求</strong>：创建一个nginx容器，修改容器内的html目录内的index.html内容</p><p><strong>分析</strong>：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。</p><p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p><p>步骤：</p><p>① 创建容器并挂载数据卷到容器内的HTML目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx<br></code></pre></td></tr></table></figure><p>② 进入html数据卷所在位置，并修改HTML内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看html数据卷的位置</span><br>docker volume inspect html<br><span class="hljs-comment"># 进入该目录</span><br><span class="hljs-built_in">cd</span> /var/lib/docker/volumes/html/_data<br><span class="hljs-comment"># 修改文件</span><br>vi index.html<br></code></pre></td></tr></table></figure><h3 id="2-3-6-案例-给MySQL挂载本地目录"><a href="#2-3-6-案例-给MySQL挂载本地目录" class="headerlink" title="2.3.6.案例-给MySQL挂载本地目录"></a>2.3.6.案例-给MySQL挂载本地目录</h3><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p><ul><li>带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录</li><li>直接挂载模式：宿主机目录 —&gt; 容器内目录</li></ul><p>如图：</p><p><img src="/../docker_pic/image-20210731175155453.png" alt="image-20210731175155453"></p><p><strong>语法</strong>：</p><p>目录挂载与数据卷挂载的语法是类似的：</p><ul><li>-v [宿主机目录]:[容器内目录]</li><li>-v [宿主机文件]:[容器内文件]</li></ul><p><strong>需求</strong>：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</p><p>实现思路如下：</p><p>1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像</p><p>2）创建目录&#x2F;tmp&#x2F;mysql&#x2F;data</p><p>3）创建目录&#x2F;tmp&#x2F;mysql&#x2F;conf，将课前资料提供的hmy.cnf文件上传到&#x2F;tmp&#x2F;mysql&#x2F;conf</p><p>4）去DockerHub查阅资料，创建并运行MySQL容器，要求：</p><p>① 挂载&#x2F;tmp&#x2F;mysql&#x2F;data到mysql容器内数据存储目录</p><p>② 挂载&#x2F;tmp&#x2F;mysql&#x2F;conf&#x2F;hmy.cnf到mysql容器的配置文件</p><p>③ 设置MySQL密码</p><h3 id="2-3-7-小结"><a href="#2-3-7-小结" class="headerlink" title="2.3.7.小结"></a>2.3.7.小结</h3><p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p><ul><li>-v volume名称:容器内目录</li><li>-v 宿主机文件:容器内文</li><li>-v 宿主机目录:容器内目录</li></ul><p>数据卷挂载与目录直接挂载的</p><ul><li>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</li><li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li></ul><h1 id="3-Dockerfile自定义镜像"><a href="#3-Dockerfile自定义镜像" class="headerlink" title="3.Dockerfile自定义镜像"></a>3.Dockerfile自定义镜像</h1><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p><p>而要自定义镜像，就必须先了解镜像的结构才行。</p><h2 id="3-1-镜像结构"><a href="#3-1-镜像结构" class="headerlink" title="3.1.镜像结构"></a>3.1.镜像结构</h2><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p><p>我们以MySQL为例，来看看镜像的组成结构：</p><p><img src="/../docker_pic/image-20210731175806273.png" alt="image-20210731175806273"></p><p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p><p>我们要构建镜像，其实就是实现上述打包的过程。</p><h2 id="3-2-Dockerfile语法"><a href="#3-2-Dockerfile语法" class="headerlink" title="3.2.Dockerfile语法"></a>3.2.Dockerfile语法</h2><p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p><p>我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。</p><p>而描述上述信息的文件就是Dockerfile文件。</p><p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p><p><img src="/../docker_pic/image-20210731180321133.png" alt="image-20210731180321133"></p><p>更新详细语法说明，请参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p><h2 id="3-3-构建Java项目"><a href="#3-3-构建Java项目" class="headerlink" title="3.3.构建Java项目"></a>3.3.构建Java项目</h2><h3 id="3-3-1-基于Ubuntu构建Java项目"><a href="#3-3-1-基于Ubuntu构建Java项目" class="headerlink" title="3.3.1.基于Ubuntu构建Java项目"></a>3.3.1.基于Ubuntu构建Java项目</h3><p>需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目</p><ul><li><p>步骤1：新建一个空文件夹docker-demo</p><p><img src="/../docker_pic/image-20210801101207444.png" alt="image-20210801101207444"></p></li><li><p>步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录</p><p><img src="/../docker_pic/image-20210801101314816.png" alt="image-20210801101314816"></p></li><li><p>步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录</p><p><img src="/../docker_pic/image-20210801101410200.png" alt="image-20210801101410200"></p></li><li><p>步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录</p><p><img src="/../docker_pic/image-20210801101455590.png" alt="image-20210801101455590"></p><p>其中的内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 指定基础镜像</span><br><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">16.04</span><br><span class="hljs-comment"># 配置环境变量，JDK的安装目录</span><br><span class="hljs-keyword">ENV</span> JAVA_DIR=/usr/local<br><br><span class="hljs-comment"># 拷贝jdk和java项目的包</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="hljs-variable">$JAVA_DIR</span>/</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span><br><br><span class="hljs-comment"># 安装JDK</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> <span class="hljs-variable">$JAVA_DIR</span> \</span><br><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span><br><span class="language-bash"> &amp;&amp; <span class="hljs-built_in">mv</span> ./jdk1.8.0_144 ./java8</span><br><br><span class="hljs-comment"># 配置环境变量</span><br><span class="hljs-keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8<br><span class="hljs-keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin<br><br><span class="hljs-comment"># 暴露端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8090</span><br><span class="hljs-comment"># 入口，java项目的启动命令</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span><br></code></pre></td></tr></table></figure></li><li><p>步骤5：进入docker-demo</p><p>将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下</p></li><li><p>步骤6：运行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker build -t javaweb:1.0 .<br></code></pre></td></tr></table></figure></li></ul><p>最后访问 <a href="http://192.168.150.101:8090/hello/count%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84ip%E6%94%B9%E6%88%90%E4%BD%A0%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BAip">http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip</a></p><h3 id="3-3-2-基于java8构建Java项目"><a href="#3-3-2-基于java8构建Java项目" class="headerlink" title="3.3.2.基于java8构建Java项目"></a>3.3.2.基于java8构建Java项目</h3><p>虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p><p>例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。</p><p>需求：基于java:8-alpine镜像，将一个Java项目构建为镜像</p><p>实现思路如下：</p><ul><li><p>① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile</p></li><li><p>② 拷贝课前资料提供的docker-demo.jar到这个目录中</p></li><li><p>③ 编写Dockerfile文件：</p><ul><li><p>a ）基于java:8-alpine作为基础镜像</p></li><li><p>b ）将app.jar拷贝到镜像中</p></li><li><p>c ）暴露端口</p></li><li><p>d ）编写入口ENTRYPOINT</p><p>内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span>-alpine<br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./app.jar /tmp/app.jar</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8090</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>④ 使用docker build命令构建镜像</p></li><li><p>⑤ 使用docker run创建容器并运行</p></li></ul><h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4.小结"></a>3.4.小结</h2><p>小结：</p><ol><li><p>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</p></li><li><p>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</p></li><li><p>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</p></li></ol><h1 id="4-Docker-Compose"><a href="#4-Docker-Compose" class="headerlink" title="4.Docker-Compose"></a>4.Docker-Compose</h1><p>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p><p><img src="/../docker_pic/image-20210731180921742.png" alt="image-20210731180921742"></p><h2 id="4-1-初识DockerCompose"><a href="#4-1-初识DockerCompose" class="headerlink" title="4.1.初识DockerCompose"></a>4.1.初识DockerCompose</h2><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json">version<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3.8&quot;</span><br> services<span class="hljs-punctuation">:</span><br>  mysql<span class="hljs-punctuation">:</span><br>    image<span class="hljs-punctuation">:</span> mysql<span class="hljs-punctuation">:</span><span class="hljs-number">5.7</span><span class="hljs-number">.25</span><br>    environment<span class="hljs-punctuation">:</span><br>     MYSQL_ROOT_PASSWORD<span class="hljs-punctuation">:</span> <span class="hljs-number">123</span> <br>    volumes<span class="hljs-punctuation">:</span><br>     - <span class="hljs-string">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span><br>     - <span class="hljs-string">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span><br>  web<span class="hljs-punctuation">:</span><br>    build<span class="hljs-punctuation">:</span> .<br>    ports<span class="hljs-punctuation">:</span><br>     - <span class="hljs-string">&quot;8090:8090&quot;</span><br><br></code></pre></td></tr></table></figure><p>上面的Compose文件就描述一个项目，其中包含两个容器：</p><ul><li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li><li>web：一个基于<code>docker build</code>临时构建的镜像容器，映射端口时8090</li></ul><p>DockerCompose的详细语法参考官网：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p><p>其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。</p><h2 id="4-2-安装DockerCompose"><a href="#4-2-安装DockerCompose" class="headerlink" title="4.2.安装DockerCompose"></a>4.2.安装DockerCompose</h2><p>参考课前资料</p><h2 id="4-3-部署微服务集群"><a href="#4-3-部署微服务集群" class="headerlink" title="4.3.部署微服务集群"></a>4.3.部署微服务集群</h2><p><strong>需求</strong>：将之前学习的cloud-demo微服务集群利用DockerCompose部署</p><p><strong>实现思路</strong>：</p><p>① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件</p><p>② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名</p><p>③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar</p><p>④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中</p><p>⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署</p><h3 id="4-3-1-compose文件"><a href="#4-3-1-compose文件" class="headerlink" title="4.3.1.compose文件"></a>4.3.1.compose文件</h3><p>查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录：</p><p><img src="/../docker_pic/image-20210731181341330.png" alt="image-20210731181341330"></p><p>内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.2&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">nacos:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nacos/nacos-server</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MODE:</span> <span class="hljs-string">standalone</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8848:8848&quot;</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7.25</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-number">123</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;$PWD/mysql/data:/var/lib/mysql&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;</span><br>  <span class="hljs-attr">userservice:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./user-service</span><br>  <span class="hljs-attr">orderservice:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./order-service</span><br>  <span class="hljs-attr">gateway:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./gateway</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;10010:10010&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到，其中包含5个service服务：</p><ul><li><code>nacos</code>：作为注册中心和配置中心<ul><li><code>image: nacos/nacos-server</code>： 基于nacos&#x2F;nacos-server镜像构建</li><li><code>environment</code>：环境变量<ul><li><code>MODE: standalone</code>：单点模式启动</li></ul></li><li><code>ports</code>：端口映射，这里暴露了8848端口</li></ul></li><li><code>mysql</code>：数据库<ul><li><code>image: mysql:5.7.25</code>：镜像版本是mysql:5.7.25</li><li><code>environment</code>：环境变量<ul><li><code>MYSQL_ROOT_PASSWORD: 123</code>：设置数据库root账户的密码为123</li></ul></li><li><code>volumes</code>：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据</li></ul></li><li><code>userservice</code>、<code>orderservice</code>、<code>gateway</code>：都是基于Dockerfile临时构建的</li></ul><p>查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表：</p><p><img src="/../docker_pic/image-20210801095205034.png" alt="image-20210801095205034"></p><p>查看微服务目录，可以看到都包含Dockerfile文件：</p><p><img src="/../docker_pic/image-20210801095320586.png" alt="image-20210801095320586"></p><p>内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span>-alpine<br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./app.jar /tmp/app.jar</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span><br></code></pre></td></tr></table></figure><h3 id="4-3-2-修改微服务配置"><a href="#4-3-2-修改微服务配置" class="headerlink" title="4.3.2.修改微服务配置"></a>4.3.2.修改微服务配置</h3><p>因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。</p><p>如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://mysql:3306/cloud_order?useSSL=false</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">orderservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">nacos:8848</span> <span class="hljs-comment"># nacos服务地址</span><br></code></pre></td></tr></table></figure><h3 id="4-3-3-打包"><a href="#4-3-3-打包" class="headerlink" title="4.3.3.打包"></a>4.3.3.打包</h3><p>接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。</p><p>可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 服务打包的最终名称 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>app<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>打包后：</p><p><img src="/../docker_pic/image-20210801095951030.png" alt="image-20210801095951030"></p><h3 id="4-3-4-拷贝jar包到部署目录"><a href="#4-3-4-拷贝jar包到部署目录" class="headerlink" title="4.3.4.拷贝jar包到部署目录"></a>4.3.4.拷贝jar包到部署目录</h3><p>编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。</p><p>user-service：</p><p><img src="/../docker_pic/image-20210801100201253.png" alt="image-20210801100201253"></p><p>order-service：</p><p><img src="/../docker_pic/image-20210801100231495.png" alt="image-20210801100231495"></p><p>gateway：</p><p><img src="/../docker_pic/image-20210801100308102.png" alt="image-20210801100308102"></p><h3 id="4-3-5-部署"><a href="#4-3-5-部署" class="headerlink" title="4.3.5.部署"></a>4.3.5.部署</h3><p>最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。</p><p>上传到任意目录：</p><p><img src="/../docker_pic/image-20210801100955653.png" alt="image-20210801100955653"></p><p>部署：</p><p>进入cloud-demo目录，然后运行下面的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker-compose up -d<br></code></pre></td></tr></table></figure><h1 id="5-Docker镜像仓库"><a href="#5-Docker镜像仓库" class="headerlink" title="5.Docker镜像仓库"></a>5.Docker镜像仓库</h1><h2 id="5-1-搭建私有镜像仓库"><a href="#5-1-搭建私有镜像仓库" class="headerlink" title="5.1.搭建私有镜像仓库"></a>5.1.搭建私有镜像仓库</h2><p>参考课前资料《CentOS7安装Docker.md》</p><h2 id="5-2-推送、拉取镜像"><a href="#5-2-推送、拉取镜像" class="headerlink" title="5.2.推送、拉取镜像"></a>5.2.推送、拉取镜像</h2><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p><p>① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080&#x2F;</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure><p>② 推送镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker push 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure><p>③ 拉取镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringMvc</title>
    <link href="/2023/02/22/JavaWeb/"/>
    <url>/2023/02/22/JavaWeb/</url>
    
    <content type="html"><![CDATA[<h2 id="Seesion和Cookie"><a href="#Seesion和Cookie" class="headerlink" title="Seesion和Cookie"></a>Seesion和Cookie</h2><ul><li>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li><li>有效期不同，Cookie  可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li><li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li><li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li><li>session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到。Cookie有个setPath的方法，可以设置可访问的路径，那么同一个网站中不同路径下的cookie互相是访问不到的</li></ul><h2 id="什么是-Cookie："><a href="#什么是-Cookie：" class="headerlink" title="什么是 Cookie："></a>什么是 Cookie：</h2><p>Cookie是服务器发送到客户端并保存在本地的一小块数据，它会在客户端下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。cookie中的数据以{key：value}的形式存在。</p><h3 id="cookie机制原理："><a href="#cookie机制原理：" class="headerlink" title="cookie机制原理："></a>cookie机制原理：</h3><p>比如服务端要想记录用户的状态，就使用response向浏览器发送一个Cookie。客户端浏览器会将这个cookie保存起来。浏览器再次请求服务端时，浏览器会把这个cookie带上。服务端检查这个cookie来获取用户状态。</p><h3 id="Cookie常用属性："><a href="#Cookie常用属性：" class="headerlink" title="Cookie常用属性："></a>Cookie常用属性：</h3><ul><li>name cookie的名字，Cookie一旦创建，名称便不可更改</li><li>value cookie的值</li><li>domain 可以访问该cookie的域名。如果设置为“.baidu.com”，则所有以“baidu.com”结尾的域名都可以访问该Cookie；第一个字符必须为“.”</li><li>maxAge Cookie失效的时间，单位秒。 正数，则超过maxAge秒之后失效。 负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。 为0，表示删除该Cookie。</li><li>isHttpOnly HttpOnly属性是用来限制非HTTP协议程序接口对客户端Cookie进行访问，将取Cookie的操作放到服务端，这样能有效的防止XSS攻击。</li></ul><h3 id="创建Cookie："><a href="#创建Cookie：" class="headerlink" title="创建Cookie："></a>创建Cookie：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;cookieSessionId&quot;</span>,<span class="hljs-string">&quot;qwertyuiop&quot;</span>); <span class="hljs-comment">//构造函数</span><br>cookie.setDomain(<span class="hljs-string">&quot;.baidu.com&quot;</span>);             <span class="hljs-comment">// 设置域名</span><br>cookie.setPath(<span class="hljs-string">&quot;/&quot;</span>);                        <span class="hljs-comment">// 设置路径</span><br>cookie.setMaxAge(Integer.MAX_VALUE);        <span class="hljs-comment">// 设置有效期为永久</span><br>response.addCookie(cookie);                 <span class="hljs-comment">// 回写到客户端</span><br></code></pre></td></tr></table></figure><h3 id="Cookie更新与删除："><a href="#Cookie更新与删除：" class="headerlink" title="Cookie更新与删除："></a>Cookie更新与删除：</h3><p>Cookie本身并没有提供修改和删除的方法，一般通过使用相同name的Cookie来覆盖原来的Cookie,以达到更新或删除的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;cookieSessionId&quot;</span>,<span class="hljs-string">&quot;new-qwertyuiop&quot;</span>);<br>response.addCookie(cookie);<br><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;cookieSessionId&quot;</span>,<span class="hljs-string">&quot;new-qwertyuiop&quot;</span>);<br>cookie.setMaxAge(<span class="hljs-number">0</span>);<span class="hljs-comment">//设置一个立即失效的cookie覆盖原cookie</span><br>response.addCookie(cookie);<br></code></pre></td></tr></table></figure><h3 id="如何获取与发送cookie"><a href="#如何获取与发送cookie" class="headerlink" title="如何获取与发送cookie"></a>如何获取与发送cookie</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//服务端从客户端取得cookie</span><br>Cookie[] cookies = request.getCookies();<br><br><span class="hljs-comment">//服务端向客户端发送cookie</span><br>response.addCookie(cookie);   <br></code></pre></td></tr></table></figure><p>对于Cookie来说，Cookie的同源只关注域名，是忽略协议和端口的。所以一般情况下，<a href="https://localhost:80和http://localhost:8080的Cookie是共享的。单个">https://localhost:80和http://localhost:8080的Cookie是共享的。单个</a> Cookie 保存的数据不能超过 4K。</p><h3 id="cookie的优缺点："><a href="#cookie的优缺点：" class="headerlink" title="cookie的优缺点："></a>cookie的优缺点：</h3><ul><li>优点： 适合用于存放需要每个请求都必须携带的数据 服务端也可以直接操作 Cookie 可以通过 domain 以及 path 控制数据存储的范围</li><li>缺点： 容量有限，规范只要求每个域名下最低提供 4kb 的存储空间 每次请求都会携带，如果存放了大量不必要的数据很显然会影响页面性能 不安全，永远不要在 Cookie 中存放用户的敏感数据 前端 API 不友好，CRUD 都是通过 document.cookie 进行，没有提供相关操作的方法</li></ul><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><blockquote><p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p></blockquote><h3 id="session机制原理："><a href="#session机制原理：" class="headerlink" title="session机制原理："></a>session机制原理：</h3><p>当客户端请求创建一个session时，服务端会先检查客户端的请求里面有没有带着session标识-sessionId。如果有，则说明服务器以前已为此客户端创建过session，于是就根据这个sessionId把session检索出来。如果客户端请求中不包含sessionId，则为客户端创建一个session并且生成一个与这个session相关联的sessionId。 这个sessionId将被在本次响应中返回给客户端保存。保存sessionId的方式大多情况下用的是cookie。</p><h3 id="创建session"><a href="#创建session" class="headerlink" title="创建session"></a>创建session</h3><p>HttpSession session &#x3D; request.getSession();</p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h3 id="当接收一个请求时，springMvc的处理流程"><a href="#当接收一个请求时，springMvc的处理流程" class="headerlink" title="当接收一个请求时，springMvc的处理流程"></a>当接收一个请求时，springMvc的处理流程</h3><p><img src="/../web_pic/1.png"></p><h3 id="拦截器概念"><a href="#拦截器概念" class="headerlink" title="拦截器概念"></a>拦截器概念</h3><p><img src="/../web_pic/2.png"></p><h3 id="拦截器与过滤器的区别"><a href="#拦截器与过滤器的区别" class="headerlink" title="拦截器与过滤器的区别"></a>拦截器与过滤器的区别</h3><p><img src="/../web_pic/3.png"></p><h2 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h2><p>MVC是一种软件架构的思想，将软件按照模型，视图，控制器来划分</p><p>M：Model,模型层，指工程中的JavaBean,作用是处理数据</p><p>JavaBean分为两类：</p><ul><li>一类称为实体类Bean:专门存储业务数据的，如Student,User等</li><li>一类称为业务处理Bean：指Service或Dao，专门用于处理业务逻辑和数据访问。</li></ul><p>V：View,视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</p><p>C：Controller,控制层，指工程中的Servlet,作用是接收请求和响应浏览器</p><p>MVC的工作流程：</p><p>用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller,Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Juc</title>
    <link href="/2023/02/22/Juc/"/>
    <url>/2023/02/22/Juc/</url>
    
    <content type="html"><![CDATA[<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><p>在Java中，线程部分是一个重点，本篇文章说的JUC也是关于线程的。JUC就是java.util.concurrent工具包的简称。这是一个处理线程的工具包。</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p><strong>进程</strong> 是计算机中程序关于某数据集合的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p><p><strong>线程</strong>是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><p>简单来说：</p><p>进程：指系统中正在运行的一个应用程序；程序一旦运行就是进程；进程—–资源配分的最小单位</p><p>线程：系统分配处理机时间资源的基本单位，或者说进程之内独立执行的一个单元的执行流。线程—-程序执行的最小单位。</p><p>比如360安全卫士，打开这个软件就是一个进程，里面有木马查杀，垃圾清理，优化加速等可以分别执行的线程。</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>一、<strong>简介</strong><br>volatile是Java提供的一种轻量级的同步机制。Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized（synchronized通常称为重量级锁），volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。</p><p>二、<strong>并发编程的3个基本概念</strong><br>1.<strong>原子性</strong><br>     定义： 即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><pre><code class="hljs">原子性是拒绝多线程操作的，不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。简而言之，在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。例如 a=1是原子性操作，但是a++和a +=1就不是原子性操作。Java中的原子性操作包括：</code></pre><p>（1）基本类型的读取和赋值操作，且赋值必须是值赋给变量，变量之间的相互赋值不是原子性操作。</p><p>（2）所有引用reference的赋值操作</p><p>（3）java.concurrent.Atomic.* 包中所有类的一切操作</p><p>2.<strong>可见性</strong><br>   定义：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p>   在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。Java提供了volatile来保证可见性，当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，其他线程读取共享变量时，会直接从主内存中读取。当然，synchronize和Lock都可以保证可见性。synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><p>3.<strong>有序性</strong><br>   定义：即程序执行的顺序按照代码的先后顺序执行。</p><p>   Java内存模型中的有序性可以总结为：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。</p><p>   在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序不会影响单线程的运行结果，但是对多线程会有影响。Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）。另外，可以通过synchronized和Lock来保证有序性，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p><p>三、<strong>锁的互斥和可见性</strong><br>   锁提供了两种主要特性：互斥（mutual exclusion） 和可见性（visibility）。</p><p>（1）互斥即一次只允许一个线程持有某个特定的锁，一次就只有一个线程能够使用该共享数据。</p><p>（2）可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。也即当一条线程修改了共享变量的值，新值对于其他线程来说是可以立即得知的。如果没有同步机制提供的这种可见性保证，线程看到的共享变  量可能是修改前的值或不一致的值，这将引发许多严重问题。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：</p><pre><code class="hljs">a.对变量的写操作不依赖于当前值。b.该变量没有包含在具有其他变量的不变式中。</code></pre><p>  实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。事实上就是保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p><p>四、<strong>Java的内存模型JMM以及共享变量的可见性</strong><br> JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。</p><p><img src="/../JUC_pic/31.png" alt="juc"></p><p>   对于普通的共享变量来讲，线程A将其修改为某个值发生在线程A的本地内存中，此时还未同步到主内存中去；而线程B已经缓存了该变量的旧值，所以就导致了共享变量值的不一致。解决这种共享变量在多线程模型中的不可见性问题，较粗暴的方式自然就是加锁，但是此处使用synchronized或者Lock这些方式太重量级了，比较合理的方式其实就是volatile。</p><p>  需要注意的是，JMM是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应cpu缓存和物理内存</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileTest</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">boolean</span> run = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> throws InterruptedException </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span>(run)&#123;<br>                <br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>        t.<span class="hljs-built_in">start</span>();<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        run = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程t不会如预想的停下来</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行以上代码，可以看到结果，程序并没有结束，而是一直处于运行状态，按道理来说主线程不是将run 置于false了吗？t1应该暂停才对啊，这就涉及到可见性问题，主线程在自己的工作内存修改了run的值，但是t1线程不知道主线程修改了run的值，所以一直在运行。</p><p>解决办法：</p><ul><li>将run用volatile修饰</li></ul><p>再次运行程序，程序暂停下来了，说明volatile可以将run在任何一个线程中做出的修改马上让其他线程可见。(volatile是Java提供的一种轻量级的同步机制)</p><ul><li><p>在while(){}里加一个System.out.println();</p><p>点开println()方法</p><p><img src="/../JUC_pic/40.png" alt="juc"></p></li></ul><p>可以看到println()里加了synchronized锁</p><p>JMM关于synchronized的两条规定:</p><p>1）线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值</p><p>2）线程解锁前，必须把共享变量的最新值刷新到主内存中</p><p>（注意：加锁与解锁需要是同一把锁）</p><p>synchronized具体过程是：</p><p>获得同步锁；<br>清空工作内存；<br>从主内存拷贝对象副本到工作内存；<br>执行代码(计算或者输出等)；<br>刷新主内存数据；<br>释放同步锁。</p><p>五、<strong>volatile变量的特性</strong><br> 1.保证可见性，不保证原子性<br>  （1）当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去；</p><p>  （2）这个写会操作会导致其他线程中的volatile变量缓存无效。</p><p> 2.禁止指令重排<br>    重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：</p><p> （1）重排序操作不会对存在数据依赖关系的操作进行重排序。</p><p>　 比如：a&#x3D;1;b&#x3D;a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。</p><p> （2）重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变</p><p>　 比如：a&#x3D;1;b&#x3D;2;c&#x3D;a+b这三个操作，第一步（a&#x3D;1)和第二步(b&#x3D;2)由于不存在数据依赖关系， 所以可能会发生重排序，但是c&#x3D;a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c&#x3D;a+b&#x3D;3。</p><pre><code class="hljs">重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果，下例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行status=true再执行a=2。而此时线程B会顺利到达4处，而线程A中a=2这个操作还未被执行，所以b=a+1的结果也有可能依然等于2。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestVolatile</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//状态切换为true</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> changeStatus&#123;<br>        a = <span class="hljs-number">2</span>;   <span class="hljs-comment">//1</span><br>        status = <span class="hljs-literal">true</span>;  <span class="hljs-comment">//2</span><br>    &#125;<span class="hljs-comment">//若状态为true，则为running</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(status)&#123;   <span class="hljs-comment">//3</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a + <span class="hljs-number">1</span>;  <span class="hljs-comment">//4</span><br>        System.out.println(b);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​     使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序,volatile禁止指令重排序也有一些规则：</p><pre><code class="hljs"> a.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； b.在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见。</code></pre><p>六、<strong>volatile不适用的场景</strong><br> 1.volatile不适合复合操作<br>  例如，int++不是一个原子性操作，可以由读取、加、赋值3步组成，所以结果并不能达到30000。.</p><p><img src="/../JUC_pic/32.png"></p><p>  2.解决方法<br> （1）采用synchronized</p><p><img src="/../JUC_pic/33.png"></p><p> （2）采用Lock</p><p><img src="/../JUC_pic/34.png"></p><p> （3）采用java并发包中的原子操作类，原子操作类是通过CAS循环的方式来保证其原子性的</p><p><img src="/../JUC_pic/35.png"></p><p>七、<strong>volatile原理</strong><br>  volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p><p>（1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p><p>（2）它会强制将对缓存的修改操作立即写入主存；</p><p>（3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p><p>八、<strong>单例模式的双重锁为什么要加volatile</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestInstance</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> TestInstance instance;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestInstance <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span>(TestInstance.class)&#123; <br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestInstance</span>();<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>   需要volatile关键字的原因是，在并发情况下，如果没有volatile关键字，在第5行会出现问题。instance &#x3D; new TestInstance();可以分解为3行伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">a. memory = allocate() <span class="hljs-comment">//分配内存</span><br>b. ctorInstanc(memory) <span class="hljs-comment">//初始化对象</span><br>c. instance = memory <span class="hljs-comment">//设置instance指向刚分配的地址 </span><br></code></pre></td></tr></table></figure><p>   上面的代码在编译运行时，可能会出现重排序从a-b-c排序为a-c-b。在多线程的情况下会出现以下问题。当线程A在执行第5行代码时，B线程进来执行到第2行代码。假设此时A执行的过程中发生了指令重排序，即先执行了a和c，没有执行b。那么由于A线程执行了c导致instance指向了一段地址，所以B线程判断instance不为null，会直接跳到第6行并返回一个未初始化的对象。</p><h2 id="创建多线程的几种方式"><a href="#创建多线程的几种方式" class="headerlink" title="创建多线程的几种方式"></a>创建多线程的几种方式</h2><h3 id="继承Thread类创建线程"><a href="#继承Thread类创建线程" class="headerlink" title="继承Thread类创建线程"></a>继承Thread类创建线程</h3><p><strong>通过继承Thread</strong>类来创建并启动多线程的一般步骤如下：</p><p>1】定义Tread类的子类MyThread，并重写run()方法.run()方法的方法体（线程执行体）就是线程要执行的任务。</p><p>2】创建My<a href="https://so.csdn.net/so/search?q=Thread%E7%B1%BB&spm=1001.2101.3001.7020">Thread类</a>的实例</p><p>3】调用子类实例的start()方法来启动线程</p><p>创建Thread1类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;a&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建Thread2类</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    public void run() &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;b&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在主方法中：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        Thread t1 =<span class="hljs-keyword">new</span> <span class="hljs-type">Thread1</span>();<br>        Thread t2 =<span class="hljs-keyword">new</span> <span class="hljs-type">Thread2</span>();<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现-Runnable接口创建线程"><a href="#实现-Runnable接口创建线程" class="headerlink" title="实现 Runnable接口创建线程"></a><strong>实现 Runnable接口创建线程</strong></h3><p>通过实现Runnable接口创建并启动线程的一般步骤如下：</p><p>1】定义Runnable接口的实现类，必须重写run(）方法，这个run()方法和Thread中的run()方法一样，是线程的执行体</p><p>2】创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象</p><p>3】调用start()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;: &quot;</span>+i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">RunnableTest</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableTest</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r,<span class="hljs-string">&quot;线程1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r,<span class="hljs-string">&quot;线程2&quot;</span>);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">线程2: 0</span><br><span class="hljs-section">线程2: 1</span><br><span class="hljs-section">线程1: 0</span><br><span class="hljs-section">线程2: 2</span><br><span class="hljs-section">线程1: 1</span><br><span class="hljs-section">线程2: 3</span><br><span class="hljs-section">线程1: 2</span><br><span class="hljs-section">线程2: 4</span><br><span class="hljs-section">线程1: 3</span><br><span class="hljs-section">线程1: 4</span><br></code></pre></td></tr></table></figure><h3 id="继承Thread和实现Runnable接口的区别"><a href="#继承Thread和实现Runnable接口的区别" class="headerlink" title="继承Thread和实现Runnable接口的区别"></a>继承Thread和实现Runnable接口的区别</h3><ul><li>实现Runnable接口避免单继承局限</li><li>当子类实现Runnable接口，此时子类</li></ul><h3 id="实现Callable接口配合FutureTask"><a href="#实现Callable接口配合FutureTask" class="headerlink" title="实现Callable接口配合FutureTask"></a>实现Callable接口配合FutureTask</h3><p>实现</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gcode">步骤：<br><span class="hljs-number">1.</span>创建一个实现Callable的实现类<br><span class="hljs-number">2.</span>实现<span class="hljs-keyword">call</span>方法，将此线程需要执行的操作声明在<span class="hljs-keyword">call</span><span class="hljs-comment">()</span>中<br><span class="hljs-number">3.</span>创建Callable接口实现类的对象<br><span class="hljs-number">4.</span>将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象<br><span class="hljs-number">5.</span>将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start<span class="hljs-comment">()</span><br><span class="hljs-number">6.</span>获取Callable中<span class="hljs-keyword">call</span>方法的返回值<br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">**实现Callable接口的方式创建线程的强大之处**<br><span class="hljs-keyword">call</span><span class="hljs-comment">()</span>可以有返回值的<br><span class="hljs-keyword">call</span><span class="hljs-comment">()</span>可以抛出异常，被外面的操作捕获，获取异常的信息<br>Callable是支持泛型的<br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadNew</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        <span class="hljs-comment">//3.创建Callable接口实现类的对象</span><br>        NumThread numThread = <span class="hljs-keyword">new</span> NumThread();<br><br>        <span class="hljs-comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span><br>        FutureTask futureTask = <span class="hljs-keyword">new</span> FutureTask(numThread);<br><br>        <span class="hljs-comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span><br>        <span class="hljs-keyword">new</span> Thread(futureTask).start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//6.获取Callable中call方法的返回值</span><br>            <span class="hljs-comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span><br>            Object <span class="hljs-keyword">sum</span> = futureTask.get();<br>            System.out.println(<span class="hljs-string">&quot;总和为：&quot;</span> + <span class="hljs-keyword">sum</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_ inherited__">Callable</span> &#123;<br>    <span class="hljs-comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span><br>    @Override<br>    <span class="hljs-keyword">public</span> Object call() throws Exception &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//把100以内的偶数相加</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(i);<br>                <span class="hljs-keyword">sum</span> += i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">sum</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程池创建"><a href="#线程池创建" class="headerlink" title="线程池创建"></a>线程池创建</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">来自项目中的代码<br><span class="hljs-comment">//定义一个线程池</span><br>    <span class="hljs-keyword">private</span> static final ExecutorService CACHE_REBUILD_EXECUTOR =      <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Executors</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">FixedThreadPool(10)</span>;<br>  .<br>  .<br>  .<br>  .<br>      <span class="hljs-comment">//6.3获取锁成功 ，开启独立线程进行缓存重建</span><br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CACHE_REBUILD_EXECUTOR</span>.</span></span>submit(<span class="hljs-literal">()</span>-&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//查询数据库</span><br>                    R r1 = dbFallback.apply(id);<br>                    <span class="hljs-comment">//写入redis</span><br>                    this.set<span class="hljs-constructor">WithLogicExpire(<span class="hljs-params">key</span>,<span class="hljs-params">r1</span>,<span class="hljs-params">time</span>,<span class="hljs-params">unit</span>)</span>;<br>                &#125; catch (Exception e) &#123;<br>                    throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">RuntimeException(<span class="hljs-params">e</span>)</span>;<br>                &#125;finally &#123;<br>                    <span class="hljs-comment">//释放🔒</span><br>                    unlock(lockKey);<br>                &#125;<br>            &#125;);<br>    <br>  <br></code></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h3><ul><li><strong>互斥条件</strong>：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。</li><li><strong>不可剥夺条件</strong>：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。</li><li><strong>请求和保持条件</strong>：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。</li><li><strong>循环等待条件</strong>：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源。</li></ul><p>以上给出了导致死锁的四个必要条件，只要系统发生死锁则以上四个条件至少有一个成立。事实上循环等待的成立蕴含了前三个条件的成立，似乎没有必要列出然而考虑这些条件对死锁的预防是有利的，因为可以通过破坏四个条件中的任何一个来预防死锁的发生。</p><p>面试官：手写一个死锁demo~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">deadLockDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadLockTusk</span>(lock1,lock2,<span class="hljs-literal">true</span>),<span class="hljs-string">&quot;线程1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadLockTusk</span>(lock1,lock2,<span class="hljs-literal">false</span>),<span class="hljs-string">&quot;线程2&quot;</span>).start();<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockTusk</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>        <span class="hljs-keyword">private</span> Object lock1;<br>        <span class="hljs-keyword">private</span> Object lock2;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> flag;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DeadLockTusk</span><span class="hljs-params">(Object lock1, Object lock2, <span class="hljs-type">boolean</span> flag)</span> &#123;<br>            <span class="hljs-built_in">this</span>.lock1 = lock1;<br>            <span class="hljs-built_in">this</span>.lock2 = lock2;<br>            <span class="hljs-built_in">this</span>.flag = flag;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span>(flag) &#123;<br>                <span class="hljs-keyword">synchronized</span> (lock1)&#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;拿到了锁1&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;等待锁2释放&quot;</span>);<br>                    <span class="hljs-keyword">synchronized</span> (lock2)&#123;<br>                        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;拿到了锁2&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!flag) &#123;<br>                <span class="hljs-keyword">synchronized</span> (lock2)&#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;拿到了锁2&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;等待锁1释放&quot;</span>);<br>                    <span class="hljs-keyword">synchronized</span> (lock1)&#123;<br>                        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;拿到了锁1&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>我们可以通过破坏死锁产生的4个必要条件来 预防死锁，由于资源互斥是资源使用的固有特性是无法改变的。</p><ul><li><strong>破坏“不可剥夺”条件</strong>：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间它占有的资源将被隐式的释放重新加入到 系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。</li><li><strong>破坏”请求与保持条件“</strong>：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。</li><li><strong>破坏“循环等待”条件</strong>：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。</li></ul><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p><ul><li>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</li><li>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</li><li>BLOCKED ：阻塞状态，需要等待锁释放。</li><li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。(不见不散)</li><li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。（过时不候）</li><li>TERMINATED：终止状态，表示该线程已经运行完毕。</li></ul><p><img src="/../JUC_pic/1.png"></p><p>由上图可以看出：</p><ul><li><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p></li><li><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</p></li><li><p><strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</p></li><li><p>当线程进入 <code>synchronized</code> 方法&#x2F;块或者调用 <code>wait</code> 后（被 <code>notify</code>）重新进入 <code>synchronized</code> 方法&#x2F;块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。</p></li><li><p>线程在执行完了 <code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p></li></ul><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><ul><li>需要等待结果返回才能继续运行就是同步</li><li>不需要等待结果返回就能继续运行就是异步</li></ul><h2 id="查看进程和线程的方法"><a href="#查看进程和线程的方法" class="headerlink" title="查看进程和线程的方法"></a>查看进程和线程的方法</h2><p>Windows</p><ul><li>任务管理器</li><li>tasklist查看进程 ( tasklist | findstr “xx”)</li><li>taskkill杀死进程</li></ul><p>Linux</p><ul><li>ps  -ef查看所有进程(ps -ef | grep 关键字)</li><li>ps -fT -p <PID> 查看某个进程(PID)的所有线程</li><li>kill 杀死进程</li><li>top 按大写H切换是否显示线程</li><li>top -H -p <PID> 查看某个进程(PID)的所有线程</li></ul><p>Java</p><ul><li>jps命令查看所有Java进程</li><li>jstack <PID>查看某个Java进程(PID)的所有线程状态</li><li>jconsole来查看某个Java进程中线程的运行情况(图像界面)</li></ul><h2 id="线程中的常见方法"><a href="#线程中的常见方法" class="headerlink" title="线程中的常见方法"></a>线程中的常见方法</h2><p><img src="/../JUC_pic/2.png"></p><p><img src="/../JUC_pic/3.png"></p><p><img src="/../JUC_pic/4.png"></p><h3 id="start与run的区别"><a href="#start与run的区别" class="headerlink" title="start与run的区别"></a>start与run的区别</h3><ul><li><p>直接调用 run 是在主线程中执行了 run，没有启动新的线程</p></li><li><p>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</p></li></ul><h3 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h3><ol><li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException </li><li>睡眠结束后的线程未必会立刻得到执行</li><li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li></ol><h3 id="yield-让出，谦让"><a href="#yield-让出，谦让" class="headerlink" title="yield(让出，谦让)"></a>yield(让出，谦让)</h3><ol><li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程 </li><li>具体的实现依赖于操作系统的任务调度器</li></ol><h3 id="join-重要"><a href="#join-重要" class="headerlink" title="join(重要)"></a>join(重要)</h3><p>下面的代码执行，打印 r 是什么？</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">static</span> int r = <span class="hljs-number">0</span>;<br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br> test1();<br>&#125;<br>private <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> test1() throws InterruptedException &#123;<br> log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br> Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;开始&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> sleep(<span class="hljs-number">1</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;结束&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> r = <span class="hljs-number">10</span>;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;结果为:&#123;&#125;&quot;</span>, r)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;结束&quot;</span>)</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>分析</p><ul><li>因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出 r&#x3D;10</li><li>而主线程一开始就要打印 r 的结果，所以只能打印出 r&#x3D;0</li></ul><p>解决方法 </p><ul><li>用 sleep 行不行？为什么？</li><li>用 join，加在 t1.start() 之后即可</li></ul><p>Eg:  t1.join()  &#x3D;&#x3D; 主线程等待t1运行结束再运行后面的内容。</p><p>加了join，异步—&gt;同步</p><h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><p><strong>注意</strong>：interrupt只会给线程打个标记，不会真的打断线程，要打断线程还是得靠isInterrupted()方法判断再决定是否打断。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br>        Thread thread=<span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                System.out.println(<span class="hljs-string">&quot;正在运行。。。&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;,<span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">thread</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">Thread</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">500</span>)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">thread</span>.<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br></code></pre></td></tr></table></figure><p>结果是不断得打印“正在运行。。。”</p><p>可以打断 sleep，wait，join 的线程</p><p>这几个方法都会让线程进入阻塞状态</p><p>打断sleep,wait,join的线程，会清空打断状态</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">private <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> test1() throws InterruptedException &#123;<br> Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> sleep(<span class="hljs-number">1</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">0.5</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted())</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输出:<br>java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.InterruptedException</span>: sleep interrupted<br> at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.sleep</span>(Native Method)<br> at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.sleep</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">340</span>)<br> at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.TimeUnit</span><span class="hljs-selector-class">.sleep</span>(TimeUnit<span class="hljs-selector-class">.java</span>:<span class="hljs-number">386</span>)<br> at cn<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.n2</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Sleeper</span><span class="hljs-selector-class">.sleep</span>(Sleeper<span class="hljs-selector-class">.java</span>:<span class="hljs-number">8</span>)<br> at cn<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.n4</span><span class="hljs-selector-class">.TestInterrupt</span>.lambda<span class="hljs-variable">$test1</span>$<span class="hljs-number">3</span>(TestInterrupt<span class="hljs-selector-class">.java</span>:<span class="hljs-number">59</span>)<br> at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.run</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">745</span>)<br><span class="hljs-number">21</span>:<span class="hljs-number">18</span>:<span class="hljs-number">10.374</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 打断状态: false<br></code></pre></td></tr></table></figure><p>打断正常运行的线程, 不会清空打断状态</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript">private <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> test2() throws InterruptedException &#123;<br> Thread t2 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> Thread thread = Thread.currentThread();</span></span><br><span class="hljs-params"><span class="hljs-function"> boolean interrupted = thread.isInterrupted();</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">if</span>(interrupted) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">break</span>;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t2&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">0.5</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t2</span>.<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">37</span>.<span class="hljs-number">964</span><span class="hljs-meta"> [t2] c.TestInterrupt - 打断状态: true </span><br></code></pre></td></tr></table></figure><h3 id="两阶段终止模式"><a href="#两阶段终止模式" class="headerlink" title="两阶段终止模式"></a>两阶段终止模式</h3><p>Two Phase Termination</p><p>在一个线程T1中如何‘优雅“终止线程T2？这里的”优雅“指的是给T2一个料理后事的机会</p><p>比如释放资源，避免不释放资源的情况</p><p><img src="/../JUC_pic/5.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws InterruptedException</span> &#123;<br>        TwoPhaseTermination tpt = <span class="hljs-keyword">new</span> TwoPhaseTermination();<br>        tpt.start();<br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        tpt.stop();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">TwoPhaseTermination</span> &#123;<br>    <span class="hljs-keyword">private</span> Thread monitor;<br>    <span class="hljs-comment">// 启动监控线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span>()</span> &#123;<br>        monitor = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            @Override<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    Thread thread = Thread.currentThread();<br>                    <span class="hljs-keyword">if</span> (thread.isInterrupted()) &#123;<span class="hljs-comment">//通过线程自带的是否被中断过标签</span><br>                        <span class="hljs-comment">/*</span><br><span class="hljs-comment">                         *被打断后的操作，业务处理在这里处理</span><br><span class="hljs-comment">                        */</span><br>                        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;后置处理&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">// 睡眠</span><br>                        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;执行监控记录&quot;</span>);<span class="hljs-comment">// 在此被打断不会异常</span><br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<span class="hljs-comment">// 在睡眠期间被打断，进入异常处理的逻辑</span><br>                        e.printStackTrace();<br>                        <span class="hljs-comment">// 重新设置打断标记，打断 sleep 会清除打断状态</span><br>                        thread.interrupt();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        monitor.start();<br>    &#125;<br>    <span class="hljs-comment">// 停止监控线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span>()</span> &#123;<br>        monitor.interrupt();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="park"><a href="#park" class="headerlink" title="park"></a>park</h3><p>使用park，线程会在该处停止，可以用interrupt方法打断使其继续运行，但是interrupt会使打断标记为true，park接下来会失效，不会阻塞，isInterruped方法不会清除打断标记，打断标记依然为ture，park依然失效，此时使用Interruped方法，会清除打断标记，此时打断标记为false，park又可以生效了，继续阻塞。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript">private <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> test3() throws InterruptedException &#123;<br> Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;park...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> LockSupport.park();</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;打断状态：&#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">0.5</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">21</span>:<span class="hljs-number">11</span>:<span class="hljs-number">52.795</span> <span class="hljs-selector-attr">[t1]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - park... <br><span class="hljs-number">21</span>:<span class="hljs-number">11</span>:<span class="hljs-number">53.295</span> <span class="hljs-selector-attr">[t1]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - unpark... <br><span class="hljs-number">21</span>:<span class="hljs-number">11</span>:<span class="hljs-number">53.295</span> <span class="hljs-selector-attr">[t1]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 打断状态：true<br></code></pre></td></tr></table></figure><p>打断标记为真时，park会失效</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript">private <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> test4() &#123;<br> Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;park...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> LockSupport.park();</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;打断状态：&#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">21</span>:<span class="hljs-number">13</span>:<span class="hljs-number">48.783</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - park... <br><span class="hljs-number">21</span>:<span class="hljs-number">13</span>:<span class="hljs-number">49.809</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 打断状态：true <br><span class="hljs-number">21</span>:<span class="hljs-number">13</span>:<span class="hljs-number">49.812</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - park... <br><span class="hljs-number">21</span>:<span class="hljs-number">13</span>:<span class="hljs-number">49.813</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 打断状态：true <br><span class="hljs-number">21</span>:<span class="hljs-number">13</span>:<span class="hljs-number">49.813</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - park... <br><span class="hljs-number">21</span>:<span class="hljs-number">13</span>:<span class="hljs-number">49.813</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 打断状态：true <br><span class="hljs-number">21</span>:<span class="hljs-number">13</span>:<span class="hljs-number">49.813</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - park... <br><span class="hljs-number">21</span>:<span class="hljs-number">13</span>:<span class="hljs-number">49.813</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 打断状态：true <br><span class="hljs-number">21</span>:<span class="hljs-number">13</span>:<span class="hljs-number">49.813</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - park... <br><span class="hljs-number">21</span>:<span class="hljs-number">13</span>:<span class="hljs-number">49.813</span> <span class="hljs-selector-attr">[Thread-0]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 打断状态：true <br><br></code></pre></td></tr></table></figure><p>提示:</p><p>可以使用 Thread.interrupted() 清除打断状态</p><h3 id="wait-x2F-notify用例"><a href="#wait-x2F-notify用例" class="headerlink" title="wait&#x2F;notify用例"></a>wait&#x2F;notify用例</h3><p>让我们先通过一个示例解析</p><p>wait()方法可以使线程进入等待状态，并且会释放synchronized锁,而notify()可以使等待的状态唤醒。这样的同步机制十分适合生产者、消费者模式：消费者消费某个资源，而生产者生产该资源。当该资源缺失时，消费者调用wait()方法进行自我阻塞，等待生产者的生产；生产者生产完毕后调用notify&#x2F;notifyAll()唤醒消费者进行消费。</p><p>以下是代码示例，其中flag标志表示资源的有无。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ThreadTest &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();  <span class="hljs-comment">//对象锁</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        Thread consume = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Consume(), <span class="hljs-string">&quot;Consume&quot;</span>);<br>        Thread produce = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Produce(), <span class="hljs-string">&quot;Produce&quot;</span>);<br>        consume.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        produce.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            produce.<span class="hljs-keyword">join</span>();<br>            consume.<span class="hljs-keyword">join</span>();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 生产者线程</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> Produce <span class="hljs-keyword">implements</span> Runnable &#123;<br><br>        @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() &#123;<br>            <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>                System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;进入生产者线程&quot;</span>);<br>                System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;生产&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">2000</span>);  <span class="hljs-comment">//模拟生产过程</span><br>                    flag = <span class="hljs-keyword">true</span>;<br>                    obj.notify();  <span class="hljs-comment">//通知消费者</span><br>                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">//模拟其他耗时操作</span><br>                    System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;退出生产者线程&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//消费者线程</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> Consume <span class="hljs-keyword">implements</span> Runnable &#123;<br><br>        @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() &#123;<br>            <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>                System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;进入消费者线程&quot;</span>);<br>                System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;wait flag 1:&quot;</span> + flag);<br>                <span class="hljs-keyword">while</span> (!flag) &#123;  <span class="hljs-comment">//判断条件是否满足，若不满足则等待</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;还没生产，进入等待&quot;</span>);<br>                        obj.wait();<br>                        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;结束等待&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;wait flag 2:&quot;</span> + flag);<br>                System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;消费&quot;</span>);<br>                System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;退出消费者线程&quot;</span>);<br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">进入消费者线程<br><br><span class="hljs-built_in">wait</span> flag 1:<span class="hljs-literal">false</span><br><br>还没生产，进入等待<br><br>进入生产者线程<br><br>生产<br><br>退出生产者线程<br><br>结束等待<br><br><span class="hljs-built_in">wait</span> flag 2:<span class="hljs-literal">true</span><br><br>消费<br><br>退出消费者线程<br></code></pre></td></tr></table></figure><p>理解了输出结果的顺序，也就明白了wait&#x2F;notify的基本用法。有以下几点需要知道：</p><ol><li>在示例中没有体现但很重要的是，<strong>wait&#x2F;notify方法的调用必须处在该对象的锁（Monitor）中，也即，在调用这些方法时首先需要获得该对象的锁。</strong>否则会抛出IllegalMonitorStateException异常。</li><li>从输出结果来看，在生产者调用notify()后，消费者并没有立即被唤醒，而是等到生产者退出同步块后才唤醒执行。（这点其实也好理解，synchronized同步方法（块）同一时刻只允许一个线程在里面，生产者不退出，消费者也进不去）</li><li>注意，消费者被唤醒后是从wait()方法（被阻塞的地方）后面执行，而不是重新从同步块开始。</li></ol><p>这一节我们探讨wait&#x2F;notify与线程状态之间的关系。深入了解线程的生命周期。</p><p>由前面线程的状态转化图可知，当调用wait()方法后，线程会进入WAITING(等待状态)，后续被notify()后，并没有立即被执行，而是进入等待获取锁的阻塞队列。</p><p><img src="/../JUC_pic/39.png"></p><p>对于每个对象来说，都有自己的等待队列和阻塞队列。以前面的生产者、消费者为例，我们拿obj对象作为对象锁，配合图示。内部流程如下</p><ol><li>当线程A（消费者）调用wait()方法后，线程A让出锁，自己进入等待状态，同时加入锁对象的等待队列。</li><li>线程B（生产者）获取锁后，调用notify方法通知锁对象的等待队列，使得线程A从等待队列进入阻塞队列。</li><li>线程A进入阻塞队列后，直至线程B释放锁后，线程A竞争得到锁继续从wait()方法后执行。</li></ol><h2 id="主线程和守护线程"><a href="#主线程和守护线程" class="headerlink" title="主线程和守护线程"></a>主线程和守护线程</h2><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守 护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript">log.debug(<span class="hljs-string">&quot;开始运行...&quot;</span>);<br>Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;开始运行...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> sleep(<span class="hljs-number">2</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;运行结束...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;, <span class="hljs-string">&quot;daemon&quot;</span>)</span>;</span><br><span class="hljs-function">// 设置该线程为守护线程</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">setDaemon</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;运行结束...&quot;</span>)</span>;</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">08</span>:<span class="hljs-number">26</span>:<span class="hljs-number">38.123</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.TestDaemon</span> - 开始运行... <br><span class="hljs-number">08</span>:<span class="hljs-number">26</span>:<span class="hljs-number">38.213</span> <span class="hljs-selector-attr">[daemon]</span> c<span class="hljs-selector-class">.TestDaemon</span> - 开始运行... <br><span class="hljs-number">08</span>:<span class="hljs-number">26</span>:<span class="hljs-number">39.215</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.TestDaemon</span> - 运行结束... <br></code></pre></td></tr></table></figure><p>注意 </p><ul><li>垃圾回收器线程就是一种守护线程 </li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求</li></ul><h2 id="线程的五种状态"><a href="#线程的五种状态" class="headerlink" title="线程的五种状态"></a>线程的五种状态</h2><p>这里的五种状态是从<strong>操作系统</strong>层面描述的</p><p><img src="/../JUC_pic/6.png"></p><ul><li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联 </li><li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行 </li><li>【运行状态】指获取了 CPU 时间片运行中的状态 当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换 </li><li>【阻塞状态】 如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】 <ul><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑 调度它们</li></ul></li><li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h2 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h2><p>这里从<strong>Java API</strong>层面描述的</p><p>根据Thread.State，分为六种状态</p><p><img src="/../JUC_pic/7.png"></p><p><img src="/../JUC_pic/38.png"></p><ul><li><table><thead><tr><th>状态名称</th><th>说明</th></tr></thead><tbody><tr><td>NEW</td><td>初始状态，线程被构建，但未调用start()方法</td></tr><tr><td>RUNNABLE</td><td>运行状态，调用start()方法后。在java线程中，将操作系统线程的就绪和运行统称运行状态</td></tr><tr><td>BLOCKED</td><td>阻塞状态，线程等待进入synchronized代码块或方法中，等待获取锁</td></tr><tr><td>WAITING</td><td>等待状态，线程可调用wait、join等操作使自己陷入等待状态，并等待其他线程做出特定操作（如notify或中断）</td></tr><tr><td>TIMED_WAITING</td><td>超时等待，线程调用sleep(timeout)、wait(timeout)等操作进入超时等待状态，超时后自行返回</td></tr><tr><td>TERMINATED</td><td>终止状态，线程运行结束</td></tr></tbody></table></li></ul><h2 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h2><p>线程安全问题Java体现</p><p>两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">static</span> int counter = <span class="hljs-number">0</span>;<br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br> Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> counter++;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">Thread</span> <span class="hljs-title">t2</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> counter--;</span></span><br><span class="hljs-params"><span class="hljs-function">  &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t2&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t2</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,counter)</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>问题分析</p><p>以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作，要彻底理 解，必须从字节码来进行分析</p><p>例如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">getstatic i <span class="hljs-regexp">//</span> 获取静态变量i的值<br>iconst_1 <span class="hljs-regexp">//</span> 准备常量<span class="hljs-number">1</span><br>iadd <span class="hljs-regexp">//</span> 自增<br>putstatic i <span class="hljs-regexp">//</span> 将修改后的值存入静态变量i<br></code></pre></td></tr></table></figure><p>而对应 i– 也是类似：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">getstatic i <span class="hljs-regexp">//</span> 获取静态变量i的值<br>iconst_1 <span class="hljs-regexp">//</span> 准备常量<span class="hljs-number">1</span><br>isub <span class="hljs-regexp">//</span> 自减<br>putstatic i <span class="hljs-regexp">//</span> 将修改后的值存入静态变量i<br><br></code></pre></td></tr></table></figure><p><img src="/../JUC_pic/8.png"></p><p><img src="/../JUC_pic/9.png"></p><h3 id="临界区-Critical-Section"><a href="#临界区-Critical-Section" class="headerlink" title="临界区 Critical Section"></a>临界区 Critical Section</h3><ul><li>一个程序运行多个线程本身是没有问题的 </li><li>问题出在多个线程访问<strong>共享资源</strong> <ul><li>多个线程读<strong>共享资源</strong>其实也没有问题 </li><li>在多个线程对<strong>共享资源</strong>读写操作时发生指令交错，就会出现问题</li></ul></li><li>一段代码块内如果存在对<strong>共享资源</strong>的多线程读写操作，称这段代码块为<strong>临界区</strong></li></ul><p>例如，下面代码中的临界区</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> counter = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span>() </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区</span></span><br>&#123; <br> counter++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span>() </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区</span></span><br>&#123; <br> counter--;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>解决办法一：加synchronized锁对临界区进行保护</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">static</span> final <span class="hljs-built_in">Object</span> lock =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>    <span class="hljs-keyword">static</span> int counter = <span class="hljs-number">0</span>;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    synchronized (lock)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                        counter++;</span></span><br><span class="hljs-params"><span class="hljs-function">                    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">Thread</span> <span class="hljs-title">t2</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    synchronized (lock)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                        counter--;</span></span><br><span class="hljs-params"><span class="hljs-function">                    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;, <span class="hljs-string">&quot;t2&quot;</span>)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">t1</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">t2</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,counter)</span>;</span><br><span class="hljs-function">    &#125;</span><br></code></pre></td></tr></table></figure><p>你可以做这样的类比：</p><ul><li>synchronized(对象) 中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人 进行计算，线程 t1，t2 想象成两个人</li><li>当线程 t1 执行到 synchronized(room) 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行 count++ 代码</li><li>这时候如果 t2 也运行到了 synchronized(room) 时，它发现门被锁住了，只能在门外等待，发生了上下文切 换，阻塞住了</li><li>这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去哦）， 这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得时间片时才 能开门进入</li><li>当 t1 执行完 synchronized{} 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥 匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 count– 代码</li></ul><p><strong>synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换 所打断。</strong>确保了一个操作的原子性。</p><h3 id="方法上的-synchronized"><a href="#方法上的-synchronized" class="headerlink" title="方法上的 synchronized"></a>方法上的 synchronized</h3><p>一：加在普通方法上</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br> <span class="hljs-keyword">public</span> synchronized <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br> <br> &#125;<br>&#125;<br>等价于<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span></span>) &#123;<br> <br> &#125;<br> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>相当于锁住this对象</p><p>二：加在静态方法上</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br> <span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br> <br> &#125;<br>&#125;<br>等价于<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-title function_">synchronized</span>(<span class="hljs-params">Test.<span class="hljs-keyword">class</span></span>) &#123;<br> <br> &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>加在静态方法上相当于锁住类对象。</p><h2 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h2><h3 id="成员变量和静态变量是否线程安全？"><a href="#成员变量和静态变量是否线程安全？" class="headerlink" title="成员变量和静态变量是否线程安全？"></a>成员变量和静态变量是否线程安全？</h3><ul><li>如果它们没有共享，则线程安全</li><li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><h3 id="局部变量是否线程安全"><a href="#局部变量是否线程安全" class="headerlink" title="局部变量是否线程安全"></a>局部变量是否线程安全</h3><ul><li>局部变量是线程安全的</li><li>但局部变量引用的对象未必<ul><li>如果该对象没有逃离方法的作用访问，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul><h3 id="局部变量线程安全分析"><a href="#局部变量线程安全分析" class="headerlink" title="局部变量线程安全分析"></a>局部变量线程安全分析</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">这里的<span class="hljs-keyword">static</span>是加在方法上，test1()是一个静态方法，i还是局部变量<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span>()</span> &#123;<br> <span class="hljs-built_in">int</span> i = <span class="hljs-number">10</span>;<br> i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">public</span> static void test1();<br> <span class="hljs-attribute">descriptor</span>: ()V<br> <span class="hljs-attribute">flags</span>: ACC_PUBLIC, ACC_STATIC<br> <span class="hljs-attribute">Code</span>:<br> <span class="hljs-attribute">stack</span>=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">0</span><br> <span class="hljs-attribute">0</span>: bipush <span class="hljs-number">10</span><br> <span class="hljs-attribute">2</span>: istore_0<br> <span class="hljs-attribute">3</span>: iinc <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br> <span class="hljs-attribute">6</span>: return<br> <span class="hljs-attribute">LineNumberTable</span>:<br> <span class="hljs-attribute">line</span> <span class="hljs-number">10</span>: <span class="hljs-number">0</span><br> <span class="hljs-attribute">line</span> <span class="hljs-number">11</span>: <span class="hljs-number">3</span><br> <span class="hljs-attribute">line</span> <span class="hljs-number">12</span>: <span class="hljs-number">6</span><br> <span class="hljs-attribute">LocalVariableTable</span>:<br> <span class="hljs-attribute">Start</span> Length Slot Name Signature<br> <span class="hljs-attribute">3</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> i I<br></code></pre></td></tr></table></figure><p><img src="/../JUC_pic/12.png"></p><h3 id="局部变量的引用"><a href="#局部变量的引用" class="headerlink" title="局部变量的引用"></a>局部变量的引用</h3><p>在类里，方法外的变量的成员变量。方法里的叫局部变量。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadUnsafe</span> &#123;<br><span class="hljs-comment">//这里的list是成员变量</span><br> ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> loopNumber</span>)</span> &#123;<br> <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br> <span class="hljs-comment">// &#123; 临界区, 会产生竞态条件</span><br> method2();<br> method3();<br>  <span class="hljs-comment">// &#125; 临界区</span><br> &#125;<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span>()</span> &#123;<br> list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;1&quot;</span>);<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span>()</span> &#123;<br> list.<span class="hljs-keyword">remove</span>(<span class="hljs-number">0</span>);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> THREAD_NUMBER = <span class="hljs-number">2</span>;<br><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> LOOP_NUMBER = <span class="hljs-number">200</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br> ThreadUnsafe test = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ThreadUnsafe</span>();<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;<br> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(() -&gt; &#123;<br> test.<span class="hljs-built_in">method1</span>(LOOP_NUMBER);<br> &#125;, <span class="hljs-string">&quot;Thread&quot;</span> + i).<span class="hljs-built_in">start</span>();<br> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中一种情况是，如果线程2 还未 add，线程1 remove 就会报错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;Thread1&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IndexOutOfBoundsException</span>: Index: <span class="hljs-number">0</span>, Size: <span class="hljs-number">0</span> <br> at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.rangeCheck</span>(ArrayList<span class="hljs-selector-class">.java</span>:<span class="hljs-number">657</span>) <br> at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.ArrayList</span><span class="hljs-selector-class">.remove</span>(ArrayList<span class="hljs-selector-class">.java</span>:<span class="hljs-number">496</span>) <br> at cn<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.n6</span><span class="hljs-selector-class">.ThreadUnsafe</span><span class="hljs-selector-class">.method3</span>(TestThreadSafe<span class="hljs-selector-class">.java</span>:<span class="hljs-number">35</span>) <br> at cn<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.n6</span><span class="hljs-selector-class">.ThreadUnsafe</span><span class="hljs-selector-class">.method1</span>(TestThreadSafe<span class="hljs-selector-class">.java</span>:<span class="hljs-number">26</span>) <br> at cn<span class="hljs-selector-class">.itcast</span><span class="hljs-selector-class">.n6</span><span class="hljs-selector-class">.TestThreadSafe</span>.lambda<span class="hljs-variable">$main</span>$<span class="hljs-number">0</span>(TestThreadSafe<span class="hljs-selector-class">.java</span>:<span class="hljs-number">14</span>) <br> at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.run</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">748</span>) <br></code></pre></td></tr></table></figure><p>分析：</p><ul><li>无论哪个线程中的 method2 引用的都是同一个对象中的 list 成员变量 </li><li>method3 与 method2 分析相同</li></ul><p><img src="/../JUC_pic/13.png"></p><p>解决办法：将list修改为局部变量</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafe</span> &#123;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> </span>&#123;<br> <span class="hljs-comment">//这里的list就是局部变量</span><br> ArrayList&lt;<span class="hljs-type">String</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br> <span class="hljs-built_in">method2</span>(list);<br> <span class="hljs-built_in">method3</span>(list);<br> &#125;<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(ArrayList&lt;<span class="hljs-type">String</span>&gt; list)</span> </span>&#123;<br> list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;1&quot;</span>);<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(ArrayList&lt;<span class="hljs-type">String</span>&gt; list)</span> </span>&#123;<br> list.<span class="hljs-built_in">remove</span>(<span class="hljs-number">0</span>);<br> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>分析：</p><ul><li>list 是局部变量，每个线程调用时会创建其不同实例，没有共享 </li><li>而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象 </li><li>method3 的参数分析与 method2 相同</li></ul><p><img src="/../JUC_pic/14.png"></p><p>方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 public 会不会代理线程安全问题？</p><ul><li>情况1：有其它线程调用 method2 和 method3</li></ul><p>不会，因为method2 和 method3传进来的参数list只能是线程自己的。</p><ul><li>情况2：在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafe</span> &#123;<br> <span class="hljs-keyword">public</span> final <span class="hljs-built_in">void</span> <span class="hljs-title function_">method1</span>(<span class="hljs-params">int loopNumber</span>) &#123;<br> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-title class_">String</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br> <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br> <span class="hljs-title function_">method2</span>(list);<br> <span class="hljs-title function_">method3</span>(list);<br> &#125;<br> &#125;<br> <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method2</span>(<span class="hljs-params">ArrayList&lt;<span class="hljs-built_in">String</span>&gt; list</span>) &#123;<br> list.<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;1&quot;</span>);<br> &#125;<br> <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method3</span>(<span class="hljs-params">ArrayList&lt;<span class="hljs-built_in">String</span>&gt; list</span>) &#123;<br> list.<span class="hljs-title function_">remove</span>(<span class="hljs-number">0</span>);<br> &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafeSubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ThreadSafe</span>&#123;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method3</span>(<span class="hljs-params">ArrayList&lt;<span class="hljs-built_in">String</span>&gt; list</span>) &#123;<br> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br> list.<span class="hljs-title function_">remove</span>(<span class="hljs-number">0</span>);<br> &#125;).<span class="hljs-title function_">start</span>();<br> &#125;<br>&#125;<br>被子类继承的话，那么子类可以另外开启一个线程进行相应操作，可能会出现线程安全问题。所以做好开闭原则中的闭。<br></code></pre></td></tr></table></figure><p><strong>从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】</strong>加上private 或 final 不然子类继承</p><h2 id="常见的线程安全类"><a href="#常见的线程安全类" class="headerlink" title="常见的线程安全类"></a>常见的线程安全类</h2><ul><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable(线程安全的Map实现)</li><li>java.util.concurrent 包下的类</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs livescript">Hashtable table = <span class="hljs-keyword">new</span> Hashtable();<br><br><span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> table.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> table.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">打开<span class="hljs-title">Put</span>源码</span><br><span class="hljs-function"><span class="hljs-title">public</span> <span class="hljs-title">synchronized</span> <span class="hljs-title">V</span> <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> &#123;</span><br><span class="hljs-function">        // <span class="hljs-title">Make</span> <span class="hljs-title">sure</span> <span class="hljs-title">the</span> <span class="hljs-title">value</span> <span class="hljs-title">is</span> <span class="hljs-title">not</span> <span class="hljs-title">null</span></span><br><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-params">(value == <span class="hljs-literal">null</span>)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">throw</span> <span class="hljs-title">new</span> <span class="hljs-title">NullPointerException</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">可见<span class="hljs-title">synchronized</span></span><br></code></pre></td></tr></table></figure><p>ctrl+N查找类。</p><p>ctrl+F12查找类中的方法。</p><ul><li>它们的每个方法是原子的 </li><li>但注意它们多个方法的组合不是原子的，</li></ul><h3 id="线程安全类方法的组合"><a href="#线程安全类方法的组合" class="headerlink" title="线程安全类方法的组合"></a>线程安全类方法的组合</h3><p>分析下面代码是否线程安全？</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Hashtable table = <span class="hljs-built_in">new</span> Hashtable();<br>// 线程<span class="hljs-number">1</span>，线程<span class="hljs-number">2</span><br><span class="hljs-keyword">if</span>( <span class="hljs-keyword">table</span>.<span class="hljs-keyword">get</span>(&quot;key&quot;) == <span class="hljs-keyword">null</span>) &#123;<br> <span class="hljs-keyword">table</span>.put(&quot;key&quot;, <span class="hljs-keyword">value</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../JUC_pic/15.png"></p><h3 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h3><p>String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的 有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安 全的呢？</p><p>比如substring(),其实没有修改，而是创建了一个新的String对象</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">String s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;456&quot;</span><span class="hljs-comment">;</span><br>编译可以通过，看上去好像改变了字符串的值，实际上是创建了新的对象，可以使用hashcode()得出结论。<br></code></pre></td></tr></table></figure><h3 id="不可变性的好处"><a href="#不可变性的好处" class="headerlink" title="不可变性的好处"></a>不可变性的好处</h3><p>String类的不可变性带来的好处总结主要有两点：</p><ul><li><p>因为String类的不可变性，才能使得JVM可以实现字符串常量池；字符串常量池可以在程序运行时节约很多内存空间，因为不同的字符串变量指向相同的字面量时，都是指向字符串常量池中的同一个对象。这样一方面能够节约内存，另一方面也提升了性能。</p></li><li><p>因为String类的不可变性，从而保证了字符串对象在多线程环境下是线程安全的。如果String类是可变的，那么会引起很严重的安全问题。我们在很多情况下都是直接通过字符串传递数据，比如数据库的用户名密码、网络编程中的ip和端口，因为字符串是不可变的，所以它的值不能被修改，如果字符串是可变的，那么可以通过改变引用地址指向的值去修改字符串的值，从而导致安全漏洞。</p></li><li><p>同时也非常适合作为HashMap的key，因为HashMap的工作原理是hashcode，如果String作为key可变，那么hashcode会发送改变，那么就找不到之前存储的数据了。</p></li></ul><h2 id="Monitor概念"><a href="#Monitor概念" class="headerlink" title="Monitor概念"></a>Monitor概念</h2><p>一个对象主要由两部分组成：Java对象头+成员变量</p><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>以32位虚拟机为例：</p><p><strong>普通对象</strong></p><p><img src="/../JUC_pic/16.png"></p><p>一个类是什么对象靠的就是Klass Word(是一个指针)，通过Klass Word找到对象的类型。</p><p><strong>数组对象</strong></p><p><img src="/../JUC_pic/17.png"></p><p><strong>其中Mark Word结构为</strong></p><p><img src="/../JUC_pic/18.png"></p><p>其中先看Normal,hashcode懂得都懂，age是JVM中新生代到老年代晋升的那个年龄，biased_lock是偏向锁(后面学习)，01是加锁状态。</p><p><strong>64位虚拟机</strong></p><p><img src="/../JUC_pic/19.png"></p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="synchronized-底层原理-Monitor"><a href="#synchronized-底层原理-Monitor" class="headerlink" title="synchronized 底层原理(Monitor)"></a>synchronized 底层原理(Monitor)</h3><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong></p><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针</p><p><img src="/../JUC_pic/20.png"></p><ul><li>刚开始 Monitor 中 Owner 为 null</li><li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一 个 Owner</li><li>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 EntryList BLOCKED</li><li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的</li><li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 wait-notify 时会分析</li></ul><h3 id="synchronized-底层原理字节码分析"><a href="#synchronized-底层原理字节码分析" class="headerlink" title="synchronized 底层原理字节码分析"></a>synchronized 底层原理字节码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <span class="hljs-keyword">synchronized</span> (lock) &#123;<br> counter++;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs awk">public static void main(java.lang.String[]);<br> descriptor: ([Ljava<span class="hljs-regexp">/lang/</span>String;)V<br> flags: ACC_PUBLIC, ACC_STATIC<br>  Code:<br> stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br> <span class="hljs-number">0</span>: getstatic <span class="hljs-comment">#2 // &lt;- lock引用 （synchronized开始）</span><br> <span class="hljs-number">3</span>: dup<br> <span class="hljs-number">4</span>: astore_1 <span class="hljs-regexp">//</span> lock引用 -&gt; slot <span class="hljs-number">1</span><br> <span class="hljs-number">5</span>: monitorenter <span class="hljs-regexp">//</span> 将 lock对象 MarkWord 置为 Monitor 指针<br> <span class="hljs-number">6</span>: getstatic <span class="hljs-comment">#3 // &lt;- i</span><br> <span class="hljs-number">9</span>: iconst_1 <span class="hljs-regexp">//</span> 准备常数 <span class="hljs-number">1</span><br> <span class="hljs-number">10</span>: iadd <span class="hljs-regexp">//</span> +<span class="hljs-number">1</span><br> <span class="hljs-number">11</span>: putstatic <span class="hljs-comment">#3 // -&gt; i</span><br> <span class="hljs-number">14</span>: aload_1 <span class="hljs-regexp">//</span> &lt;- lock引用<br> <span class="hljs-number">15</span>: monitorexit <span class="hljs-regexp">//</span> 将 lock对象 MarkWord 重置, 唤醒 EntryList<br> <span class="hljs-number">16</span>: goto <span class="hljs-number">24</span><br> <span class="hljs-number">19</span>: astore_2 <span class="hljs-regexp">//</span> e -&gt; slot <span class="hljs-number">2</span> <br> <span class="hljs-number">20</span>: aload_1 <span class="hljs-regexp">//</span> &lt;- lock引用<br> <span class="hljs-number">21</span>: monitorexit <span class="hljs-regexp">//</span> 将 lock对象 MarkWord 重置, 唤醒 EntryList<br> <span class="hljs-number">22</span>: aload_2 <span class="hljs-regexp">//</span> &lt;- slot <span class="hljs-number">2</span> (e)<br> <span class="hljs-number">23</span>: athrow <span class="hljs-regexp">//</span> throw e<br> <span class="hljs-number">24</span>: return<br> Exception table:<br> from to target type<br> <span class="hljs-number">6</span>    <span class="hljs-number">16</span> <span class="hljs-number">19</span>     any<br> <span class="hljs-number">19</span>   <span class="hljs-number">22</span> <span class="hljs-number">19</span>     any<br> LineNumberTable:<br> line <span class="hljs-number">8</span>: <span class="hljs-number">0</span><br> line <span class="hljs-number">9</span>: <span class="hljs-number">6</span><br> line <span class="hljs-number">10</span>: <span class="hljs-number">14</span><br> line <span class="hljs-number">11</span>: <span class="hljs-number">24</span><br> LocalVariableTable:<br> Start Length Slot Name Signature<br>  <span class="hljs-number">0</span>     <span class="hljs-number">25</span>      <span class="hljs-number">0</span>   args [Ljava<span class="hljs-regexp">/lang/</span>String;<br> StackMapTable: number_of_entries = <span class="hljs-number">2</span><br> frame_type = <span class="hljs-number">255</span> <span class="hljs-regexp">/* full_frame */</span><br> offset_delta = <span class="hljs-number">19</span><br> locals = [ class <span class="hljs-string">&quot;[Ljava/lang/String;&quot;</span>, class java<span class="hljs-regexp">/lang/</span>Object ]<br> stack = [ class java<span class="hljs-regexp">/lang/</span>Throwable ]<br> frame_type = <span class="hljs-number">250</span> <span class="hljs-regexp">/* chop */</span><br> offset_delta = <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p><p>不过两者的本质都是对对象监视器 monitor 的获取。(Monitor是由操作系统提供的)。</p><h3 id="synchronized升级之小故事"><a href="#synchronized升级之小故事" class="headerlink" title="synchronized升级之小故事"></a>synchronized升级之小故事</h3><p>故事角色 </p><ul><li><p>老王 - JVM </p></li><li><p>小南 - 线程 </p></li><li><p>小女 - 线程 </p></li><li><p>房间 - 对象 </p></li><li><p>房间门上 - 防盗锁 - Monitor </p></li><li><p>房间门上 - 小南书包 - 轻量级锁 </p></li><li><p>房间门上 - 刻上小南大名 - 偏向锁 </p></li><li><p>批量重刻名 - 一个类的偏向锁撤销到达 20 阈值 </p></li><li><p>不能刻名字 - 批量撤销该类对象的偏向锁，设置该类不可偏向 </p><p>小南要使用房间保证计算不被其它人干扰（原子性），最初，他用的是防盗锁，当上下文切换时，锁住门。这样， 即使他离开了，别人也进不了门，他的工作就是安全的。</p><p>但是，很多情况下没人跟他来竞争房间的使用权。小女是要用房间，但使用的时间上是错开的，小南白天用，小女 晚上用。每次上锁太麻烦了，有没有更简单的办法呢？ </p><p>小南和小女商量了一下，约定不锁门了，而是谁用房间，谁把自己的书包挂在门口，但他们的书包样式都一样，因 此每次进门前得翻翻书包(查看对象头的线程ID)，看课本是谁的，如果是自己的，那么就可以进门，这样省的上锁解锁了。万一书包不是 自己的，那么就在门外等，并通知对方下次用锁门的方式(因为有了竞争，所以升级为重量级锁)。 </p><p>后来，小女回老家了，很长一段时间都不会用这个房间。小南每次还是挂书包，翻书包，虽然比锁门省事了，但仍 然觉得麻烦。 </p><p>于是，小南干脆在门上刻上了自己的名字：【小南专属房间，其它人勿用】，下次来用房间时，只要名字还在，那 么说明没人打扰，还是可以安全地使用房间。如果这期间有其它人要用这个房间，那么由使用者将小南刻的名字擦 掉，升级为挂书包的方式。</p><p> 同学们都放假回老家了，小南就膨胀了，在 20 个房间刻上了自己的名字，想进哪个进哪个。后来他自己放假回老 家了，这时小女回来了（她也要用这些房间），结果就是得一个个地擦掉小南刻的名字，升级为挂书包的方式。老 王觉得这成本有点高，提出了一种批量重刻名的方法，他让小女不用挂书包了，可以直接在门上刻上自己的名字 </p><p>后来，刻名的现象越来越频繁，老王受不了了：算了，这些房间都不能刻名了，只能挂书包</p></li></ul><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以 使用轻量级锁来优化。 轻量级锁对使用者是透明的，即语法仍然是 synchronized </p><p>假设有两个方法同步块，利用同一个对象加锁</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">static</span> final <span class="hljs-title class_">Object</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method1</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;<br> <span class="hljs-comment">// 同步块 A</span><br> <span class="hljs-title function_">method2</span>();<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method2</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;<br> <span class="hljs-comment">// 同步块 B</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建锁记录（Lock Record）对象，每个线程都的每个栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word</li></ul><p><img src="/../JUC_pic/21.png"></p><ul><li>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将对象的 Mark Word 的值存 入锁记录</li></ul><p><img src="/../JUC_pic/22.png"></p><ul><li>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</li></ul><p><img src="/../JUC_pic/23.png"></p><ul><li><p>如果 cas 失败，有两种情况 </p><ul><li><p>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 </p></li><li><p>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</p></li></ul></li></ul><p><img src="/../JUC_pic/24.png"></p><ul><li>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重 入计数减一</li></ul><p><img src="/../JUC_pic/25.png"></p><ul><li>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象 头 <ul><li>成功，则解锁成功 </li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul></li></ul><h3 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有 竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">static</span> <span class="hljs-title class_">Object</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method1</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;<br> <span class="hljs-comment">// 同步块</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li></ul><p><img src="/../JUC_pic/26.png"></p><ul><li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程 <ul><li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址 </li><li>然后自己进入 Monitor 的 EntryList BLOCKED</li></ul></li></ul><p><img src="/../JUC_pic/27.png"></p><ul><li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁 流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li></ul><h3 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h3><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步 块，释放了锁），这时当前线程就可以避免阻塞。(阻塞会发生上下文切换，上下文切换影响性能)。</p><p><strong>自旋重试成功的情况</strong></p><p><img src="/../JUC_pic/28.png"></p><p><strong>自旋重试失败的情况</strong></p><p><img src="/../JUC_pic/29.png"></p><ul><li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 </li><li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会 高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</li><li>Java 7 之后不能控制是否开启自旋功能</li></ul><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS（Compare And Swap） 操作。</p><p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现 这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">static</span> final <span class="hljs-title class_">Object</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">m1</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;<br> <span class="hljs-comment">// 同步块 A</span><br> <span class="hljs-title function_">m2</span>();<br> &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">m2</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;<br> <span class="hljs-comment">// 同步块 B</span><br> <span class="hljs-title function_">m3</span>();<br> &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">m3</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;<br> <span class="hljs-comment">// 同步块 C</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../JUC_pic/30.png"></p><p><img src="/../JUC_pic/36.png"></p><h3 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h3><p>回忆一下对象头格式</p><p><img src="/../JUC_pic/37.png"></p><p>分别是：无锁，偏向锁，轻量级锁，重量级锁，已被GC回收</p><p>一个对象创建时：</p><ul><li>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的 thread、epoch、age 都为 0。</li><li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 - XX:BiasedLockingStartupDelay&#x3D;0 来禁用延迟。(偏向锁的延迟性)</li><li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、 age 都为 0，第一次用到 hashcode 时才会赋值。</li></ul><p>1） 测试偏向锁的延迟特性</p><p>2） 测试偏向锁</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Dog</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>利用 jol 第三方工具来查看对象头信息（注意这里我扩展了 jol 让它输出更为简洁）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// 添加虚拟机参数 -XX:BiasedLockingStartupDelay=<span class="hljs-number">0</span> <br><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) throws IOException &#123;<br> Dog d = <span class="hljs-built_in">new</span> Dog();<br> ClassLayout classLayout = ClassLayout.parseInstance(d);<br> <br> <span class="hljs-built_in">new</span> Thread(() -&gt; &#123;<br> <span class="hljs-keyword">log</span>.<span class="hljs-keyword">debug</span>(&quot;synchronized 前&quot;);<br> <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(classLayout.toPrintableSimple(<span class="hljs-keyword">true</span>));<br> synchronized (d) &#123;<br> <span class="hljs-keyword">log</span>.<span class="hljs-keyword">debug</span>(&quot;synchronized 中&quot;);<br> <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(classLayout.toPrintableSimple(<span class="hljs-keyword">true</span>));<br> &#125;<br> <span class="hljs-keyword">log</span>.<span class="hljs-keyword">debug</span>(&quot;synchronized 后&quot;);<br> <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(classLayout.toPrintableSimple(<span class="hljs-keyword">true</span>));<br> &#125;, &quot;t1&quot;).<span class="hljs-keyword">start</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">11:08:58.117 c.TestBiased [t1] - synchronized 前<br>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000101 <br>11:08:58.121 c.TestBiased [t1] - synchronized 中<br>00000000 00000000 00000000 00000000 00011111 11101011 11010000 00000101 <br>11:08:58.121 c.TestBiased [t1] - synchronized 后<br>00000000 00000000 00000000 00000000 00011111 11101011 11010000 00000101<br></code></pre></td></tr></table></figure><p><strong>注意 处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</strong></p><p>3）测试禁用 </p><p>在上面测试代码运行时在添加 VM 参数 -XX:-UseBiasedLocking 禁用偏向锁</p><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">11</span>:<span class="hljs-number">13</span>:<span class="hljs-number">10.018</span> c.TestBiased [t1] - synchronized 前<br><span class="hljs-symbol">00000000 </span><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br><span class="hljs-number">11</span>:<span class="hljs-number">13</span>:<span class="hljs-number">10.021</span> c.TestBiased [t1] - synchronized 中<br><span class="hljs-symbol">00000000 </span><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">00010100</span> <span class="hljs-number">11110011</span> <span class="hljs-number">10001000</span> <br><span class="hljs-number">11</span>:<span class="hljs-number">13</span>:<span class="hljs-number">10.021</span> c.TestBiased [t1] - synchronized 后<br><span class="hljs-symbol">00000000 </span><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span><br></code></pre></td></tr></table></figure><ol start="4"><li><p>测试 hashCode </p><p>正常状态对象一开始是没有 hashCode 的，第一次调用才生成,注意。调用Hashcode()方法会使偏向锁失效</p><p><img src="/../JUC_pic/37.png"></p></li></ol><p>调用Hashcode()后生成31位hashCode ，这时候没有空间再存储thread(操作系统方面的线程ID)，所以偏向锁失效，但是为什么轻量级锁和重量级锁不失效呢？</p><p><img src="/../JUC_pic/26.png"></p><p><img src="/../JUC_pic/27.png"></p><p>因为对象在使用轻量级锁时把hashcode存储在线程栈帧的Lock Record(所记录)中。</p><p>而对象在使用重量级锁时把hashcode存储在Monitor对象中，释放锁时再还原给对象头中。</p><h3 id="撤销-调用对象-hashCode"><a href="#撤销-调用对象-hashCode" class="headerlink" title="撤销 - 调用对象 hashCode"></a>撤销 - 调用对象 hashCode</h3><p>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被 撤销</p><ul><li>轻量级锁会在锁记录中记录 hashCode</li><li>重量级锁会在 Monitor 中记录 hashCode</li></ul><p>在调用 hashCode 后使用偏向锁，记得去掉 -XX:-UseBiasedLocking</p><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">11</span>:<span class="hljs-number">22</span>:<span class="hljs-number">10.386</span> c.TestBiased [main] - 调用 hashCode:<span class="hljs-number">1778535015</span> <br><span class="hljs-number">11</span>:<span class="hljs-number">22</span>:<span class="hljs-number">10.391</span> c.TestBiased [t1] - synchronized 前<br><span class="hljs-symbol">00000000 </span><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">01101010</span> <span class="hljs-number">00000010</span> <span class="hljs-number">01001010</span> <span class="hljs-number">01100111</span> <span class="hljs-number">00000001</span> <br><span class="hljs-number">11</span>:<span class="hljs-number">22</span>:<span class="hljs-number">10.393</span> c.TestBiased [t1] - synchronized 中<br><span class="hljs-symbol">00000000 </span><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">11000011</span> <span class="hljs-number">11110011</span> <span class="hljs-number">01101000</span> <br><span class="hljs-number">11</span>:<span class="hljs-number">22</span>:<span class="hljs-number">10.393</span> c.TestBiased [t1] - synchronized 后<br><span class="hljs-symbol">00000000 </span><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">01101010</span> <span class="hljs-number">00000010</span> <span class="hljs-number">01001010</span> <span class="hljs-number">01100111</span> <span class="hljs-number">00000001</span><br></code></pre></td></tr></table></figure><h3 id="撤销-其它线程使用对象"><a href="#撤销-其它线程使用对象" class="headerlink" title="撤销 - 其它线程使用对象"></a>撤销 - 其它线程使用对象</h3><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs livescript">private <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> test2() throws InterruptedException &#123;<br> Dog d = <span class="hljs-keyword">new</span> Dog();<br> Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (d) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (TestBiased.<span class="hljs-keyword">class</span>) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> TestBiased.<span class="hljs-keyword">class</span>.notify();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-regexp">// 如果不用 wait/notify 使用 join 必须打开下面的注释</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function"> //</span> 因为：t1 线程不能结束，否则底层线程可能被 jvm 重用作为 t2 线程，底层线程 id 是一样的</span></span><br><span class="hljs-params"><span class="hljs-function"> /*<span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> System.<span class="hljs-keyword">in</span>.read();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;*/</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> </span><br><span class="hljs-function"> <span class="hljs-title">Thread</span> <span class="hljs-title">t2</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (TestBiased.<span class="hljs-keyword">class</span>) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> TestBiased.<span class="hljs-keyword">class</span>.wait();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (d) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t2&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">[t1] - <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">01000001</span> <span class="hljs-number">00010000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">01000001</span> <span class="hljs-number">00010000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">10110101</span> <span class="hljs-number">11110000</span> <span class="hljs-number">01000000</span> <br>[t2] - <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br></code></pre></td></tr></table></figure><h3 id="撤销-调用-wait-x2F-notify"><a href="#撤销-调用-wait-x2F-notify" class="headerlink" title="撤销 - 调用 wait&#x2F;notify"></a>撤销 - 调用 wait&#x2F;notify</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br> Dog d = <span class="hljs-keyword">new</span> Dog();<br> Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (d) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> d.wait();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> </span><br><span class="hljs-function"> <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> Thread.sleep(<span class="hljs-number">6000</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (d) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;notify&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> d.notify();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t2&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">[t1] - <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">10110011</span> <span class="hljs-number">11111000</span> <span class="hljs-number">00000101</span> <br>[t2] - notify <br>[t1] - <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011100</span> <span class="hljs-number">11010100</span> <span class="hljs-number">00001101</span> <span class="hljs-number">11001010</span> <br></code></pre></td></tr></table></figure><p>因为wait&#x2F;notify只有在重量锁(两个线程存在竞争)的情况下才能使用。</p><p><strong>wait&#x2F;notify方法的调用必须处在该对象的锁（Monitor）中，也即，在调用这些方法时首先需要获得该对象的锁。</strong>否则会抛出IllegalMonitorStateException异常。</p><h3 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h3><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象 的 Thread ID</p><p>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至 加锁线程,并且这些对象在synchronized同步代码块之外的状态依然处于偏向T2的状态，而在20次之前这些对象被撤销锁处于不可偏向状态(normal).</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs livescript">private <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> test3() throws InterruptedException &#123;<br> Vector&lt;Dog&gt; <span class="hljs-keyword">list</span> = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br> Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> Dog d = <span class="hljs-keyword">new</span> Dog();</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">list</span>.add(d);</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (d) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (<span class="hljs-keyword">list</span>) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">list</span>.notify();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125; </span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> </span><br><span class="hljs-function"> <span class="hljs-title">Thread</span> <span class="hljs-title">t2</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (<span class="hljs-keyword">list</span>) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">list</span>.wait();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;===============&gt; &quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> Dog d = <span class="hljs-keyword">list</span>.get(i);</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (d) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t2&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs dns">[t1] - <span class="hljs-number">0 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">1 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">2 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">3 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">4 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">5 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">6 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">7 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">8 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">9 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">10 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">11 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">12 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">13 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">14 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">15 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">16 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">17 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">18 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">19 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">20 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">21 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">22 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">23 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">24 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">25 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">26 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">27 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">28 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t1] - <span class="hljs-number">29 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - ===============&gt; <br>[t2] - <span class="hljs-number">0 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">0 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">0 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">1 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">1 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">1 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">2 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">2 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">2 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">3 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">3 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">3 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">4 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">4 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">4 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">5 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">5 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">5 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">6 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">6 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">6 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">7 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">7 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">7 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">8 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">8 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">8 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">9 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">9 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">9 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">10 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">10 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">10 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">11 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">11 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">11 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">12 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">12 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">12 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">13 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">13 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">13 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">14 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">14 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">14 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">15 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">15 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">15 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">16 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">16 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">16 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">17 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">17 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">17 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">18 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">18 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01011000</span> <span class="hljs-number">11110111</span> <span class="hljs-number">00000000</span> <br>[t2] - <span class="hljs-number">18 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <br>[t2] - <span class="hljs-number">19 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">19 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">19 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">20 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">20 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">20 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">21 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">21 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">21 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">22 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">22 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">22 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">23 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">23 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">23 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">24 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">24 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">24 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">25 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">25 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">25 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">26 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">26 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">26 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">27 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">27 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">27 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">28 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">28 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">28 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">29 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11100000</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">29 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br>[t2] - <span class="hljs-number">29 00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11110011</span> <span class="hljs-number">11110001</span> <span class="hljs-number">00000101</span> <br><br></code></pre></td></tr></table></figure><h3 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h3><p>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象 都会变为不可偏向的，新建的对象也是不可偏向的。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">static</span> Thread t1,t2,t3;<br>   private <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> test4() throws InterruptedException &#123;<br> Vector&lt;Dog&gt; <span class="hljs-keyword">list</span> = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br>  int loopNumber = <span class="hljs-number">39</span>;<br> t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> Dog d = <span class="hljs-keyword">new</span> Dog();</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">list</span>.add(d);</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (d) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> LockSupport.unpark(t2);</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">   <span class="hljs-title">t2</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> LockSupport.park();</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;===============&gt; &quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> Dog d = <span class="hljs-keyword">list</span>.get(i);</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (d) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> LockSupport.unpark(t3);</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t2&quot;</span>)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">5. 锁消除</span><br><span class="hljs-function">锁消除</span><br><span class="hljs-function"> <span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    <span class="hljs-title">t3</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> LockSupport.park();</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;===============&gt; &quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> Dog d = <span class="hljs-keyword">list</span>.get(i);</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> synchronized (d) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> &#125;, <span class="hljs-string">&quot;t3&quot;</span>)</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t3</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">t3</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"> <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(ClassLayout.parseInstance(<span class="hljs-keyword">new</span> Dog()).toPrintableSimple(<span class="hljs-literal">true</span>))</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="Wait-notify原理"><a href="#Wait-notify原理" class="headerlink" title="Wait notify原理"></a>Wait notify原理</h2><p><img src="/../JUC_pic/41.png"></p><ul><li><p>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 </p></li><li><p>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 </p></li><li><p>BLOCKED 线程会在 Owner 线程释放锁时唤醒</p></li><li><p>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争</p></li></ul><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul><li>obj.wait() 让进入 object 监视器的线程到 waitSet 等待</li><li>obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒</li><li>obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒</li></ul><p>它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法,比如</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss">new <span class="hljs-built_in">Thread</span>(() -&gt; &#123;<br> synchronized (obj) &#123;<br> log<span class="hljs-selector-class">.debug</span>(&quot;执行....&quot;);<br> try &#123;<br> obj<span class="hljs-selector-class">.wait</span>(); <span class="hljs-comment">// 让线程在obj上一直等待下去</span><br> &#125; catch (InterruptedException e) &#123;<br> e<span class="hljs-selector-class">.printStackTrace</span>();<br> &#125;<br> log<span class="hljs-selector-class">.debug</span>(&quot;其它代码....&quot;);<br> &#125;<br> &#125;)<span class="hljs-selector-class">.start</span>();<br></code></pre></td></tr></table></figure><h3 id="sleep-long-n-和-wait-long-n-的区别"><a href="#sleep-long-n-和-wait-long-n-的区别" class="headerlink" title="sleep(long n) 和 wait(long n) 的区别"></a>sleep(long n) 和 wait(long n) 的区别</h3><ul><li>sleep 是 Thread 方法，而 wait 是 Object 的方法</li><li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要 和 synchronized 一起用</li><li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁</li><li>它们 状态都是 TIMED_WAITING(共同点)</li></ul><h2 id="Park-amp-Unpark"><a href="#Park-amp-Unpark" class="headerlink" title="Park &amp; Unpark"></a>Park &amp; Unpark</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>调用park的线程处于wait状态</p><p>它们是 LockSupport 类中的方法</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 暂停当前线程<br>LockSupport.park(); <br><span class="hljs-regexp">//</span> 恢复某个线程的运行<br>LockSupport.unpark(暂停线程对象)<br></code></pre></td></tr></table></figure><p>先 park 再 unpark</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript">Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;start...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> sleep(<span class="hljs-number">1</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;park...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> LockSupport.park();</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;resume...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;,<span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;unpark...&quot;</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">LockSupport</span>.<span class="hljs-title">unpark</span><span class="hljs-params">(t1)</span>;</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">52.585</span> c<span class="hljs-selector-class">.TestParkUnpark</span> <span class="hljs-selector-attr">[t1]</span> - start... <br><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">53.589</span> c<span class="hljs-selector-class">.TestParkUnpark</span> <span class="hljs-selector-attr">[t1]</span> - park... <br><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">54.583</span> c<span class="hljs-selector-class">.TestParkUnpark</span> <span class="hljs-selector-attr">[main]</span> - unpark... <br><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">54.583</span> c<span class="hljs-selector-class">.TestParkUnpark</span> <span class="hljs-selector-attr">[t1]</span> - resume... <br></code></pre></td></tr></table></figure><p>先 unpark 再 park</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript">Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;start...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> sleep(<span class="hljs-number">2</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;park...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"> LockSupport.park();</span></span><br><span class="hljs-params"><span class="hljs-function"> log.debug(<span class="hljs-string">&quot;resume...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;unpark...&quot;</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">LockSupport</span>.<span class="hljs-title">unpark</span><span class="hljs-params">(t1)</span>;</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">50.765</span> c<span class="hljs-selector-class">.TestParkUnpark</span> <span class="hljs-selector-attr">[t1]</span> - start... <br><span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">51.764</span> c<span class="hljs-selector-class">.TestParkUnpark</span> <span class="hljs-selector-attr">[main]</span> - unpark... <br><span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">52.769</span> c<span class="hljs-selector-class">.TestParkUnpark</span> <span class="hljs-selector-attr">[t1]</span> - park... <br><span class="hljs-number">18</span>:<span class="hljs-number">43</span>:<span class="hljs-number">52.769</span> c<span class="hljs-selector-class">.TestParkUnpark</span> <span class="hljs-selector-attr">[t1]</span> - resume... <br></code></pre></td></tr></table></figure><p>可以看到不管unpark在park之前还是之后都可以成功唤醒park所在线程</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>与 Object 的 wait &amp; notify 相比</p><ul><li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li><li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll  是唤醒所有等待线程，就不那么【精确】</li><li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li></ul><h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2><p><img src="/../JUC_pic/42.png"></p><p>(待详细分析)</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>相对于 synchronized 它具备如下特点</p><ul><li>可打断(synchonized不可打断)，减少死锁发生的 可能性</li><li>可以设置超时时间</li><li>可以设置为公平锁</li><li>支持多个条件变量</li></ul><p>与 synchronized 一样，都支持可重入</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 获取锁<br>reentrantLock.lock();<br>try &#123;<br> <span class="hljs-regexp">//</span> 临界区<br>&#125; finally &#123;<br> <span class="hljs-regexp">//</span> 释放锁<br> reentrantLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁 如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp">@Slf4j<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLockTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;entry main&quot;</span>);<br>            m1();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">lock</span>.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span>()</span>&#123;<br>        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;entry m1&quot;</span>);<br>            m2();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">lock</span>.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span>()</span>&#123;<br>        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;entry m2&quot;</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">lock</span>.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">16</span>:<span class="hljs-number">01</span>:<span class="hljs-number">24.390</span> <span class="hljs-selector-attr">[main]</span> DEBUG lock<span class="hljs-selector-class">.ReentrantLockTest</span> - entry <span class="hljs-selector-tag">main</span><br><span class="hljs-number">16</span>:<span class="hljs-number">01</span>:<span class="hljs-number">24.392</span> <span class="hljs-selector-attr">[main]</span> DEBUG lock<span class="hljs-selector-class">.ReentrantLockTest</span> - entry m1<br><span class="hljs-number">16</span>:<span class="hljs-number">01</span>:<span class="hljs-number">24.392</span> <span class="hljs-selector-attr">[main]</span> DEBUG lock<span class="hljs-selector-class">.ReentrantLockTest</span> - entry m2<br></code></pre></td></tr></table></figure><h3 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-built_in">new</span> ReentrantLock();<br>        Thread t1 = <span class="hljs-built_in">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">log</span>.<span class="hljs-keyword">debug</span>(&quot;启动...&quot;);<br>            try &#123;<br>                //如果没有竞争那么将获得<span class="hljs-keyword">lock</span>对象锁<br>                //如果有竞争就进入阻塞队列,可以被其他线程用interrupt()打断<br>                //主线程已经获取锁了，t1线程阻塞并在阻塞队列等待，主线程执行t1.interrupt()将t1等待打断<br>                <span class="hljs-keyword">lock</span>.lockInterruptibly();<br>            &#125; catch (InterruptedException e) &#123;<br>                e.printStackTrace();<br>                <span class="hljs-keyword">log</span>.<span class="hljs-keyword">debug</span>(&quot;等锁的过程中被打断&quot;);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            try &#123;<br>                <span class="hljs-keyword">log</span>.<span class="hljs-keyword">debug</span>(&quot;获得了锁&quot;);<br>            &#125; finally &#123;<br>                <span class="hljs-keyword">lock</span>.unlock();<br>            &#125;<br>        &#125;,&quot;t1&quot;);<br>        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br>        <span class="hljs-keyword">log</span>.<span class="hljs-keyword">debug</span>(&quot;获得了锁&quot;);<br>        t1.<span class="hljs-keyword">start</span>();<br>        try &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            t1.interrupt();<br>            <span class="hljs-keyword">log</span>.<span class="hljs-keyword">debug</span>(&quot;执行打断&quot;);<br>        &#125; finally &#123;<br>            <span class="hljs-keyword">lock</span>.unlock();<br>        &#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">6</span>:<span class="hljs-number">47</span>:<span class="hljs-number">34.169</span> <span class="hljs-selector-attr">[main]</span> DEBUG lock<span class="hljs-selector-class">.ReentrantLockTest2</span> - 获得了锁<br><span class="hljs-number">16</span>:<span class="hljs-number">47</span>:<span class="hljs-number">34.172</span> <span class="hljs-selector-attr">[Thread-0]</span> DEBUG lock<span class="hljs-selector-class">.ReentrantLockTest2</span> - 启动...<br><span class="hljs-number">16</span>:<span class="hljs-number">47</span>:<span class="hljs-number">35.183</span> <span class="hljs-selector-attr">[main]</span> DEBUG lock<span class="hljs-selector-class">.ReentrantLockTest2</span> - 执行打断<br><span class="hljs-number">16</span>:<span class="hljs-number">47</span>:<span class="hljs-number">35.183</span> <span class="hljs-selector-attr">[Thread-0]</span> DEBUG lock<span class="hljs-selector-class">.ReentrantLockTest2</span> - 等锁的过程中被打断<br>java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.InterruptedException</span><br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.doAcquireInterruptibly</span>(AbstractQueuedSynchronizer<span class="hljs-selector-class">.java</span>:<span class="hljs-number">898</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.acquireInterruptibly</span>(AbstractQueuedSynchronizer<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1222</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.ReentrantLock</span><span class="hljs-selector-class">.lockInterruptibly</span>(ReentrantLock<span class="hljs-selector-class">.java</span>:<span class="hljs-number">335</span>)<br>at lock<span class="hljs-selector-class">.ReentrantLockTest2</span>.lambda<span class="hljs-variable">$main</span>$<span class="hljs-number">0</span>(ReentrantLockTest2<span class="hljs-selector-class">.java</span>:<span class="hljs-number">20</span>)<br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.run</span>(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">750</span>)<br></code></pre></td></tr></table></figure><p>注意如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs livescript">@Slf4j<br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLockTest2</span> &#123;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br>        ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            lock.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125; <span class="hljs-keyword">finally</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                lock.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">lock</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;获得了锁&quot;</span>)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">t1</span>.<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;执行打断&quot;</span>)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>;</span><br><span class="hljs-function">        &#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;释放了锁&quot;</span>)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">lock</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">18</span>:<span class="hljs-number">06</span>:<span class="hljs-number">56.261</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 获得了锁<br><span class="hljs-number">18</span>:<span class="hljs-number">06</span>:<span class="hljs-number">56.265</span> <span class="hljs-selector-attr">[t1]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 启动... <br><span class="hljs-number">18</span>:<span class="hljs-number">06</span>:<span class="hljs-number">57.266</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 执行打断 <span class="hljs-comment">// 这时 t1 并没有被真正打断, 而是仍继续等待锁</span><br><span class="hljs-number">18</span>:<span class="hljs-number">06</span>:<span class="hljs-number">58.267</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 释放了锁<br><span class="hljs-number">18</span>:<span class="hljs-number">06</span>:<span class="hljs-number">58.267</span> <span class="hljs-selector-attr">[t1]</span> c<span class="hljs-selector-class">.TestInterrupt</span> - 获得了锁<br></code></pre></td></tr></table></figure><p>这是一种被动打断，也就是被别的线程打断，所以接下来介绍主动打断-&gt;锁超时。</p><h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p>立刻失败</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs livescript">ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">if</span> (!lock.tryLock()) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        log.debug(<span class="hljs-string">&quot;获取立刻失败，返回&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">return</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125; <span class="hljs-keyword">finally</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        lock.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function">//主线程获得到<span class="hljs-title">lock</span>锁</span><br><span class="hljs-function"><span class="hljs-title">lock</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;获得了锁&quot;</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>;</span><br><span class="hljs-function">&#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">lock</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">17:05:08.957 [main] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest3 - 获得了锁<br>17:05:08.960 [t1] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest3 - 启动<span class="hljs-built_in">..</span>.<br>17:05:08.960 [t1] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest3 - 获取立刻失败，返回<br></code></pre></td></tr></table></figure><p>超时失败</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs livescript">ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">if</span> (!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            log.debug(<span class="hljs-string">&quot;获取等待 1s 后失败，返回&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">return</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125; <span class="hljs-keyword">finally</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        lock.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">lock</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;获得了锁&quot;</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>;</span><br><span class="hljs-function">&#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">lock</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">17:07:37.062 [main] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest3 - 获得了锁<br>17:07:37.064 [t1] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest3 - 启动<span class="hljs-built_in">..</span>.<br>17:07:38.075 [t1] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest3 - 获取等待 1s 后失败，返回<br></code></pre></td></tr></table></figure><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>ReentrantLock 默认是不公平的，什么是公平和不公平？在获取不到锁对象时，线程会进入阻塞队列，当执行线程完毕后，阻塞队列里的线程会一窝蜂来争抢锁对象，谁抢到就是谁的，而不是按进入队列的顺序先来后到。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待。</p><p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比</p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li><li>await 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul><p>例子：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">static</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-keyword">static</span> Condition waitCigaretteQueue = lock.newCondition();<br><span class="hljs-keyword">static</span> Condition waitbreakfastQueue = lock.newCondition();<br><span class="hljs-keyword">static</span> volatile boolean hasCigrette = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">static</span> volatile boolean hasBreakfast = <span class="hljs-literal">false</span>;<br><br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br>    <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            lock.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">while</span> (!hasCigrette) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    log.debug(<span class="hljs-string">&quot;没烟抽，先等一会&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">                    waitCigaretteQueue.<span class="hljs-keyword">await</span>();</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">            log.debug(<span class="hljs-string">&quot;等到了它的烟&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125; <span class="hljs-keyword">finally</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            lock.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            lock.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">while</span> (!hasBreakfast) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    log.debug(<span class="hljs-string">&quot;没饭吃，先等一会&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">                    waitbreakfastQueue.<span class="hljs-keyword">await</span>();</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">            log.debug(<span class="hljs-string">&quot;等到了它的早餐&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125; <span class="hljs-keyword">finally</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            lock.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1000</span>)</span>;</span><br><span class="hljs-function">    <span class="hljs-title">sendBreakfast</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1000</span>)</span>;</span><br><span class="hljs-function">    <span class="hljs-title">sendCigarette</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"><span class="hljs-title">private</span> <span class="hljs-title">static</span> <span class="hljs-title">void</span> <span class="hljs-title">sendCigarette</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">    //先获取锁才能使用</span><br><span class="hljs-function">    <span class="hljs-title">lock</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;送烟来了&quot;</span>)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">hasCigrette</span> = <span class="hljs-title">true</span>;</span><br><span class="hljs-function">        <span class="hljs-title">waitCigaretteQueue</span>.<span class="hljs-title">signal</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">lock</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">private</span> <span class="hljs-title">static</span> <span class="hljs-title">void</span> <span class="hljs-title">sendBreakfast</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">lock</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;送早餐来了&quot;</span>)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">hasBreakfast</span> = <span class="hljs-title">true</span>;</span><br><span class="hljs-function">        <span class="hljs-title">waitbreakfastQueue</span>.<span class="hljs-title">signal</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">lock</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">19:12:46.838 [Thread-0] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest4 - 没烟抽，先等一会<br>19:12:46.840 [Thread-1] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest4 - 没饭吃，先等一会<br>19:12:47.838 [main] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest4 - 送早餐来了<br>19:12:47.838 [Thread-1] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest4 - 等到了它的早餐<br>19:12:48.852 [main] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest4 - 送烟来了<br>19:12:48.852 [Thread-0] <span class="hljs-built_in">DEBUG</span> reentrantlockTest.ReentrantLockTest4 - 等到了它的烟<br></code></pre></td></tr></table></figure><h2 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h2><h3 id="固定运行顺序打印"><a href="#固定运行顺序打印" class="headerlink" title="固定运行顺序打印"></a>固定运行顺序打印</h3><h4 id="wait-notify-版"><a href="#wait-notify-版" class="headerlink" title="wait notify 版"></a>wait notify 版</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">static</span> final <span class="hljs-built_in">Object</span> lock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-keyword">static</span> volatile boolean  t2runed = <span class="hljs-literal">false</span>;<br><br>Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            synchronized (lock)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">while</span>(t2runed)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                        lock.wait();</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                        e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">                    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">                System.out.println(<span class="hljs-string">&quot;1&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">Thread</span> <span class="hljs-title">t2</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            System.out.println(<span class="hljs-string">&quot;2&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            synchronized (lock)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                t2runed = <span class="hljs-literal">true</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">                lock.notify();</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;, <span class="hljs-string">&quot;t2&quot;</span>)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>1<br></code></pre></td></tr></table></figure><h4 id="Park-Unpark-版"><a href="#Park-Unpark-版" class="headerlink" title="Park Unpark 版"></a>Park Unpark 版</h4><p>可以看到，实现上很麻烦：</p><ul><li>首先，需要保证先 wait 再 notify，否则 wait 线程永远得不到唤醒。因此使用了『运行标记』来判断该不该 wait，比如先notify再wait就出问题了。</li><li>第二，如果有些干扰线程错误地 notify 了 wait 线程，条件不满足时还要重新等待，使用了 while 循环来解决 此问题</li><li>最后，唤醒对象上的 wait 线程需要使用 notifyAll，因为『同步对象』上的等待线程可能不止一个</li></ul><p>可以使用 LockSupport 类的 park 和 unpark 来简化上面的题目：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs livescript">Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">1000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-regexp">// 当没有『许可』时，当前线程暂停运行；有『许可』时，用掉这个『许可』，当前线程恢复运行</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function"> LockSupport.park();</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function"> System.out.println(&quot;1&quot;);</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">&#125;);</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">Thread t2 = new Thread(() -&gt; &#123;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function"> System.out.println(&quot;2&quot;);</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function"> //</span> 给线程 t1 发放『许可』（多次连续调用 unpark 只会发放一个『许可』）</span></span><br><span class="hljs-params"><span class="hljs-function"> LockSupport.unpark(t1);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br></code></pre></td></tr></table></figure><p>park 和 unpark 方法比较灵活，他俩谁先调用，谁后调用无所谓。并且是以线程为单位进行『暂停』和『恢复』， 不需要『同步对象』和『运行标记』</p><h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><p>线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现</p><h4 id="wait-notify-版-1"><a href="#wait-notify-版-1" class="headerlink" title="wait notify 版"></a>wait notify 版</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutPutTest3</span> &#123;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        SyncWaitNotify syncWaitNotify = <span class="hljs-keyword">new</span> SyncWaitNotify(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br><br>        <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            syncWaitNotify.<span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;a&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            syncWaitNotify.<span class="hljs-built_in">print</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;b&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            syncWaitNotify.<span class="hljs-built_in">print</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;c&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">SyncWaitNotify</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">private</span> <span class="hljs-title">int</span> <span class="hljs-title">flag</span>;</span><br><span class="hljs-function">    <span class="hljs-title">private</span> <span class="hljs-title">int</span> <span class="hljs-title">loopNumber</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">SyncWaitNotify</span><span class="hljs-params">(int flag, int loopNumber)</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">this</span>.<span class="hljs-title">flag</span> = <span class="hljs-title">flag</span>;</span><br><span class="hljs-function">        <span class="hljs-title">this</span>.<span class="hljs-title">loopNumber</span> = <span class="hljs-title">loopNumber</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">print</span><span class="hljs-params">(int waitFlag, int nextFlag, <span class="hljs-built_in">String</span> str)</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">synchronized</span> <span class="hljs-params">(this)</span>&#123;</span><br><span class="hljs-function">                <span class="hljs-title">while</span><span class="hljs-params">(flag != waitFlag)</span>&#123;</span><br><span class="hljs-function">                    <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">                        <span class="hljs-title">this</span>.<span class="hljs-title">wait</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">                    &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function">                        <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">                    &#125;</span><br><span class="hljs-function">                &#125;</span><br><span class="hljs-function">                <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(str)</span>;</span><br><span class="hljs-function">                <span class="hljs-title">flag</span> = <span class="hljs-title">nextFlag</span>;</span><br><span class="hljs-function">                <span class="hljs-title">this</span>.<span class="hljs-title">notifyAll</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            &#125;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="ReentrantLock版"><a href="#ReentrantLock版" class="headerlink" title="ReentrantLock版"></a>ReentrantLock版</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs livescript">package output;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @description: TODO(一句话描述该做什么)</span><br><span class="hljs-comment"> * @Author : </span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutPutTest4</span> &#123;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br>        AwaitSignal awaitSignal = <span class="hljs-keyword">new</span> AwaitSignal(<span class="hljs-number">5</span>);<br>        Condition a = awaitSignal.newCondition();<br>        Condition b = awaitSignal.newCondition();<br>        Condition c = awaitSignal.newCondition();<br><br>        <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            awaitSignal.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a&quot;</span>,a,b);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;,<span class="hljs-string">&quot;t1&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            awaitSignal.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;b&quot;</span>,b,c);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;,<span class="hljs-string">&quot;t1&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            awaitSignal.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;c&quot;</span>,c,a);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;,<span class="hljs-string">&quot;t1&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">Thread</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">awaitSignal</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">a</span>.<span class="hljs-title">signal</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125;<span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">awaitSignal</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">AwaitSignal</span> <span class="hljs-title">extends</span> <span class="hljs-title">ReentrantLock</span>&#123;</span><br><span class="hljs-function">    <span class="hljs-title">private</span> <span class="hljs-title">int</span> <span class="hljs-title">loopNumber</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">AwaitSignal</span><span class="hljs-params">(int loopNumber)</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">this</span>.<span class="hljs-title">loopNumber</span> = <span class="hljs-title">loopNumber</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">print</span><span class="hljs-params">( <span class="hljs-built_in">String</span> str,Condition cur,Condition next)</span>&#123;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">                <span class="hljs-title">cur</span>.<span class="hljs-title">await</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">                <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(str)</span>;</span><br><span class="hljs-function">                <span class="hljs-title">next</span>.<span class="hljs-title">signal</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function">                <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            &#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function">                <span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            &#125;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="park-x2F-unpark"><a href="#park-x2F-unpark" class="headerlink" title="park&#x2F;unpark"></a>park&#x2F;unpark</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs livescript">package output;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @description: TODO(一句话描述该做什么)</span><br><span class="hljs-comment"> * @Author : 彭建飞</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutPutTest5</span> &#123;<br>    <span class="hljs-keyword">static</span> Thread a;<br>    <span class="hljs-keyword">static</span> Thread b;<br>    <span class="hljs-keyword">static</span> Thread c;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br>        SyncPark syncPark = <span class="hljs-keyword">new</span> SyncPark(<span class="hljs-number">5</span>);<br>        a = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            syncPark.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a&quot;</span>,b);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">b</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            syncPark.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;b&quot;</span>,c);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">c</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            syncPark.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;c&quot;</span>,a);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">a</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">b</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">c</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">Thread</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span>;</span><br><span class="hljs-function">        <span class="hljs-title">LockSupport</span>.<span class="hljs-title">unpark</span><span class="hljs-params">(a)</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">SyncPark</span>&#123;</span><br><span class="hljs-function">    <span class="hljs-title">private</span> <span class="hljs-title">int</span> <span class="hljs-title">loopNumber</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">SyncPark</span><span class="hljs-params">(int loopNumber)</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">this</span>.<span class="hljs-title">loopNumber</span> = <span class="hljs-title">loopNumber</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-built_in">String</span> str , Thread next)</span>&#123;</span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(int i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">LockSupport</span>.<span class="hljs-title">park</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(str)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">LockSupport</span>.<span class="hljs-title">unpark</span><span class="hljs-params">(next)</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>先聊几个问题</p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230707214957383.png" alt="image-20230707214957383"></p><p>先来看操作系统中的一个架构</p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230707215340412.png" alt="image-20230707215340412"></p><p>因为有那么多级的缓存(CPU和物理主内存的速度不一致的)，CPU的运行并<strong>不是直接操作内存而是先把内存里边的数据读取到缓存</strong>，而内存的读和写操作就会造成不一致的问题</p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230707220135160.png" alt="image-20230707220135160"></p><p>JVM规范中试图定义一种Java内存模型(Java Memory Model,简称JMM)来<strong>屏蔽掉各种硬件和操作系统的内存访问差异</strong>以实现让Java程序在各种平台下都能达到一致的<strong>内存访问效果</strong></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>JMM(Java内存模型Java Memory Model，简称JMM)本身是一种<strong>抽象的</strong>概念<strong>并不真实存在</strong>它仅仅描述的<strong>是一组约定或规范</strong>，通过这组规范定义了程序中(尤其是多线程)各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，关键技术点都是围绕多线程的<strong>原子性、可见性和有序性</strong>展开的。</p><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>JMM的关键技术点都是围绕多线程的<strong>原子性、可见性和有序性</strong>展开的</p><p><strong>能干吗？</strong></p><ul><li>通过JMM来实现<strong>线程和主内存之间的抽象关系</strong>。</li><li>屏蔽各个<strong>硬件平台</strong>和<strong>操作系统</strong>的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。</li></ul><h3 id="JMM规范下的三大特性"><a href="#JMM规范下的三大特性" class="headerlink" title="JMM规范下的三大特性"></a>JMM规范下的三大特性</h3><p><strong>可见性</strong>：是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更，JMM规定了所有的变量都存储在<strong>主内存</strong>中</p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230707222542359.png" alt="image-20230707222542359"></p><p>系统主内存<strong>共享变量</strong>数据修改被写入的时机是不确定的，<strong>多线程并发下很可能出现”脏读”<strong>，所以每个线程都有自己的工作内存、线程自己的工作内存中保存了该线程使用到的变量的</strong>主内存副本拷贝</strong>，线程对变量的所有操作（读取，赋值等）都必需在线程自己的工作内存中进行，而不能够直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230707224418765.png" alt="image-20230707224418765"></p><p><strong>线程脏读</strong></p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230707224718299.png" alt="image-20230707224718299"></p><p><strong>原子性</strong>：指一个操作是不可打断的，即多线程环境下，操作是不能被其他线程干扰的</p><p><strong>有序性</strong>：</p><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">static int i<span class="hljs-comment">;</span><br>static int j<span class="hljs-comment">;</span><br>// 在某个线程内执行如下赋值操作<br><span class="hljs-attribute">i</span> <span class="hljs-operator">=</span> ...<span class="hljs-comment">; </span><br><span class="hljs-attribute">j</span> <span class="hljs-operator">=</span> ...<span class="hljs-comment">; </span><br></code></pre></td></tr></table></figure><p>可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时，既可以是</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">i</span> <span class="hljs-operator">=</span> ...<span class="hljs-comment">; </span><br><span class="hljs-attribute">j</span> <span class="hljs-operator">=</span> ...<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>也可以是</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">j</span> <span class="hljs-operator">=</span> ...<span class="hljs-comment">;</span><br><span class="hljs-attribute">i</span> <span class="hljs-operator">=</span> ...<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。为什么要有重排指令这项优化呢？从 CPU 执行指令的原理来理解一下吧</p><h3 id="鱼罐头的故事"><a href="#鱼罐头的故事" class="headerlink" title="鱼罐头的故事"></a>鱼罐头的故事</h3><p>加工一条鱼需要 50 分钟，只能一条鱼、一条鱼顺序加工…</p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230708192343346.png" alt="image-20230708192343346"></p><p>可以将每个鱼罐头的加工流程细分为 5 个步骤：</p><ul><li>去鳞清洗 10分钟 </li><li>蒸煮沥水 10分钟 </li><li>加注汤料 10分钟 </li><li>杀菌出锅 10分钟 </li><li>真空封罐 10分钟</li></ul><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230708192435387.png" alt="image-20230708192435387"></p><p>即使只有一个工人，最理想的情况是：他能够在 10 分钟内同时做好这 5 件事，因为对第一条鱼的真空装罐，不会 影响对第二条鱼的杀菌出锅…</p><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。但为了提升性能，编译器和处理器通常会对指令序列进行<strong>重新排序</strong>。Java规范规定JVM线程内部维持<strong>顺序化语义</strong>，即只要程序的最终结果与它顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序<strong>不一致,此过程叫指令的重排序</strong>。</p><p>指令重排序优缺点：</p><p>JVM能根据处理器特性:(CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。但是，</p><p>指令重排<strong>可以保证串行语义一致</strong>，但没有义务保证<strong>多线程间的语义也一致</strong>(即可能产生”脏读”)，简单说.</p><p>两行以上不相干的代码在执行的时候有可能先执行的不是第一条，<strong>不见得是从上到下顺序执行，执行顺序会被优化</strong>。</p><p><strong>从源码到最终执行示例图：</strong></p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230707234808169.png" alt="image-20230707234808169"></p><p>单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。处理器在进行重排序时<strong>必须要考虑</strong>指令之间的<strong>数据依赖性</strong>。</p><p>多线程环境中线程交替执行,由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的,结果无法预测。</p><h3 id="指令重排序优化"><a href="#指令重排序优化" class="headerlink" title="指令重排序优化"></a>指令重排序优化</h3><p>事实上，现代处理器会设计为一个时钟周期完成一条执行时间最长的 CPU 指令。为什么这么做呢？可以想到指令 还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据 写回 这 5 个阶段</p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230708192534371.png" alt="image-20230708192534371"></p><p>在不改变程序结果的前提下，这些指令的各个阶段可以通过重排序和组合来实现指令级并行，这一技术在 80’s 中 叶到 90’s 中叶占据了计算架构的重要地位。</p><p>提示： 分阶段，分工是提升效率的关键！</p><p><strong>指令重排的前提是，重排指令不能影响结果，例如</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 可以重排的例子<br>int a = <span class="hljs-number">10</span>; <span class="hljs-regexp">//</span> 指令<span class="hljs-number">1</span><br>int b = <span class="hljs-number">20</span>; <span class="hljs-regexp">//</span> 指令<span class="hljs-number">2</span><br>System.out.println( a + b );<br><span class="hljs-regexp">//</span> 不能重排的例子<br>int a = <span class="hljs-number">10</span>; <span class="hljs-regexp">//</span> 指令<span class="hljs-number">1</span><br>int b = a - <span class="hljs-number">5</span>; <span class="hljs-regexp">//</span> 指令<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>现代 CPU 支持多级指令流水线，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理 器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间最长的复杂指令），IPC &#x3D; 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了 指令地吞吐率。</p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230708192704187.png" alt="image-20230708192704187"></p><h3 id="诡异的结果"><a href="#诡异的结果" class="headerlink" title="诡异的结果"></a>诡异的结果</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-type">boolean</span> ready = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br> <span class="hljs-keyword">if</span>(ready) &#123;<br>     r.r1 = num + num;<br> &#125; <span class="hljs-keyword">else</span> &#123;<br>     r.r1 = <span class="hljs-number">1</span>;<br> &#125;<br>&#125;<br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123; <br> num = <span class="hljs-number">2</span>;<br> ready = <span class="hljs-literal">true</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？ </p><ul><li>情况1：线程1 先执行，这时 ready &#x3D; false，所以进入 else 分支结果为 1</li><li>情况2：线程2 先执行 num &#x3D; 2，但没来得及执行 ready &#x3D; true，线程1 执行，还是进入 else 分支，结果为1</li><li>情况3：线程2 执行到 ready &#x3D; true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）</li></ul><p>但我告诉你，结果还有可能是 0 😁😁😁，信不信吧！ 这种情况下是：线程2 执行 ready &#x3D; true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num &#x3D; 2 相信很多人已经晕了 😵😵😵</p><p><strong>这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现</strong></p><p>那么怎么解决呢？</p><p>这里采取的是 volatile boolean ready &#x3D; false;</p><p>在ready前加上volatile，意思是在ready之前的都不能重排列到ready之后去</p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>内存屏障 Memory Barrier（Memory Fence）</p><ul><li>可见性<ul><li>写屏障（sfence）保证在该屏障<strong>之前的</strong>，对共享变量的改动，都同步到主存当中</li><li>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</li></ul></li><li>有序性<ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul></li></ul><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230708203312284.png" alt="image-20230708203312284"></p><h3 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h3><p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障</li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><h4 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h4><ul><li>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>     num = <span class="hljs-number">2</span>;<br>     ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ready 是 volatile 赋值带写屏障</span><br>     <span class="hljs-comment">// 加写屏障</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>     <span class="hljs-comment">// 读屏障</span><br>     <span class="hljs-comment">// ready 是 volatile 读取值带读屏障</span><br>     <span class="hljs-keyword">if</span>(ready) &#123;<br>        r.r1 = num + num;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>        r.r1 = <span class="hljs-number">1</span>;<br>     &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230708205155910.png" alt="image-20230708205155910"></p><h4 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h4><ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>    num = <span class="hljs-number">2</span>;<br>    ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ready 是 volatile 赋值带写屏障</span><br>    <span class="hljs-comment">// 加写屏障</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>    <span class="hljs-comment">//加读屏障</span><br>    <span class="hljs-comment">// ready 是 volatile 读取值带读屏障</span><br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>       r.r1 = num + num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>       r.r1 = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230708205902062.png" alt="image-20230708205902062"></p><p>还是那句话，不能解决指令交错：</p><ul><li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去</li><li>而有序性的保证也只是保证了本线程内相关代码不被重排序</li></ul><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230708211016744.png" alt="image-20230708211016744"></p><p>volatile只能保证线程的可见性和有序性，不能保证原子性，如上图，而synchronized三者都可保证</p><h3 id="单例模式double-checked-locking-问题"><a href="#单例模式double-checked-locking-问题" class="headerlink" title="单例模式double-checked locking 问题"></a>单例模式double-checked locking 问题</h3><p>以著名的 double-checked locking 单例模式为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123; <br>        <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t2</span><br>        <span class="hljs-comment">// 首次访问会同步，而之后的使用没有 synchronized</span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br>               <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t1</span><br>                 INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>               &#125; <br>             &#125;<br>          &#125;<br>          <span class="hljs-keyword">return</span> INSTANCE;<br>     &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>以上的实现特点是：</p><ul><li>懒惰实例化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li><li>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外</li></ul><p>但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">0</span>: getstatic <span class="hljs-comment">#2        // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-attribute">3</span>: ifnonnull 37<br><span class="hljs-attribute">6</span>: ldc <span class="hljs-comment">#3              // class cn/itcast/n5/Singleton</span><br><span class="hljs-attribute">8</span>: dup<br><span class="hljs-attribute">9</span>: astore_0<br><span class="hljs-attribute">10</span>: monitorenter<br><span class="hljs-attribute">11</span>: getstatic <span class="hljs-comment">#2       // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-attribute">14</span>: ifnonnull 27<br><span class="hljs-attribute">17</span>: new <span class="hljs-comment">#3             // class cn/itcast/n5/Singleton</span><br><span class="hljs-attribute">20</span>: dup<br><span class="hljs-attribute">21</span>: invokespecial <span class="hljs-comment">#4   // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-attribute">24</span>: putstatic <span class="hljs-comment">#2       // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-attribute">27</span>: aload_0<br><span class="hljs-attribute">28</span>: monitorexit<br><span class="hljs-attribute">29</span>: goto 37<br><span class="hljs-attribute">32</span>: astore_1<br><span class="hljs-attribute">33</span>: aload_0<br><span class="hljs-attribute">34</span>: monitorexit<br><span class="hljs-attribute">35</span>: aload_1<br><span class="hljs-attribute">36</span>: athrow<br><span class="hljs-attribute">37</span>: getstatic <span class="hljs-comment">#2       // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-attribute">40</span>: areturn<br></code></pre></td></tr></table></figure><p>其中</p><ul><li>17 表示创建对象，将对象引用入栈 &#x2F;&#x2F; new Singleton</li><li>20 表示复制一份对象引用 &#x2F;&#x2F; 引用地址</li><li>21 表示利用一个对象引用，调用构造方法</li><li>24 表示利用一个对象引用，赋值给 static INSTANCE</li></ul><p>也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行：</p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230709102151941.png" alt="image-20230709102151941"></p><p>关键在于 0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取 INSTANCE 变量的值 这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个<strong>未初 始化完毕的单例</strong> 对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效</p><h3 id="double-checked-locking-解决"><a href="#double-checked-locking-解决" class="headerlink" title="double-checked locking 解决"></a>double-checked locking 解决</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> final <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>()</span> &#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton INSTANCE = <span class="hljs-literal">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span>()</span> &#123;<br>        <span class="hljs-comment">// 实例没创建，才会进入内部的 synchronized代码块</span><br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123; <br>           synchronized (Singleton.<span class="hljs-keyword">class</span>) &#123; <span class="hljs-comment">// t2</span><br>              <span class="hljs-comment">// 也许有其它线程已经创建实例，所以再判断一次</span><br>              <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t1</span><br>                 INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>              &#125;<br>           &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>     &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>字节码上看不出来 volatile 指令的效果</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ldif">// -------------------------------------&gt; 加入对 INSTANCE 变量的读屏障<br><span class="hljs-attribute">0</span>: getstatic <span class="hljs-comment">#2     // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-attribute">3</span>: ifnonnull 37<br><span class="hljs-attribute">6</span>: ldc <span class="hljs-comment">#3       // class cn/itcast/n5/Singleton</span><br><span class="hljs-attribute">8</span>: dup<br><span class="hljs-attribute">9</span>: astore_0<br><span class="hljs-attribute">10</span>: monitorenter -----------------------&gt; 保证原子性、可见性<br><span class="hljs-attribute">11</span>: getstatic <span class="hljs-comment">#2     // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-attribute">14</span>: ifnonnull 27<br><span class="hljs-attribute">17</span>: new <span class="hljs-comment">#3     // class cn/itcast/n5/Singleton</span><br><span class="hljs-attribute">20</span>: dup<br><span class="hljs-attribute">21</span>: invokespecial <span class="hljs-comment">#4     // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-attribute">24</span>: putstatic <span class="hljs-comment">#2     // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br>// -------------------------------------&gt; 加入对 INSTANCE 变量的写屏障<br><span class="hljs-attribute">27</span>: aload_0<br><span class="hljs-attribute">28</span>: monitorexit ------------------------&gt; 保证原子性、可见性<br><span class="hljs-attribute">29</span>: goto 37<br><span class="hljs-attribute">32</span>: astore_1<br><span class="hljs-attribute">33</span>: aload_0<br><span class="hljs-attribute">34</span>: monitorexit<br><span class="hljs-attribute">35</span>: aload_1<br><span class="hljs-attribute">36</span>: athrow<br><span class="hljs-attribute">37</span>: getstatic <span class="hljs-comment">#2   // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-attribute">40</span>: areturn<br></code></pre></td></tr></table></figure><p>如上面的注释内容所示，读写 volatile 变量时会加入内存屏障（Memory Barrier（Memory Fence）），保证下面 两点：</p><ul><li>可见性<ul><li><strong>写屏障（sfence）</strong>保证在该屏障<strong>之前</strong>的 t1 对共享变量的改动，都同步到主存当中</li><li>而<strong>读屏障（lfence）</strong>保证在该屏障<strong>之后</strong> t2 对共享变量的读取，加载的是主存中最新数据</li></ul></li><li>有序性<ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul></li><li>更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性</li></ul><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230709102042785.png" alt="image-20230709102042785"></p><h3 id="读取过程"><a href="#读取过程" class="headerlink" title="读取过程"></a>读取过程</h3><p>由于JVM运行程序的实体是线醒，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在<strong>主内存</strong>，主内存是共享内存区域，所有线程都可以访问，<strong>但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存</strong>，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的<strong>变量副本拷贝</strong>，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图:</p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230708115509974.png"></p><h3 id="Happens-before-先行发生-原则"><a href="#Happens-before-先行发生-原则" class="headerlink" title="Happens-before(先行发生)原则"></a>Happens-before(先行发生)原则</h3><p>在JMM中，如果一个操作<strong>执行的结果</strong>需要对另一个操作可见性或者代码重排序，那么这两个操作之间必须存在<strong>Happens-before</strong>原则。</p><p>逻辑上的先后关系。</p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230708121608334.png" alt="image-20230708121608334"></p><p>如果Java内存模型中所有的有序性都仅靠volatile和synchronized来完成，那么有很多操作都将会变得非常啰嗦，但是我们在编写Java并发代码的时候并没有察觉到这一点。</p><p>我们没有时时、处处、次次，添加volatile和synchronized来完成程序，这是因为Java语言中JMM原则下有一个“先行发生”(Happens-Before)的原则限制和规矩，给你立好了规矩!</p><p>这个原则非常重要:</p><p>它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型苦涩难懂的底层编译原理之中</p><p><strong>总原则</strong></p><ul><li>如果一个操作<strong>happens-before</strong>另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的<strong>结果一致</strong>，那么这种重排序<strong>并不非法</strong></li></ul><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230708124934452.png" alt="image-20230708124934452"></p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230708144718535.png" alt="image-20230708144718535"></p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>全称是 AbstractQueuedSynchronizer(抽象队列同步器)，是<strong>阻塞式锁</strong>和<strong>相关的同步器工具</strong>的框架</p><p>特点：</p><ul><li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取 锁和释放锁<ul><li>getState - 获取 state 状态</li><li>setState - 设置 state 状态</li><li>compareAndSetState - cas 机制设置 state 状态</li><li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li></ul></li><li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li><li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li></ul><p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul><h3 id="实现不可重入锁"><a href="#实现不可重入锁" class="headerlink" title="实现不可重入锁"></a>实现不可重入锁</h3><p>创建同步器类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//同步器类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySyn</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AbstractQueuedSynchronizer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">tryAcquire</span>(<span class="hljs-params">int arg</span>) &#123;<br>       <span class="hljs-keyword">if</span>( <span class="hljs-title function_">compareAndSetState</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))&#123;<br>           <span class="hljs-title function_">setExclusiveOwnerThread</span>(<span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">currentThread</span>());<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">tryRelease</span>(<span class="hljs-params">int arg</span>) &#123;<br>        <span class="hljs-title function_">setExclusiveOwnerThread</span>(<span class="hljs-literal">null</span>);<br>        <span class="hljs-title function_">setState</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isHeldExclusively</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">getState</span>() == <span class="hljs-number">1</span> ;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title class_">Condition</span> <span class="hljs-title function_">newCondition</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建锁类</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;<br>    MySyn syn = <span class="hljs-keyword">new</span> MySyn();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        syn.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        syn.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> syn.<span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">return</span> syn.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        syn.release(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> syn.<span class="hljs-title">newCondition</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        MyLock lock = <span class="hljs-keyword">new</span> MyLock();<br>        <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            lock.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">                Thread.sleep(<span class="hljs-number">1000</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125; <span class="hljs-keyword">finally</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                log.debug(<span class="hljs-string">&quot;unlocking...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">                lock.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;,<span class="hljs-string">&quot;t1&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            lock.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125; <span class="hljs-keyword">finally</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                log.debug(<span class="hljs-string">&quot;unlocking...&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">                lock.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;,<span class="hljs-string">&quot;t2&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">20</span>:<span class="hljs-number">24</span>:<span class="hljs-number">43</span>.<span class="hljs-number">861</span> [<span class="hljs-built_in">t1</span>] <span class="hljs-built_in">DEBUG</span> AQSTest.AQStest - locking...<br><span class="hljs-number">20</span>:<span class="hljs-number">24</span>:<span class="hljs-number">44</span>.<span class="hljs-number">875</span> [<span class="hljs-built_in">t1</span>] <span class="hljs-built_in">DEBUG</span> AQSTest.AQStest - unlocking...<br><span class="hljs-number">20</span>:<span class="hljs-number">24</span>:<span class="hljs-number">44</span>.<span class="hljs-number">875</span> [<span class="hljs-built_in">t2</span>] <span class="hljs-built_in">DEBUG</span> AQSTest.AQStest - locking...<br><span class="hljs-number">20</span>:<span class="hljs-number">24</span>:<span class="hljs-number">44</span>.<span class="hljs-number">875</span> [<span class="hljs-built_in">t2</span>] <span class="hljs-built_in">DEBUG</span> AQSTest.AQStest - unlocking...<br></code></pre></td></tr></table></figure><h2 id="ReentrantLock-1"><a href="#ReentrantLock-1" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230709215715775.png" alt="image-20230709215715775"></p><h3 id="非公平锁实现原理"><a href="#非公平锁实现原理" class="headerlink" title="非公平锁实现原理"></a>非公平锁实现原理</h3><p><strong>加锁解锁流程</strong></p><p>先从构造器开始看，默认为非公平锁实现</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span>()</span> &#123;<br>   sync = <span class="hljs-keyword">new</span> NonfairSync();<br>&#125;<br></code></pre></td></tr></table></figure><p>NonfairSync 继承自 AQS</p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230709215859835.png" alt="image-20230709215859835"></p><p>没有竞争时</p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230709215920057.png" alt="image-20230709215920057"></p><p>第一个竞争出现时</p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230709220045966.png" alt="image-20230709220045966"></p><p>Thread-1 执行了</p><ul><li>CAS 尝试将 state 由 0 改为 1，结果失败</li></ul><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230709220711944.png" alt="image-20230709220711944"></p><ul><li>进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败</li></ul><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230709220737276.png" alt="image-20230709220737276"></p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230709220749139.png" alt="image-20230709220749139"></p><ul><li>接下来进入 addWaiter 逻辑，构造 Node 队列<ul><li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态</li><li>Node 的创建是懒惰的</li><li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li></ul></li></ul><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230709220844407.png" alt="image-20230709220844407"></p><p>当前线程进入 acquireQueued 逻辑</p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230709221118587.png" alt="image-20230709221118587"></p><ul><li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</li><li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li><li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head(Node(null)) 的 waitStatus 改为 -1，这次返回 false</li></ul><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230709221724573.png" alt="image-20230709221724573"></p><ul><li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li><li>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true</li><li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li></ul><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230709221953856.png" alt="image-20230709221953856"></p><p>再次有多个线程经历上述过程竞争失败，变成这个样子</p><p><img src="C:\Users\86185\AppData\Roaming\Typora\typora-user-images\image-20230709222007039.png" alt="image-20230709222007039"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Jvm</title>
    <link href="/2023/02/22/Jvm/"/>
    <url>/2023/02/22/Jvm/</url>
    
    <content type="html"><![CDATA[<h2 id="一、JVM-内存区域"><a href="#一、JVM-内存区域" class="headerlink" title="一、JVM 内存区域"></a>一、JVM 内存区域</h2><p>Java虚拟机在运行时，会把内存空间分为若干个区域，根据《Java虚拟机规范（Java SE 7 版）》的规定，Java虚拟机所管理的内存区域分为如下部分：<em><strong>方法区、堆内存、虚拟机栈、本地方法栈、程序计数器</strong></em>。</p><p><img src="/../Jvm_pic/1.png" alt="Jvm"></p><p>参考：<a href="https://cloud.tencent.com/developer/article/1698363">内存篇：JVM内存结构 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p>1、<em><strong>方法区</strong></em></p><p>方法区主要用于存储虚拟机加载的<em><strong>类信息、常量、静态变量，以及编译器编译后的代码</strong></em>等数据。在<em><strong>jdk1.7</strong></em>及<em><strong>其之前</strong></em>，方法区是堆的一个“<em><strong>逻辑部分</strong></em>”（一片连续的堆空间），但为了与堆做区分，方法区还有个名字叫“非堆”，也有人用“永久代”（<em><strong>HotSpot</strong></em>对方法区的实现方法）来表示方法区。</p><p>从<em><strong>jdk1.7</strong></em>已经开始准备“去永久代”的规划，jdk1.7的HotSpot中，已经把原本放在方法区中的<em><strong>静态变量</strong></em>、<em><strong>字符串常量池</strong></em>等<em><strong>移到堆内存</strong></em>中，（常量池除字符串常量池还有class常量池等），这里只是把字符串常量池移到堆内存中；在<em><strong>jdk1.8</strong></em>中，方法区已经不存在，原方法区中存储的类信息、编译后的代码数据等已经移动到了<em><strong>元空间</strong></em>（MetaSpace）中，<em><strong>元空间并没有处于堆内存上</strong></em>，而是直接占用的<em><strong>本地内存</strong></em>（NativeMemory）。根据网上的资料结合自己的理解对jdk1.3~1.6、jdk1.7、jdk1.8中方法区的变迁画了张图如下（如有不合理的地方希望读者指出）：</p><p><img src="/../Jvm_pic/Jvm%E7%89%88%E6%9C%AC%E5%8F%98%E8%BF%81.png"></p><p>去永久代的原因有： </p><p>（1）字符串存在永久代中，容易出现性能问题和内存溢出。</p><p>（2）类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</p><p>（3）永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p><p>2、<em><strong>堆内存</strong></em></p><p>堆内存主要用于存放<strong>对象和数组</strong>，它是JVM管理的内存中最大的一块区域，<strong>堆内存和方法区都被所有线程共享</strong>，在虚拟机启动时创建。在垃圾收集的层面上来看，由于现在收集器基本上都采用分代收集算法，因此堆还可以分为<strong>新生代（YoungGeneration）和老年代（OldGeneration）</strong>，<strong>新生代还可以分为 Eden、From Survivor、To Survivor</strong>。</p><p>堆具有以下特点：</p><ul><li>堆内存最大</li><li>堆是被线程共享，</li><li>堆的目的就是存放对象，几乎所有的对象实例都在此分配。当然，随着优化技术的更新，某些数据也会被放在栈上等。</li></ul><p>因为堆占用内存空间最大，堆也是Java垃圾回收的主要区域（重点对象），因此也称作“GC堆”（Garbage Collected Heap）</p><p><img src="/../Jvm_pic/2.png"></p><p> 同样，对上图呈现内容汇总分析：</p><ul><li>堆的GC操作采用分代收集算法。</li><li>堆区分了新生代和老年代。</li><li>新生代又分为：Eden空间、From Survivor（S0）空间、To Survivor（S1）空间。</li></ul><p>Java虚拟机规范规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。也就是说堆的内存是一块块拼凑起来的。要增加堆空间时，往上“拼凑”（可扩展性）即可，但当堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><p>3、<em><strong>程序计数器</strong></em></p><p>程序计数器是一块非常小的内存空间，可以看做是当前线程执行字节码的行号指示器，<strong>每个线程都有一个独立的程序计数器，因此程序计数器是线程私有的一块空间</strong>，此外，<strong>程序计数器是Java虚拟机规定的唯一不会发生内存溢出的区域</strong>。</p><p>4、<em><strong>虚拟机栈</strong></em></p><p><strong>虚拟机栈也是每个线程私有的一块内存空间</strong>，它描述的是方法的内存模型，直接看下图所示：</p><p><img src="/../Jvm_pic/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png"></p><p>虚拟机会为<strong>每个线程</strong>分配一个虚拟机栈，每个虚拟机栈中都有若干个栈帧，每个栈帧中<strong>存储了局部变量表、操作数栈、动态链接、返回地址等</strong>。一个栈帧就对应 Java 代码中的一个方法，当线程执行到一个方法时，就代表这个方法对应的栈帧已经进入虚拟机栈并且处于栈顶的位置，每一个 Java 方法从被调用到执行结束，就对应了一个栈帧从入栈到出栈的过程。</p><ul><li>局部变量表(Local Variable Table)是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。包括8种基本数据类型（int、short、byte、char、double、float、long、boolean）、对象引用（reference类型）和returnAddress类型（指向一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<strong>StackOverflowError</strong>异常；如果虚拟机栈动态扩展时无法申请到足够的内存时会抛出<strong>OutOfMemoryError</strong>异常。</li><li>操作数栈(Operand Stack)也称作操作栈，是一个后入先出栈(LIFO)。随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈&#x2F;入栈操作。</li><li>动态链接：Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态链接(Dynamic Linking)。</li><li>方法返回：无论方法是否正常完成，都需要返回到方法被调用的位置，程序才能继续进行。</li></ul><p>5、<em><strong>本地方法栈</strong></em></p><p>本地方法栈与虚拟机栈的区别是，虚拟机栈执行的是 Java 方法，本地方法栈执行的是本地方法（Native Method）,其他基本上一致，在 HotSpot 中直接把本地方法栈和虚拟机栈合二为一，这里暂时不做过多叙述。</p><p>6、<em><strong>元空间</strong></em></p><p>上面说到，jdk1.8 中，已经不存在永久代（方法区），替代它的一块空间叫做 “ 元空间 ”，和永久代类似，都是 JVM 规范对方法区的实现，但是<strong>元空间并不在虚拟机中，而是使用本地内存</strong>，元空间的大小仅受本地内存限制，但可以通过 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 来指定元空间的大小。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="如何判断对象可以被回收"><a href="#如何判断对象可以被回收" class="headerlink" title="如何判断对象可以被回收"></a>如何判断对象可以被回收</h3><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象中添加一个引用计数器：</p><ul><li>每当有一个地方引用它，计数器就加 1；</li><li>当引用失效，计数器就减 1；</li><li>任何时候计数器为 0 的对象就是不可能再被使用的。</li></ul><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。</strong></p><p><img src="/../Jvm_pic/3.png"></p><p>所谓对象之间的相互引用问题，如下面代码所示：除了对象 <code>objA</code> 和 <code>objB</code> 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs abnf">public class ReferenceCountingGc &#123;<br>    Object instance <span class="hljs-operator">=</span> null<span class="hljs-comment">;</span><br>    public static void main(String[] args) &#123;<br>        ReferenceCountingGc objA <span class="hljs-operator">=</span> new ReferenceCountingGc()<span class="hljs-comment">;</span><br>        ReferenceCountingGc objB <span class="hljs-operator">=</span> new ReferenceCountingGc()<span class="hljs-comment">;</span><br>        objA.instance <span class="hljs-operator">=</span> objB<span class="hljs-comment">;</span><br>        objB.instance <span class="hljs-operator">=</span> objA<span class="hljs-comment">;</span><br>        objA <span class="hljs-operator">=</span> null<span class="hljs-comment">;</span><br>        objB <span class="hljs-operator">=</span> null<span class="hljs-comment">;</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收</p><p>下图中的 <code>Object 6 ~ Object 10</code> 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。</p><p><img src="/../Jvm_pic/4.png"></p><p><strong>哪些对象可以作为GC Roots呢？</strong></p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><p><strong>对象可以被回收，就代表一定会被回收吗？</strong></p><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，<strong>至少要经历两次标记</strong>过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><p>tags：<code>Object</code> 类中的 <code>finalize</code> 方法一直被认为是一个糟糕的设计，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。JDK9 版本及后续版本中各个类中的 <code>finalize</code> 方法会被逐渐弃用移除。忘掉它的存在吧！</p><h3 id="引用类型总结"><a href="#引用类型总结" class="headerlink" title="引用类型总结"></a>引用类型总结</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p><img src="/../Jvm_pic/5.png"></p><ul><li>强引用<strong>（StrongReference）</strong></li></ul><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器一般不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</p><ul><li><strong>软引用（SoftReference）</strong></li></ul><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><ul><li><strong>弱引用（WeakReference）</strong></li></ul><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><ul><li><strong>虚引用（PhantomReference）</strong></li></ul><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><hr><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有<strong>可回收</strong>的对象，在标记完成后统一回收掉所有没有被标记的对象。</p><p>它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ul><li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li><li><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</li></ul><p><img src="/../Jvm_pic/6.png"></p><p>整个标记-清除过程大致是这样的：</p><ul><li><p>当一个对象被创建时，给一个标记位，假设为 0 (false)；</p></li><li><p>在标记阶段，我们将所有可达对象（或用户可以引用的对象）的标记位设置为 1 (true)；</p></li><li><p>扫描阶段清除的就是标记位为 0 (false)的对象</p></li></ul><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="/../Jvm_pic/7.png"></p><p>虽然改进了标记-清除算法，但依然存在下面这些问题：</p><ul><li><strong>可用内存变小</strong>：可用内存缩小为原来的一半。</li><li><strong>不适合老年代</strong>：如果存活对象数量比较大，复制性能会变得很差。</li></ul><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="/../Jvm_pic/8.png"></p><p>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记</p><p>问题：<strong>HotSpot 为什么要分为新生代和老年代</strong>？答案在上</p><h2 id="JVM相关参数"><a href="#JVM相关参数" class="headerlink" title="JVM相关参数"></a>JVM相关参数</h2><p><img src="/../Jvm_pic/9.png"></p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p><p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p><p>JDK 默认垃圾收集器（使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看）：</p><ul><li>JDK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）</li><li>JDK 9 ~ JDK20: G1</li></ul><h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="/../Jvm_pic/10.png"></p><p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p><h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="/../Jvm_pic/11.png"></p><p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><p><strong>并行和并发概念补充：</strong></p><ul><li><strong>并行（Parallel）</strong>：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上</li></ul><h4 id="Parallel-Scavenge-收集器-1-8默认"><a href="#Parallel-Scavenge-收集器-1-8默认" class="headerlink" title="Parallel Scavenge 收集器(1.8默认)"></a>Parallel Scavenge 收集器(1.8默认)</h4><p>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby">-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+UseParallelGC</span><br><br>    使用 <span class="hljs-title class_">Parallel</span> 收集器+ 老年代串行<br><br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+UseParallelOldGC</span><br><br>    使用 <span class="hljs-title class_">Parallel</span> 收集器+ 老年代并行<br><br></code></pre></td></tr></table></figure><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="/../Jvm_pic/12.png"></p><p><strong>这是 JDK1.8 默认收集器</strong></p><h4 id="CMS-重点"><a href="#CMS-重点" class="headerlink" title="CMS(重点)"></a>CMS(重点)</h4><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong>(关键：最短停顿时间-用户体验)</p><p>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机<strong>第一款真正意义上的并发收集器</strong>，它第一次实现了让垃圾收集线程与用户线程（基本上）<strong>同时</strong>工作。</p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><p><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快；</p><p><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p><p><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</p><p><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫</p><p><img src="/../Jvm_pic/13.png"></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h4 id="G1-重点，1-9及以后默认收集器"><a href="#G1-重点，1-9及以后默认收集器" class="headerlink" title="G1(重点，1.9及以后默认收集器)"></a>G1(重点，1.9及以后默认收集器)</h4><p>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要<strong>针对配备多颗处理器及大容量内存的机器</strong>. 以极高概率满足 GC <strong>停顿时间</strong>要求的同时,<strong>还具备高吞吐量</strong>性能特征.</p><p>(关键：停顿时间、高吞吐量)</p><p>特点：</p><ul><li><strong>并行与并发</strong>：充分利用CPU、多核环境的优势，使用多个CPU缩短STW时间，支持用户线程和GC并发</li><li><strong>分代收集</strong>：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，依然保留了分代概念</li><li><strong>空间整合</strong>：G1 从<strong>整体</strong>来看是基于“<strong>标记-整理</strong>”算法实现的收集器；从<strong>局部</strong>上来看是基于“<strong>标记-复制</strong>”算法实现的。</li><li><strong>可预测的停顿</strong>：能建立可预测的<strong>停顿时间模型</strong>，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><img src="/../Jvm_pic/14.png"></p><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><p><strong>从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2023/02/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1，设计模式概述"><a href="#1，设计模式概述" class="headerlink" title="1，设计模式概述"></a>1，设计模式概述</h1><h2 id="1-1-软件设计模式的产生背景"><a href="#1-1-软件设计模式的产生背景" class="headerlink" title="1.1 软件设计模式的产生背景"></a>1.1 软件设计模式的产生背景</h2><p>“设计模式”最初并不是出现在软件设计中，而是被用于建筑领域的设计中。</p><p>1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任<code>克里斯托夫·亚历山大（Christopher Alexander）</code>在他的著作《建筑模式语言：城镇、建筑、构造》中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。</p><p>1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）著称。  </p><h2 id="1-2-软件设计模式的概念"><a href="#1-2-软件设计模式的概念" class="headerlink" title="1.2 软件设计模式的概念"></a>1.2 软件设计模式的概念</h2><p>软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。</p><h2 id="1-3-学习设计模式的必要性"><a href="#1-3-学习设计模式的必要性" class="headerlink" title="1.3 学习设计模式的必要性"></a>1.3 学习设计模式的必要性</h2><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。</p><p>正确使用设计模式具有以下优点。</p><ul><li>可以提高程序员的思维能力、编程能力和设计能力。</li><li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li></ul><h2 id="1-4-设计模式分类"><a href="#1-4-设计模式分类" class="headerlink" title="1.4 设计模式分类"></a>1.4 设计模式分类</h2><ul><li><p><strong>创建型模式</strong></p><p>用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</p></li><li><p><strong>结构型模式</strong></p><p>用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</p></li><li><p><strong>行为型模式</strong></p><p>用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</p></li></ul><h1 id="2，UML图"><a href="#2，UML图" class="headerlink" title="2，UML图"></a>2，UML图</h1><p>统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</p><p>UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。</p><h2 id="2-1-类图概述"><a href="#2-1-类图概述" class="headerlink" title="2.1 类图概述"></a>2.1 类图概述</h2><p>类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。</p><h2 id="2-2-类图的作用"><a href="#2-2-类图的作用" class="headerlink" title="2.2 类图的作用"></a>2.2 类图的作用</h2><ul><li>在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解；</li><li>类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。</li></ul><h2 id="2-3-类图表示法"><a href="#2-3-类图表示法" class="headerlink" title="2.3 类图表示法"></a>2.3 类图表示法</h2><h3 id="2-3-1-类的表示方式"><a href="#2-3-1-类的表示方式" class="headerlink" title="2.3.1 类的表示方式"></a>2.3.1 类的表示方式</h3><p>在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。 </p><p><img src="/../img/Employee.jpg" alt="img"></p><p>属性&#x2F;方法名称前加的加号和减号表示了这个属性&#x2F;方法的可见性，UML类图中表示可见性的符号有三种：</p><ul><li><p>+：表示public</p></li><li><p>-：表示private</p></li><li><p>#：表示protected</p></li></ul><p>属性的完整表示方式是： <strong>可见性  名称 ：类型 [ &#x3D; 缺省值]</strong>  </p><p>方法的完整表示方式是： <strong>可见性  名称(参数列表) [ ： 返回类型]</strong></p><blockquote><p>注意：</p><p>​1，中括号中的内容表示是可选的</p><p>​2，也有将类型放在变量名前面，返回值类型放在方法名前面</p></blockquote><p><strong>举个栗子：</strong></p><p><img src="/../img/demo.png" alt="img"></p><p>上图Demo类定义了三个方法：</p><ul><li>method()方法：修饰符为public，没有参数，没有返回值。</li><li>method1()方法：修饰符为private，没有参数，返回值类型为String。</li><li>method2()方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为String，返回值类型是int。</li></ul><h3 id="2-3-2-类与类之间关系的表示方式"><a href="#2-3-2-类与类之间关系的表示方式" class="headerlink" title="2.3.2 类与类之间关系的表示方式"></a>2.3.2 类与类之间关系的表示方式</h3><h4 id="2-3-2-1-关联关系"><a href="#2-3-2-1-关联关系" class="headerlink" title="2.3.2.1 关联关系"></a>2.3.2.1 关联关系</h4><p>关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。</p><p>关联又可以分为单向关联，双向关联，自关联。</p><p><strong>1，单向关联</strong></p><p><img src="/../img/customer_address.png" alt="img"></p><p>在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。</p><p><strong>2，双向关联</strong></p><p><img src="/img/customer_product.png" alt="img"></p><p>从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。</p><p>在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List&lt;Product&gt;，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。</p><p><strong>3，自关联</strong></p><p><img src="/../img/node.png" alt="img"></p><p>自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。</p><h4 id="2-3-2-2-聚合关系"><a href="#2-3-2-2-聚合关系" class="headerlink" title="2.3.2.2 聚合关系"></a>2.3.2.2 聚合关系</h4><p>聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。</p><p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p><p>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：</p><p><img src="/../img/image-20191229173422328.png" alt="img"></p><h4 id="2-3-2-3-组合关系"><a href="#2-3-2-3-组合关系" class="headerlink" title="2.3.2.3 组合关系"></a>2.3.2.3 组合关系</h4><p>组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。</p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p><p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：</p><p><img src="/../img/image-20191229173455149.png" alt="img"></p><h4 id="2-3-2-4-依赖关系"><a href="#2-3-2-4-依赖关系" class="headerlink" title="2.3.2.4 依赖关系"></a>2.3.2.4 依赖关系</h4><p>依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p><p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：</p><p><img src="/../img/image-20191229173518926.png" alt="img"></p><h4 id="2-3-2-5-继承关系"><a href="#2-3-2-5-继承关系" class="headerlink" title="2.3.2.5 继承关系"></a>2.3.2.5 继承关系</h4><p>继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。</p><p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示：</p><p><img src="/../img/image-20191229173539838.png" alt="img"></p><h4 id="2-3-2-6-实现关系"><a href="#2-3-2-6-实现关系" class="headerlink" title="2.3.2.6 实现关系"></a>2.3.2.6 实现关系</h4><p>实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p><p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。</p><p><img src="/../img/image-20191229173554296.png" alt="img"></p><h1 id="3，软件设计原则"><a href="#3，软件设计原则" class="headerlink" title="3，软件设计原则"></a>3，软件设计原则</h1><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p><h2 id="3-1-开闭原则"><a href="#3-1-开闭原则" class="headerlink" title="3.1 开闭原则"></a>3.1 开闭原则</h2><p><strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p><p>想要达到这样的效果，我们需要使用接口和抽象类。</p><p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p><p>下面以 <code>搜狗输入法</code> 的皮肤为例介绍开闭原则的应用。</p><p>【例】<code>搜狗输入法</code> 的皮肤设计。</p><p>分析：<code>搜狗输入法</code> 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。</p><p><img src="/../img/open-close.png" alt="img"></p><h2 id="3-2-里氏代换原则"><a href="#3-2-里氏代换原则" class="headerlink" title="3.2 里氏代换原则"></a>3.2 里氏代换原则</h2><p>里氏代换原则是面向对象设计的基本原则之一。</p><p>里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p><p>下面看一个里氏替换原则中经典的一个例子</p><p>【例】正方形不是长方形。</p><p>在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。</p><p><img src="/../img/%E6%AD%A3%E6%96%B9%E5%BD%A2%E4%B8%8D%E6%98%AF%E9%95%BF%E6%96%B9%E5%BD%A2.png" alt="img"></p><p>代码如下：</p><p><strong>长方形类（Rectangle）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> length;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> width;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getLength</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLength</span><span class="hljs-params">(<span class="hljs-type">double</span> length)</span> &#123;<br>        <span class="hljs-built_in">this</span>.length = length;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getWidth</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> width;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWidth</span><span class="hljs-params">(<span class="hljs-type">double</span> width)</span> &#123;<br>        <span class="hljs-built_in">this</span>.width = width;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>正方形（Square）：</strong></p><p>由于正方形的长和宽相同，所以在方法setLength和setWidth中，对长度和宽度都需要赋相同值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWidth</span><span class="hljs-params">(<span class="hljs-type">double</span> width)</span> &#123;<br>        <span class="hljs-built_in">super</span>.setLength(width);<br>        <span class="hljs-built_in">super</span>.setWidth(width);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLength</span><span class="hljs-params">(<span class="hljs-type">double</span> length)</span> &#123;<br>        <span class="hljs-built_in">super</span>.setLength(length);<br>        <span class="hljs-built_in">super</span>.setWidth(length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类RectangleDemo是我们的软件系统中的一个组件，它有一个resize方法依赖基类Rectangle，resize方法是RectandleDemo类中的一个方法，用来实现宽度逐渐增长的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RectangleDemo</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(Rectangle rectangle)</span> &#123;<br>        <span class="hljs-keyword">while</span> (rectangle.getWidth() &lt;= rectangle.getLength()) &#123;<br>            rectangle.setWidth(rectangle.getWidth() + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//打印长方形的长和宽</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLengthAndWidth</span><span class="hljs-params">(Rectangle rectangle)</span> &#123;<br>        System.out.println(rectangle.getLength());<br>        System.out.println(rectangle.getWidth());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Rectangle</span> <span class="hljs-variable">rectangle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>();<br>        rectangle.setLength(<span class="hljs-number">20</span>);<br>        rectangle.setWidth(<span class="hljs-number">10</span>);<br>        resize(rectangle);<br>        printLengthAndWidth(rectangle);<br><br>        System.out.println(<span class="hljs-string">&quot;============&quot;</span>);<br><br>        <span class="hljs-type">Rectangle</span> <span class="hljs-variable">rectangle1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Square</span>();<br>        rectangle1.setLength(<span class="hljs-number">10</span>);<br>        resize(rectangle1);<br>        printLengthAndWidth(rectangle1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们运行一下这段代码就会发现，假如我们把一个普通长方形作为参数传入resize方法，就会看到长方形宽度逐渐增长的效果，当宽度大于长度,代码就会停止，这种行为的结果符合我们的预期；假如我们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度都在不断增长，代码会一直运行下去，直至系统产生溢出错误。所以，普通的长方形是适合这段代码的，正方形不适合。<br>我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。</p><p>如何改进呢？此时我们需要重新设计他们之间的关系。抽象出来一个四边形接口(Quadrilateral)，让Rectangle类和Square类实现Quadrilateral接口</p><p><img src="/../img/%E6%AD%A3%E6%96%B9%E5%BD%A2%E4%B8%8D%E6%98%AF%E9%95%BF%E6%96%B9%E5%BD%A2%E6%94%B9%E8%BF%9B.png" alt="img"></p><h2 id="3-3-依赖倒转原则"><a href="#3-3-依赖倒转原则" class="headerlink" title="3.3 依赖倒转原则"></a>3.3 依赖倒转原则</h2><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p><p>下面看一个例子来理解依赖倒转原则</p><p>【例】组装电脑</p><p>现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。</p><p><strong>类图如下：</strong></p><p><img src="/../img/%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99.png" alt="img"></p><p>代码如下：</p><p><strong>希捷硬盘类（XiJieHardDisk）:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XiJieHardDisk</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HardDisk</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(String data)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;使用希捷硬盘存储数据&quot;</span> + data);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;使用希捷希捷硬盘取数据&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;数据&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Intel处理器（IntelCpu）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelCpu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cpu</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;使用Intel处理器&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>金士顿内存条（KingstonMemory）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KingstonMemory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Memory</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;使用金士顿作为内存条&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>电脑（Computer）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> XiJieHardDisk hardDisk;<br>    <span class="hljs-keyword">private</span> IntelCpu cpu;<br>    <span class="hljs-keyword">private</span> KingstonMemory memory;<br><br>    <span class="hljs-keyword">public</span> IntelCpu <span class="hljs-title function_">getCpu</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cpu;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCpu</span><span class="hljs-params">(IntelCpu cpu)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cpu = cpu;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> KingstonMemory <span class="hljs-title function_">getMemory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> memory;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMemory</span><span class="hljs-params">(KingstonMemory memory)</span> &#123;<br>        <span class="hljs-built_in">this</span>.memory = memory;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> XiJieHardDisk <span class="hljs-title function_">getHardDisk</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> hardDisk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHardDisk</span><span class="hljs-params">(XiJieHardDisk hardDisk)</span> &#123;<br>        <span class="hljs-built_in">this</span>.hardDisk = hardDisk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;计算机工作&quot;</span>);<br>        cpu.run();<br>        memory.save();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> hardDisk.get();<br>        System.out.println(<span class="hljs-string">&quot;从硬盘中获取的数据为：&quot;</span> + data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试类（TestComputer）：</strong></p><p>测试类用来组装电脑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestComputer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Computer</span> <span class="hljs-variable">computer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>();<br>        computer.setHardDisk(<span class="hljs-keyword">new</span> <span class="hljs-title class_">XiJieHardDisk</span>());<br>        computer.setCpu(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IntelCpu</span>());<br>        computer.setMemory(<span class="hljs-keyword">new</span> <span class="hljs-title class_">KingstonMemory</span>());<br><br>        computer.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码可以看到已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件。</p><p>根据依赖倒转原则进行改进：</p><p>代码我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类。</p><p><strong>类图如下：</strong></p><p><img src="/../img/%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99%E6%94%B9%E8%BF%9B.png" alt="img"></p><p><strong>电脑（Computer）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> HardDisk hardDisk;<br>    <span class="hljs-keyword">private</span> Cpu cpu;<br>    <span class="hljs-keyword">private</span> Memory memory;<br><br>    <span class="hljs-keyword">public</span> HardDisk <span class="hljs-title function_">getHardDisk</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> hardDisk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHardDisk</span><span class="hljs-params">(HardDisk hardDisk)</span> &#123;<br>        <span class="hljs-built_in">this</span>.hardDisk = hardDisk;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Cpu <span class="hljs-title function_">getCpu</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cpu;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCpu</span><span class="hljs-params">(Cpu cpu)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cpu = cpu;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Memory <span class="hljs-title function_">getMemory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> memory;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMemory</span><span class="hljs-params">(Memory memory)</span> &#123;<br>        <span class="hljs-built_in">this</span>.memory = memory;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;计算机工作&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。</p><h2 id="3-4-接口隔离原则"><a href="#3-4-接口隔离原则" class="headerlink" title="3.4 接口隔离原则"></a>3.4 接口隔离原则</h2><p>客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。</p><p>下面看一个例子来理解接口隔离原则</p><p>【例】安全门案例</p><p>我们需要创建一个<code>黑马</code>品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下：</p><p><img src="/../img/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99.png" alt="img"></p><p>上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图：</p><p><img src="/../img/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%991.png" alt="img"></p><p>代码如下：</p><p><strong>AntiTheft（接口）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AntiTheft</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">antiTheft</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Fireproof（接口）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fireproof</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fireproof</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Waterproof（接口）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Waterproof</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">waterproof</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>HeiMaSafetyDoor（类）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeiMaSafetyDoor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AntiTheft</span>,Fireproof,Waterproof &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">antiTheft</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;防盗&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fireproof</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;防火&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waterproof</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;防水&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ItcastSafetyDoor（类）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItcastSafetyDoor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AntiTheft</span>,Fireproof &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">antiTheft</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;防盗&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fireproof</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;防火&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-5-迪米特法则"><a href="#3-5-迪米特法则" class="headerlink" title="3.5 迪米特法则"></a>3.5 迪米特法则</h2><p>迪米特法则又叫最少知识原则。</p><p>只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。</p><p>其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><p>下面看一个例子来理解迪米特法则</p><p>【例】明星与经纪人的关系实例</p><p>明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。</p><p>类图如下：</p><img src="../img/迪米特法则.png" alt="image-20191229173554296" style="zoom:80%;" /><p>代码如下：</p><p><strong>明星类（Star）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Star</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Star</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>粉丝类（Fans）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fans</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Fans</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>媒体公司类（Company）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Company</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Company</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>经纪人类（Agent）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Agent</span> &#123;<br>    <span class="hljs-keyword">private</span> Star star;<br>    <span class="hljs-keyword">private</span> Fans fans;<br>    <span class="hljs-keyword">private</span> Company company;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStar</span><span class="hljs-params">(Star star)</span> &#123;<br>        <span class="hljs-built_in">this</span>.star = star;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFans</span><span class="hljs-params">(Fans fans)</span> &#123;<br>        <span class="hljs-built_in">this</span>.fans = fans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCompany</span><span class="hljs-params">(Company company)</span> &#123;<br>        <span class="hljs-built_in">this</span>.company = company;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meeting</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(fans.getName() + <span class="hljs-string">&quot;与明星&quot;</span> + star.getName() + <span class="hljs-string">&quot;见面了。&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">business</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(company.getName() + <span class="hljs-string">&quot;与明星&quot;</span> + star.getName() + <span class="hljs-string">&quot;洽淡业务。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-6-合成复用原则"><a href="#3-6-合成复用原则" class="headerlink" title="3.6 合成复用原则"></a>3.6 合成复用原则</h2><p>合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p><p>通常类的复用分为继承复用和合成复用两种。</p><p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：</p><ol><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>对象间的耦合度低。可以在类的成员位置声明抽象。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ol><p>下面看一个例子来理解合成复用原则</p><p>【例】汽车分类管理程序</p><p>汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下： </p><img src="../img/合成复用原则.png" alt="image-20191229173554296" style="zoom:80%;" /><p>从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。</p><img src="../img/合成复用原则1.png" alt="image-20191229173554296" style="zoom:80%;" /><h1 id="创建者模式"><a href="#创建者模式" class="headerlink" title="创建者模式"></a>创建者模式</h1><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。</p><p>这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。</p><p>创建型模式分为：</p><ul><li>单例模式</li><li>工厂方法模式</li><li>抽象工程模式</li><li>原型模式</li><li>建造者模式</li></ul><h2 id="4-1-单例设计模式"><a href="#4-1-单例设计模式" class="headerlink" title="4.1 单例设计模式"></a>4.1 单例设计模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><h3 id="4-1-1-单例模式的结构"><a href="#4-1-1-单例模式的结构" class="headerlink" title="4.1.1 单例模式的结构"></a>4.1.1 单例模式的结构</h3><p>单例模式的主要有以下角色：</p><ul><li><strong>单例类</strong>。只能创建一个实例的类</li><li><strong>访问类</strong>。使用单例类</li></ul><h3 id="4-1-2-单例模式的实现"><a href="#4-1-2-单例模式的实现" class="headerlink" title="4.1.2 单例模式的实现"></a>4.1.2 单例模式的实现</h3><blockquote><p>单例设计模式分类两种：</p><p>​<strong>饿汉式</strong>：类加载就会导致该单实例对象被创建</p><p>​<strong>懒汉式</strong>：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p></blockquote><ol><li><p>饿汉式-方式1（静态变量方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 饿汉式</span><br><span class="hljs-comment"> *      静态变量创建类的对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。</p></li><li><p>饿汉式-方式2（静态代码块方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 恶汉式</span><br><span class="hljs-comment"> *      在静态代码块中创建该类对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。</p></li><li><p>懒汉式-方式1（线程不安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 懒汉式</span><br><span class="hljs-comment"> *  线程不安全</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。</p></li><li><p>懒汉式-方式2（线程安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 懒汉式</span><br><span class="hljs-comment"> *  线程安全</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。</p></li><li><p>懒汉式-方式3（双重检查锁）</p><p>再来讨论一下懒汉模式中加锁的问题，对于 <code>getInstance()</code> 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：<em><strong>双重检查锁模式</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双重检查方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123; <br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>   <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">//抢到锁之后再次判断是否为null</span><br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。</p><p>要解决双重检查锁模式带来空指针异常的问题，只需要使用 <code>volatile</code> 关键字, <code>volatile</code> 关键字可以保证可见性和有序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双重检查方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>   <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">//抢到锁之后再次判断是否为空</span><br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">小结：</font></p><p>添加 <code>volatile</code> 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。</p></li><li><p>懒汉式-方式4（静态内部类方式）</p><p>静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性&#x2F;方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 静态内部类方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder</p><p>并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。</p><p><font color="red">小结：</font></p><p>​静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p></li><li><p>枚举方式</p><p>枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 枚举方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​枚举方式属于恶汉式方式。</p></li></ol><h3 id="4-1-3-存在的问题"><a href="#4-1-3-存在的问题" class="headerlink" title="4.1.3 存在的问题"></a>4.1.3 存在的问题</h3><h4 id="4-1-3-1-问题演示"><a href="#4-1-3-1-问题演示" class="headerlink" title="4.1.3.1 问题演示"></a>4.1.3.1 问题演示</h4><p>破坏单例模式：</p><p>使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。</p><ul><li><p>序列化反序列化</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Test类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//往文件中写对象</span><br>        <span class="hljs-comment">//writeObject2File();</span><br>        <span class="hljs-comment">//从文件中读取对象</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> readObjectFromFile();<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> readObjectFromFile();<br><br>        <span class="hljs-comment">//判断两个反序列化后的对象是否是同一个对象</span><br>        System.out.println(s1 == s2);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">readObjectFromFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//创建对象输入流对象</span><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));<br>        <span class="hljs-comment">//第一个读取Singleton对象</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> (Singleton) ois.readObject();<br><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeObject2File</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//获取Singleton类的对象</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br>        <span class="hljs-comment">//创建对象输出流</span><br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));<br>        <span class="hljs-comment">//将instance对象写出到文件中</span><br>        oos.writeObject(instance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面代码运行结果是<code>false</code>，表明序列化和反序列化已经破坏了单例设计模式。</p></blockquote></li><li><p>反射</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> instance;<br>            &#125;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Test类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//获取Singleton类的字节码对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Singleton.class;<br>        <span class="hljs-comment">//获取Singleton类的私有无参构造方法对象</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor();<br>        <span class="hljs-comment">//取消访问检查</span><br>        constructor.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">//创建Singleton类的对象s1</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> (Singleton) constructor.newInstance();<br>        <span class="hljs-comment">//创建Singleton类的对象s2</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> (Singleton) constructor.newInstance();<br><br>        <span class="hljs-comment">//判断通过反射创建的两个Singleton对象是否是同一个对象</span><br>        System.out.println(s1 == s2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面代码运行结果是<code>false</code>，表明序列化和反序列化已经破坏了单例设计模式</p></blockquote></li></ul><blockquote><p><font color="red">注意：</font>枚举方式不会出现这两个问题。</p></blockquote><h4 id="4-1-3-2-问题的解决"><a href="#4-1-3-2-问题的解决" class="headerlink" title="4.1.3.2 问题的解决"></a>4.1.3.2 问题的解决</h4><ul><li><p>序列化、反序列方式破坏单例模式的解决方法</p><p>在Singleton类中添加<code>readResolve()</code>方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 下面是为了解决序列化反序列化破解单例模式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>源码解析：</strong></p><p>ObjectInputStream类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">readObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException&#123;<br>    ...<br>    <span class="hljs-comment">// if nested read, passHandle contains handle of enclosing object</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">outerHandle</span> <span class="hljs-operator">=</span> passHandle;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> readObject0(<span class="hljs-literal">false</span>);<span class="hljs-comment">//重点查看readObject0方法</span><br>    .....<br>&#125;<br>    <br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readObject0</span><span class="hljs-params">(<span class="hljs-type">boolean</span> unshared)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>...<br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">switch</span> (tc) &#123;<br>...<br><span class="hljs-keyword">case</span> TC_OBJECT:<br><span class="hljs-keyword">return</span> checkResolve(readOrdinaryObject(unshared));<span class="hljs-comment">//重点查看readOrdinaryObject方法</span><br>...<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        depth--;<br>        bin.setBlockDataMode(oldMode);<br>    &#125;    <br>&#125;<br>    <br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readOrdinaryObject</span><span class="hljs-params">(<span class="hljs-type">boolean</span> unshared)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>...<br><span class="hljs-comment">//isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类，</span><br>    obj = desc.isInstantiable() ? desc.newInstance() : <span class="hljs-literal">null</span>; <br>    ...<br>    <span class="hljs-comment">// 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true</span><br>    <span class="hljs-keyword">if</span> (obj != <span class="hljs-literal">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="hljs-literal">null</span> &amp;&amp; desc.hasReadResolveMethod()) &#123;<br>    <span class="hljs-comment">// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量</span><br>    <span class="hljs-comment">// 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">rep</span> <span class="hljs-operator">=</span> desc.invokeReadResolve(obj);<br>     ...<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>反射方式破解单例的解决方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           反射破解单例模式需要添加的代码</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> instance;<br>            &#125;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">说明:</font></p><p>​这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操作。</p></li></ul><h3 id="JDK源码解析-Runtime类"><a href="#JDK源码解析-Runtime类" class="headerlink" title="JDK源码解析-Runtime类"></a>JDK源码解析-Runtime类</h3><p>Runtime类就是使用的单例设计模式。</p><ol><li><p>通过源代码查看使用的是哪儿种单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Runtime</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Runtime</span> <span class="hljs-variable">currentRuntime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runtime</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the runtime object associated with the current Java application.</span><br><span class="hljs-comment">     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance</span><br><span class="hljs-comment">     * methods and must be invoked with respect to the current runtime object.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</span><br><span class="hljs-comment">     *          Java application.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runtime <span class="hljs-title function_">getRuntime</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> currentRuntime;<br>    &#125;<br><br>    <span class="hljs-comment">/** Don&#x27;t let anyone else instantiate this class */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Runtime</span><span class="hljs-params">()</span> &#123;&#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面源代码中可以看出Runtime类使用的是恶汉式（静态属性）方式来实现单例模式的。</p></li><li><p>使用Runtime类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuntimeDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//获取Runtime类对象</span><br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br><br>        <span class="hljs-comment">//返回 Java 虚拟机中的内存总量。</span><br>        System.out.println(runtime.totalMemory());<br>        <span class="hljs-comment">//返回 Java 虚拟机试图使用的最大内存量。</span><br>        System.out.println(runtime.maxMemory());<br><br>        <span class="hljs-comment">//创建一个新的进程执行指定的字符串命令，返回进程对象</span><br>        <span class="hljs-type">Process</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> runtime.exec(<span class="hljs-string">&quot;ipconfig&quot;</span>);<br>        <span class="hljs-comment">//获取命令执行后的结果，通过输入流获取</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> process.getInputStream();<br>        <span class="hljs-type">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>* <span class="hljs-number">100</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> inputStream.read(arr);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(arr,<span class="hljs-number">0</span>,b,<span class="hljs-string">&quot;gbk&quot;</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>简单工厂模式又称为<strong>静态工厂方法模式</strong>，它属于创建型模式，在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><p><img src="/../img/3.png"></p><p><img src="/../img/4.png"></p><p>优点：对象的创建和使用分离，对象的创建交给专门的工厂类实现，程序员不需要关心怎么创建，只关心使用</p><p>缺点：简单工厂模式不够灵活，如果我门需要新增一个产品的话需要求改工厂类，比如ProductC。它需要知道产品的具体创建细节(System,out.println(“产品A”)、System,out.println(“产品B”)…..)</p><p>所以每当新增产品的时候，那么就需要工厂类去实现产品的细节，违反了<strong>开闭原则</strong>，没有扩展性</p><p><strong>开闭原则规定：对扩展是开放的，对修改是关闭的</strong></p><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p><strong>定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例话延迟到其子类</strong></p><p><img src="/../img/5.png"></p><p>在JDK中</p><p><img src="/../img/6.png"></p><p>那么Collection就是我们的抽象工厂，LinkedList和ArrayList就是我们的具体子工厂抽象产品就是Iterator,ListItr和Itr就是我们的具体产品，它们分别由我们的LinkedList和ArrayList生产。</p><p><img src="/../img/7.png"></p><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p><img src="/../img/8.png"></p><p>和工厂模式没有太大的区别，新增了一条产品线，不仅可以身材Phone，还可以生成Mask，但是我们发现，<strong>新增一条产品线也要到抽象工厂中修改代码</strong>，也违反了开闭原则</p><p><img src="/../img/9.png"></p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>作用：动态地给一个对象添加一些额外的功能。就增加功能来说，装饰器模式比生成子类(继承)更灵活。</p><p><img src="/../img/10.png"></p><p> 四个部分：</p><p>component：代表产品需要哪些功能(机器人接口)</p><p>concreteComnent : 我们的一代机器人</p><p>Decorator : 装饰器，它也是一个抽象的类(或是接口)，首先他要和机器人有同样的功能。</p><p>concreteDecorator ： 具体的装饰器，实现了Decorator</p><p>举个例子</p><p>一代机器人</p><p><img src="/../img/11.png"></p><p>在第一代的基础上推出二代机器人(继承)，新增了功能：拖地跳舞</p><p><img src="/../img/12.png"></p><p><img src="/../img/13.png"></p><p>我太厉害了，直接在一代基础上套了个<strong>壳子</strong>拓展了原有的功能，新增了功能</p><p>那么这两种都新增了功能，第一种称之为<strong>继承</strong>，继承父类，在子类中进行扩展功能，第二章称之为<strong>关联机制</strong>，那我把一个类的对象嵌入到另一个类的对象中，相当于给机器人套一个壳子给它新增功能，那么这个壳子就是我们说的装饰器</p><p>那么继承和装饰器模式有什么区别呢？</p><p>继承这种方式是静态的，一定要写一个新的子类，对类层级进行扩展</p><p>装饰器模式是动态地，我们拿到一个对象就可以对其进行扩展，不需要修改原有类逻辑</p><p><img src="/../img/14.png"></p><p><img src="/../img/15.png"></p><p>这种方式非常熟悉，我们在Java-IO流中经常看到，每次，Java-IO流大量使用到了装饰器模式。</p><p><img src="/../img/16.png"></p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用 算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分 割开来，并委派给不同的对象对这些算法进行管理。</p><p>举个生活中常见例子：洗衣机</p><p><img src="/../img/17.png"></p><p>这里洗衣程序有四种策略(更<strong>注重的是行为</strong>)：标准、浸洗、快洗、大物</p><p>作为一个程序猿，开发需要选择一款开发工具，当然可以进行代码开发的工具有很多，可以选择Idea 进行开发，也可以使用eclipse进行开发，也可以使用其他的一些开发工具。</p><p><img src="/../img/20.png"></p><p><img src="/../img/18.png"></p><ul><li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有 的具体策略类所需的接口。</li><li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行 为。</li><li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li></ul><p><img src="/../img/19.png"></p><p>我们实现线程池就可以看作策略模式 </p><h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动， 由促销员将促销活动展示给客户。类图如下：</p><p><img src="/../img/21.png"></p><p>定义百货公司所有促销活动的共同接口</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Strategy</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;买一送一&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;满200元减50元&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">StrategyC</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Strategy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> show() &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;满1000元加一元换购任意200元以下商品&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SalesMan</span> &#123;<br>    <span class="hljs-comment">//持有抽象策略角色的引用</span><br>    <span class="hljs-keyword">private</span> Strategy strategy;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SalesMan</span>(<span class="hljs-params">Strategy strategy</span>)</span> &#123;<br>        <span class="hljs-keyword">this</span>.strategy = strategy;<br>    &#125;<br>    <span class="hljs-comment">//向客户展示促销活动</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">salesManShow</span>()</span>&#123;<br>        strategy.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrategyTest</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        SalesMan salesMan = <span class="hljs-keyword">new</span> <span class="hljs-type">SalesMan</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">StrategyB</span>());<br>        salesMan.salesManShow();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>策略类之间可以自由切换</li></ul><p>由于策略类都实现一个接口，所以使他们之间可以自由切换</p><ul><li>易于扩展</li></ul><p>增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则”</p><ul><li>避免使用多重条件选择语句(if else),充分体现面向对象设计思想。</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类</li><li>策略模式将造成很多策略类，可以通过使用<strong>享元模式</strong>在一定程度上减少对象的数量</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条 件分支移入它们各自的策略类中以代替这些条件语句。</li><li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li><li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结 构。</li><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li></ul><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成的一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止</p><p><img src="/../img/22.png"></p><p>那么责任链主要有3个部分：</p><ul><li>抽象处理者(Han’dler)：定义一个处理请求的接口，包含抽象处理方法和一个后继连接</li><li>具体处理者(Concrete Handler):实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者</li><li>客户类(Client):创建处理链，并向链头的具体处理对象提交请求。它不关心处理细节和请求的传递过程。</li></ul><p><img src="/../img/23.png"></p><p><img src="/../img/24.png"></p><p><img src="/../img/25.png"></p><p><img src="/../img/26.png"></p><p><img src="/../img/27.png"></p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p><img src="/../img/28.png"></p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p><img src="/../img/29.png"></p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式(Observer Pattern):定义对象间的一种<strong>一堆多</strong>的依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新(其实就相当于发布&#x2F;订阅模式)，<strong>当一个对象的状态发生改变时，已经登记的其他对象能够观察到这一改变从而作出自己相对应的改变。通过这种方式来达到减少依赖关系，解耦合的作用。</strong></p><p>比如：举一个例子，就好比微信朋友圈，以当前个人作为订阅者，好友作为主题。一个人发一条动态朋友圈出去，他的好友都能看到这个朋友圈，并且可以在自主选择点赞或者评论。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">Subject（主题）: 主要由类实现的可观察的接口，通知观察者使用attach方法，以及取消观察的detach方法。</span><br><span class="hljs-section">ConcreteSubject（具体主题）: 是一个实现主题接口的类，处理观察者的变化</span><br><span class="hljs-section">Observe（观察者）: 观察者是一个由对象水岸的接口，根据主题中的更改而进行更新。</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">先创建一个主题定义，定义添加删除关系以及通知订阅者<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-comment">// 添加订阅关系</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Observer observer)</span>;<br>    <span class="hljs-comment">// 移除订阅关系</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(Observer observer)</span>;<br>    <span class="hljs-comment">// 通知订阅者</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">(String message)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//其次再创建的具体主题，并且构建一个容器来维护订阅关系，支持添加删除关系，以及通知订阅者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br><br>    <span class="hljs-comment">// 订阅者容器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Observer</span>&gt; observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-title class_">Observer</span>&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">attach</span>(<span class="hljs-params">Observer observer</span>) &#123;<br>        <span class="hljs-comment">// 添加订阅关系</span><br>        observers.<span class="hljs-title function_">add</span>(observer);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">detach</span>(<span class="hljs-params">Observer observer</span>) &#123;<br>        <span class="hljs-comment">// 移除订阅关系</span><br>        observers.<span class="hljs-title function_">remove</span>(observer);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">notifyObservers</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> message</span>) &#123;<br>        <span class="hljs-comment">// 通知订阅者们</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Observer</span> observer : observers) &#123;<br>            observer.<span class="hljs-title function_">update</span>(message);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个观察者接口，方便我们管理</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Observer</span> &#123;<br>    <span class="hljs-comment">// 处理业务逻辑</span><br>    <span class="hljs-built_in">void</span> update(String message);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后就是创建具体的观察者类，实现观察者接口的update方法，处理本身的业务逻辑</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FriendOneObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>   <br>  <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">update</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> message</span>) &#123;<br>        <span class="hljs-comment">// 模拟处理业务逻辑</span><br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;FriendOne 知道了你发动态了&quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后就是看测试结果了，通过ConcreteSubject 维护了一个订阅关系，在通过notifyObservers 方法通知订阅者之后，观察者都获取到消息从而处理自己的业务逻辑。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br><br>        ConcreteSubject subject = <span class="hljs-keyword">new</span> <span class="hljs-type">ConcreteSubject</span>();<br>        <span class="hljs-comment">// 这里假设是添加好友</span><br>        subject.attach(<span class="hljs-keyword">new</span> <span class="hljs-type">FriendOneObserver</span>());<br>        FriendTwoObserver twoObserver = <span class="hljs-keyword">new</span> <span class="hljs-type">FriendTwoObserver</span>();<br>        subject.attach(twoObserver);<br><br>        <span class="hljs-comment">// 发送朋友圈动态</span><br>        subject.notifyObservers(<span class="hljs-string">&quot;第一个朋友圈消息&quot;</span>);<br>        <span class="hljs-comment">// 输出结果： FriendOne 知道了你发动态了第一个朋友圈消息</span><br>        <span class="hljs-comment">//          FriendTwo 知道了你发动态了第一个朋友圈消息</span><br><br>        <span class="hljs-comment">// 这里发现 twoObserver 是个推荐卖茶叶的，删除好友</span><br>        subject.detach(twoObserver);<br>        subject.notifyObservers(<span class="hljs-string">&quot;第二个朋友圈消息&quot;</span>);<br>        <span class="hljs-comment">// 输出结果：FriendOne 知道了你发动态了第二个朋友圈消息</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/../img/30.png"></p><p>如果有新的业务添加进来，我们也只需要创建一个新的订阅者，并且维护到observers 容器中即可，也符合我们的开闭原则。</p><p>这里只是一种同步的实现方式，我们还可以扩展更多其他的异步实现方式，或者采用多线程等实现方式。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
